<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GaoQ&#39;s blog</title>
  <subtitle>There are no shortcuts to any place worth going</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gaoquan.wang/"/>
  <updated>2017-06-04T12:59:59.810Z</updated>
  <id>http://gaoquan.wang/</id>
  
  <author>
    <name>GaoQ</name>
    <email>729006199@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试下</title>
    <link href="http://gaoquan.wang/2017/06/04/%E6%B5%8B%E8%AF%95%E4%B8%8B/"/>
    <id>http://gaoquan.wang/2017/06/04/测试下/</id>
    <published>2017-06-04T12:59:33.000Z</published>
    <updated>2017-06-04T12:59:59.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你好&quot;&gt;&lt;a href=&quot;#你好&quot; class=&quot;headerlink&quot; title=&quot;你好&quot;&gt;&lt;/a&gt;你好&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>live-server和http-server</title>
    <link href="http://gaoquan.wang/2016/10/26/live-server%E5%92%8Chttp-server/"/>
    <id>http://gaoquan.wang/2016/10/26/live-server和http-server/</id>
    <published>2016-10-26T03:04:05.000Z</published>
    <updated>2017-06-04T12:54:20.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>I find that the harder I work, the more luck I seem to have.</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>前端开发的过程中，总有这样的需求。想快速在移动端，PC端看看页面的效果，看看交互的效果。通常我们会自己搭建一个服务器，或简单或复杂。<br>这里推荐的两个live-server和http-server是基于nodejs的快速搭建服务器的插件。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>当然首先在用这两个live-server和http-server的前提是你要安装nodejs。<br>然后起个terminal窗口，全局安装live-server和http-server。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g live-server</div><div class="line">npm install -g http-server</div></pre></td></tr></table></figure></p>
<p>安装完毕后，你就可以在你需要其服务的目录下直接输入<code>live-server</code>或者<code>http-server</code></p>
<h2 id="live-server和http-server的区别"><a href="#live-server和http-server的区别" class="headerlink" title="live-server和http-server的区别"></a><a href="https://github.com/tapio/live-server" target="_blank" rel="external">live-server</a>和<a href="https://github.com/indexzero/http-server" target="_blank" rel="external">http-server</a>的区别</h2><p><code>live-server</code>提供的功能是：</p>
<ol>
<li>由于安全限制，AJAX的请求不能是<code>file://</code>的协议。因此你需要创建一个server来调用AJAX请求</li>
<li><code>live-server</code>另一个用途是，当所要监控的文件发生变化，页面会自动刷新，且十分方便简单。</li>
</ol>
<p><code>http-server</code>功能就略微单一，只是一个简单的无须配置的http服务器。</p>
<h2 id="live-server和http-server的命令行的使用"><a href="#live-server和http-server的命令行的使用" class="headerlink" title="live-server和http-server的命令行的使用"></a>live-server和http-server的命令行的使用</h2><p>关于live-server和http-server命令行的使用，比如如何设置port、host等等，具体的请查看对应的github进行查看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;I find that the harder I work, the more luck I seem to have.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="教程" scheme="http://gaoquan.wang/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="live-server" scheme="http://gaoquan.wang/tags/live-server/"/>
    
      <category term="http-server" scheme="http://gaoquan.wang/tags/http-server/"/>
    
      <category term="nodejs" scheme="http://gaoquan.wang/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>CSS_3D_Panorama</title>
    <link href="http://gaoquan.wang/2016/08/31/CSS_3D_Panorama/"/>
    <id>http://gaoquan.wang/2016/08/31/CSS_3D_Panorama/</id>
    <published>2016-08-31T02:37:01.000Z</published>
    <updated>2017-06-04T12:54:20.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Tomorrow is never clear.Our time is here.</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>3D全景并不是什么新鲜事物了，但以前我们在Web上看到的3D全景一般是通过flash实现的。若我们能将CSS3 Transform的相关知识运用得当，也是能实现类似的效果。换句话说，3D全景其实就是CSS3 3D的应用场景之一。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在实现CSS3 3D全景之前，我们先理清部分CSS3 Transform属性：</p>
<ul>
<li>Transform-origin: 元素变形的原点（默认值为 50% 50% 0，该数值和后续提及的百分比均默认基于元素自身的宽高算出具体数值）;</li>
<li>perspective: 指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果（默认值：none，值只能是绝对长度，即负数是非法值）;</li>
<li>transform-style: 用于指定其为子元素提供2D还是3D的场景。另外，该属性是非继承的。</li>
<li>transform: 该属性能让你修改CSS可视化模型的坐标空间，其中包括平移(translate)、旋转(rotate)、缩放(scale)和扭曲(skew).</li>
</ul>
<p>下面对上述的一些点进行更深入的分析：</p>
<ul>
<li>perspective，该属性指定了“眼睛”与元素的<code>perspective-origin</code>(默认值为50% 50%)点的距离。那么问题来了：“当我们应用px作为衡量单位时，那它的实际距离该如何量化呢（即如何得到我们熟悉且易于表达的距离）?”  当我们的屏幕的分辨率是1080p(1920*1080px)，且该元素或祖先元素的perspective值为1920px时，该应用了CSS3 3D Transform的元素的立体效果就相当于我们我们在一个屏幕宽度(1920px)的屏幕前观看该元素的真是效果。尽管如此，目前我也不清楚如何准确地为元素设置一个合适的perspective的值，只能猜测个大概值，然后再动态修改值，以达到满意的呈现效果。<br><img src="/images/CSS3D/perspective.jpg" alt="呈现效果"><br>根据相似三角形的性质可计算出被前移的元素最终在屏幕上显示的实际大小</li>
</ul>
<p>另外，关于perspective还有另外一个重要的点。因为，<code>perspective-origin</code>的默认值为50% 50%,因此对哪个元素应用perspective属性，就决定了“眼睛”的位置(即我们的“眼睛”是在哪个角度看物体)。一般来说，当我们需要正视物体时，就会将该属性设置在与 <strong>该元素中心重合的某一祖先元素上</strong>。</p>
<p>再另外，如果说“如何让一个元素(背面)不可见?”，你可能会说backface-visibility:hidden。其实，对于在“眼睛”背后的元素(以元素的<code>transform-origin</code>为参考点)， <strong>即元素的z轴坐标值大于perspective的值，浏览器是不会将其渲染出来的</strong>。</p>
<ul>
<li>对于<code>transform-style</code>，该属性指定了其子元素是处于3D场景还是2D场景。对于2D场景，元素的前后位置是按照平时的渲染方式(即若在普通文档流中，是按照代码中元素的先后顺序，后面的元素会遮住在其前面的元素)；对于3D场景，元素的前后位置是按照真实世界的规则排序(即越靠近“眼睛”的，会遮住离“眼睛”更远的元素)。 另外，由于 <strong>transform-style属性是非继承性的，对于中间节点需要显示设定</strong></li>
<li>对于transform属性：下图整理了rotate3d、translate3d的变化方向：<br><img src="/images/CSS3D/transform.jpg" alt="变换方向"><br>transform中的变换属性的顺序是有关系的，如transformX(10px)rotate(30deg)与rotate(30deg)transformX(10px)是不等价的。</li>
</ul>
<p>另外，需要注意的是scale中如果有负数值，则该方向会产生180度的翻转。再另外，部分transform效果会导致元素(字体)模糊，如translate的数值存在小数、通过translateZ或scale方法元素等等。每个浏览器都有其不同的表现。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>上面理清了一些CSS Transform的知识点，下面就讲讲如何实现CSS 3D全景：</p>
<p>想象一下，当我们站在十字路口中间，身体不动，头部旋转 360°，这个过程中所看到的画面就形成了一幅以你为中心的全景图了。其实，当焦距不变时，我们就等同于站在一个圆柱体的中心。</p>
<p>但是，虚拟世界与现实的最大不同是：没有东西是连续的，即所有东西都是离散的。例如，你无法在屏幕上显示一个完美的圆。你只能以一个正多边形表示圆：边越多，圆就越“完美”。</p>
<p>同理，在三维空间，每个 3D 模型都等同于一个多面体（即 3D 模型只能由不弯曲的平面组成）。当我们讨论一个本身就是多面体（如立方体）的模型时并不足以为奇，但当我们想展示其它模型时，如球体时，就需要记住这个原理了。<br><img src="/images/CSS3D/ball.png" alt="球体模型"></p>
<p><a href="http://zwj360.im20.com.cn/" target="_blank" rel="external">淘宝造物节的活动页</a>就是CSS 3D全景的一个很赞的页面，它将全景图分隔成20等份，相邻的元素间差18deg(360/20)。需要注意的是：我们要确保每个元素的正面是指向圆柱中心的，所以要计算好每等份的旋转角度值。然后再将元素向外(即Z轴方向)平移r px.对于立方体r就是边长/2，而对于其他更复杂的正多面体呢？</p>
<p>举例：对于正九面体，每个元素的宽为210px，对应的角度为40deg，例如下图：<br><img src="/images/CSS3D/diagram.png" alt="正九面体的俯视图"><br><img src="/images/CSS3D/calc.png" alt="计算过程"></p>
<p>由此得到一个公用函数，只需传入含有元素的宽度和元素数量的对象，即可得到r值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calTranslateZ</span>(<span class="params">opts</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(opts.width/(<span class="number">2</span>*<span class="built_in">Math</span>.tan(<span class="built_in">Math</span>.PI/opts.number)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">calTranslateZ(&#123;</div><div class="line">  <span class="attr">width</span>: <span class="number">210</span>,</div><div class="line">  <span class="attr">number</span>: <span class="number">9</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="/images/CSS3D/expand4.gif" alt="俯视时所看到的元素外移动画"></p>
<p>另外，为了让下文易于理解，我们约定html结构是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#view(perspective:1000px)</div><div class="line">  #stage(transform-style: perserve-3d)</div><div class="line">    #cube(transform-style: perserve-3d)</div><div class="line">      .div(width:600px;height:600px) /*组成立方体的元素*/</div></pre></td></tr></table></figure></p>
<p>正多面体构建完成后，就需要将我们的“眼睛”放置在正多面体内。由于在“眼睛”后的元素是不会被浏览器所渲染的（与 .div元素 是否设置 backface-visibility:hidden; 无关），且我们保证了.div元素的正面都指向了正多面体的中心，这就形成360deg被环绕的效果了。<br>那“眼睛”具体是被放置在哪个位置？<br>答：通过设置#stage元素的translateZ的值，让不能被看到的.div元素的Z轴坐标值大于perspective的值即可。如：立方体的正面的translateZ是-300px(为了保证立方体的正面是指向立方体中心，正面元素需要设置rotate(-180deg) translateZ(-300px), 即正面元素向“眼球”方向平移了300px),而#view的perspective的值为1000px，那么 #stage 的 translateZ 的值应该大于 700px 且小于 1300px，具体数值则取决于你想要呈现的效果了。</p>
<p>可由下图看出，将水平的 4 张图片合成后就是一张全景图：<br><img src="/images/CSS3D/panorama3d.jpg" alt="4张图合成的全景图"></p>
<p>理解上述知识后，就可以通过为元素设置合适的 CSS3 Transform 属性值，即可实现一张可交互的全景图了。当然，交互的效果可以是拖拽，也可以是重力感应等。</p>
<p>正如在上文提到的：“没有东西是连续的，即所有东西都是离散的…”。将《造物节》与后续全景图的水平方向上的图片分别合成一张图后，可以发现：图片数量越多，图片的要求也越低。你觉得呢？<br><img src="/images/CSS3D/zaowujie.jpg" alt="造物节全景图"></p>
<h2 id="全景图素材的制作"><a href="#全景图素材的制作" class="headerlink" title="全景图素材的制作"></a>全景图素材的制作</h2><p>将全景图制作分为设计类与实景类：</p>
<h3 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h3><p>要制作类似 <a href="http://zwj360.im20.com.cn/" target="_blank" rel="external">《淘宝造物节》</a> 的全景页面，设计稿需要有以下这些要求。</p>
<p>整体背景设计图如下（2580*1170px，被分成 20 等份）：<br><img src="/images/CSS3D/zaowujie.jpg" alt="造物节全景图"></p>
<p>基本要求：</p>
<ul>
<li>水平方向上需要首尾相连；</li>
<li>因为效果图最终需要切成 N 等份，所以尽可能让 设计图的宽度能被 N 整除；</li>
<li>图片尺寸不仅要考虑正视图的大小，还要考虑元素在旋转时依然能覆盖视野（可选）。</li>
</ul>
<p>当然，上图只是背景图，还可以添加一些小物体素材（通过运动速度的差异形成视差，增强立体效果），如：<br><img src="/images/CSS3D/item3.jpg" alt="小物体元素1"><br><img src="/images/CSS3D/item1.jpg" alt="小物体元素2"></p>
<p>小物体元素（虚线是用于参考的，造物节中共有 21 个小物体）</p>
<p>如上图所示，每个图片也是被等分成 M 等份。当然，M 取决于物体在背景上的具体位置和本身大小。<br>另外，M 的宽度是与 N 的宽度相等的。尽管部分物体（M&gt;1）的两侧等份的图案占比小，但建议保留同样的宽度。</p>
<p>注：如果小物体有特殊的变形效果，应该备注具体变形参数。</p>
<p>对于顶部和底图图片，则无特殊要求。</p>
<h3 id="实景类"><a href="#实景类" class="headerlink" title="实景类"></a>实景类</h3><p>如果想制作实景的全景，可以看看 Google 街景：<br><a href="https://www.google.com/streetview/publish/" target="_blank" rel="external">Google街景</a>推荐的设备如下：<br><img src="/images/CSS3D/panorama_machine.jpg" alt="实景类工具"></p>
<p>处理全景的方式：</p>
<ul>
<li>利用 RICOH THETA S 等专业设备拍出全景图</li>
<li>导出静态图像</li>
<li>利用设备专门提供的 APP 或 krpamo tools、pano2vr、Glsky box 等工具将静态图像转为6张图</li>
<li>利用 Web 技术制作可交互的全景图</li>
</ul>
<p>其中 Web 技术有以下3种可选方式（当然，还有其它）：</p>
<ul>
<li>CSS3（本文所提及的方式）</li>
<li>Three.js</li>
<li>krpano（为全景而生，低级浏览器则回退到 Flash），<a href="http://krpano.com/docu/tutorials/quickstart/?from=groupmessage&amp;isappinstalled=0#top" target="_blank" rel="external">查看教程</a></li>
</ul>
<p>可见，优秀硬件设备的出现，大大减少了后期处理的时间，而 Web 则提供了一个很好的展现平台。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>随着终端设备的软硬件不断完善和提高，Web 在 3D 领域也不甘落后，如果你玩腻了 2D 的 H5 或者想为用户提供更加新颖优秀的体验，全景也许是一种选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Tomorrow is never clear.Our time is here.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/
    
    </summary>
    
      <category term="转载笔记" scheme="http://gaoquan.wang/categories/%E8%BD%AC%E8%BD%BD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="http://gaoquan.wang/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何运用最新的技术提升网页速度和性能</title>
    <link href="http://gaoquan.wang/2016/08/28/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87%E7%BD%91%E9%A1%B5%E9%80%9F%E5%BA%A6%E5%92%8C%E6%80%A7%E8%83%BD/"/>
    <id>http://gaoquan.wang/2016/08/28/如何运用最新的技术提升网页速度和性能/</id>
    <published>2016-08-28T06:50:27.000Z</published>
    <updated>2017-06-04T12:54:20.295Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>What doesn’t kill you makes you stronger.</p>
</blockquote>
<h2 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h2><p>在我们的项目中，我们每天都会和设计师和产品负责人讨论关于平衡美观和性能的问题。对于我们自己的网站，这样做是很简单的。简言之，我们认为好的用户体验从快速的内容传输开始，也就是意味着性能&gt;美观。</p>
<p>好的内容、布局、图片和交互是吸引用户的重要因素。这每个因素都会影响页面的加载时间和终端用户体验。每一步我们都在探讨如何在获得好的用户体验和保证设计美感的同时，最小化对性能的影响。</p>
<h2 id="内容优先"><a href="#内容优先" class="headerlink" title="内容优先"></a>内容优先</h2><p>我们想要把核心内容尽快呈现给用户，意味着我们要处理好基本的HTML和CSS。每个页面都应该达到基本的目的：传递信息。JS、CSS、网页字体、图片、网站分析等优化都是位居于核心内容之下的。</p>
<h2 id="可控性"><a href="#可控性" class="headerlink" title="可控性"></a>可控性</h2><p>给理想网站定义了标准后，我们总结出：想要达到预期效果，就要能对网站各方面的控制都游刃有余。我们选择构建自己的静态站点生成器，包括资源传输，并且由我们自己操控。</p>
<h2 id="静态站点生成器"><a href="#静态站点生成器" class="headerlink" title="静态站点生成器"></a>静态站点生成器</h2><p>我们用nodejs实现了静态站点生成器。它是采用带有简短JSON页面描述标签的Markdown文件来生成整个网站结构和它所有的资源。为了包括特殊的脚本页面，也可以附带一个HTML文件。以下是一个简单化的描述标签和markdown文件，用于博客的发布，用它来生成真正的HTML.</p>
<p>JSON描述标签：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"keywords"</span>: [<span class="string">"performance"</span>, <span class="string">"critical rendering path"</span>, <span class="string">"static site"</span>],</div><div class="line"><span class="string">"publishDate"</span>: <span class="string">"2016-08-28"</span>,</div><div class="line"><span class="string">"authors"</span>: [<span class="string">"Co"</span>]</div></pre></td></tr></table></figure></p>
<p>markdown文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Title</div><div class="line">## Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></pre></td></tr></table></figure></p>
<h2 id="图片传输"><a href="#图片传输" class="headerlink" title="图片传输"></a>图片传输</h2><p>平均一个2406kb的网页中1535kb是图片。就因为图片在网站中占据了这么大一个比例，所以它也是性能优化的重点之一。</p>
<h2 id="Webp格式"><a href="#Webp格式" class="headerlink" title="Webp格式"></a>Webp格式</h2><p>Webp是一种现在图片格式，为网页图片提供了出色的低损耗、有损压缩。Webp格式的图片实质上比其他格式的小，有时可以比同样的JPEG图片小25%。Webp被大多数人所忽略，也没有被经常使用。截止到写这篇文章的时候，Webp仅支持Chrome、Opera和Android(仍超过我们50%的用户)，但我们可以优雅降级为JPG/PNG。</p>
<p>使用<picture>元素我们可以把图片从Webp优雅地降级到其他被广发支持的图片格式，如JPEG：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;picture&gt;</div><div class="line">  &lt;source type="image/webp" srcset="image-1.webp" media="(min-width: 640px)"&gt;</div><div class="line">  &lt;source type="image/webp" srcset="image-m.webp" media="(min-width: 320px)"&gt;</div><div class="line">  &lt;source type="image/webp" srcset="image-s.webp"&gt;</div><div class="line">  &lt;source srcset="image-1.jpg" media="(min-width: 640px)"&gt;</div><div class="line">  &lt;source srcset="image-m.jpg" media="(min-width: 320px)"&gt;</div><div class="line">  &lt;source srcset="image-s.jpg"&gt;</div><div class="line">  &lt;img alt="Description of the image" src="image-1.jpg"&gt;</div><div class="line">&lt;/picture&gt;</div></pre></td></tr></table></figure></picture></p>
<p>我们使用Scott Jehl 的picturefill来使那些不支持<picture>元素的浏览器获得支持，在各个浏览器中达到一致的效果。</picture></p>
<p>我们使用<img>作为那些不支持<picture>或者JS的浏览器的后备元素。使用图片的最大实例确保了它在后备方案中的可行性。</picture></p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>尽管图片传输方式已经确定了，我们仍需要思考怎样有效执行。我喜欢<picture>元素的功能，但不喜欢上面那些代码段，尤其是写内容是必须把它加进去。我们不想做这么费力的事情：每张图片都要写6个实例，所以优化这些图片并且把它们写在markdown文件的<picture>里面。所以：</picture></picture></p>
<h2 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h2><p>在构建过程中，原图片的多个实例，包括JPG、PNG和Webp格式，我们使用gulp responsive来生成。</p>
<h2 id="最小化图片"><a href="#最小化图片" class="headerlink" title="最小化图片"></a>最小化图片</h2><p>在markdown文件中写图片描述(image.jpg).</p>
<p>在构建过程中使用自定义markdown渲染器来为已经完全成熟的<picture>元素编译传统的markdown图片声明。</picture></p>
<h2 id="SVG动画"><a href="#SVG动画" class="headerlink" title="SVG动画"></a>SVG动画</h2><p>我们为自己的网站选择了特定的图表类型，其中SVG插图占了主要地位。这样做有以下几个原因：首先，SVG的图片比位图更小；其二，SVG图片本身就是响应式的，有很棒的伸缩性，所以不需要图片生成及<picture>元素；最后一点也是很重要的一点，就是我们可以通过CSS来不断改变它，赋予它新的活力！我们所有的组合页面都有一个自定义的动态SVG图，可以被概述页面所复用。这张图片作为我们所有的组合页面中的一种循环风格，使得页面设计一体化，同时又几乎不会对性能造成影响。请看这张动画，看看我们是如何用CSS来改变它的。<br><img src="/images/SEO/0.gif" alt="例子"></picture></p>
<h2 id="自定义网页字体"><a href="#自定义网页字体" class="headerlink" title="自定义网页字体"></a>自定义网页字体</h2><p>在深入之前，这里有一个关于在浏览器设置自定义字体的简短介绍。当浏览器发现CSS里面有@font-face的定义，但是用户的电脑并不支持该字体时，它会尝试下载该字体文件。在下载时，多数浏览器根本不会用这种字体来展示文本。这种现象称为“不可见文本的闪现”或者FOIT.如果你有留意，你会发现网页上都有这种情况存在。如果你问我，我会告诉你这会影响用户体验。它延迟了用户读取他们所需内容的时间。我们可以迫使浏览器改变这种行为，变成“无样式内容闪现”或者称为FOUT。我们告诉浏览器先使用普通字体，想Arial或者Georgia。当自定义的字体下载完成后，再代替标准字体并且重新渲染。这样，即使自定义字体只是一种优化。尽管没有自定义字体，网页看起来也完好，也能百分百的正常运行。勾选/不勾选复选框来切换我们的网页字体，来自己体验一下：<br>切换下载的字体类使用自定义网页字体可以改善我们的用户体验，只要你能够优化他们，并且负责任地为之服务。</p>
<h2 id="字型子集设定"><a href="#字型子集设定" class="headerlink" title="字型子集设定"></a>字型子集设定</h2><p>到目前为止，子集设定以最短的时间在改善网页字体性能方面取胜。我将会向每个使用自定义字体的网页开发者推荐子集设定。如果你能完全控制网页内容，并且知道它将要展示哪些特性的话，你可以完全使用子集设定。但是，即使是仅仅把字体设为西方语言，也会对文件大小造成很大的影响。例如，我们的Noto Regular WOFF 字体，默认是246KB，将其设为西方语言后，大小下降到31KB。我们使用Font squirrel webfont，这种字体真的很易用。</p>
<h2 id="字体监听器"><a href="#字体监听器" class="headerlink" title="字体监听器"></a>字体监听器</h2><p>Bram Stein推出的字体监听器是一个很了不起的脚本，可以帮助检查字体是否已被加载。至于你是如何加载字体的，是通过一个网页字体服务，还是自己上传就不可知了。在这个监听器告诉我们所有自定义的字体已经下载完毕后，我们就可以在<html>元素上添加一个字体加载完毕的类，我们的页面就会重新用心的字体：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span>&#123;</div><div class="line">  <span class="attribute">font-family</span>: Georgia, serif;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">html</span><span class="selector-class">.fonts-loaded</span>&#123;</div><div class="line">  <span class="attribute">font-family</span>: Noto, Georgia, serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure></html></p>
<p>注意：为了简短，我们有给上面的CSS中的Noto加上@font-face的声明。</p>
<p>我们可以设定一个cookie来记住所有的字体已经被加载过，就可以让他们缓存在浏览器里面了。我们使用这个cookie来替代重复的视图，这个我后续会解释。</p>
<p>在不久的将来，我们或许不需要Bram Stein的脚本来监听这个行为。CSS开发团队已经提案一个新的@font-face描述器，也叫font-display。它的属性值控制着一个可下载的字体是如何在还没加载出来时就渲染页面的。这是CSS对font-display的描述：它将带给我们像上面方法一样的行为效果。你可以读读更多关于font-display的属性。</p>
<h2 id="JS和CSS懒加载"><a href="#JS和CSS懒加载" class="headerlink" title="JS和CSS懒加载"></a>JS和CSS懒加载</h2><p>一般来讲，我们都是尽可能快的加载需要的资源。我们移除一些堵塞的请求来加快页面渲染，优化首屏，用浏览器缓存来处理重复的页面。</p>
<h3 id="JS懒加载"><a href="#JS懒加载" class="headerlink" title="JS懒加载"></a>JS懒加载</h3><p>设计上，我们的网站并没有很多JS。我们发展了一个javascript工作流来处理我们目前已有的js，以及未来会用到的js资源。</p>
<p>JS在<head>块里面渲染，这是我们想要的。JS应该只是用来提高用户体验，不应该是访问者需要的关键。处理JS堵塞渲染的简单方法就是把脚本放在页面的尾部。这样网页就会在真个HTML渲染完毕后才去加载JS。</head></p>
<p>另一种可以把脚本放在head执行的方案就是在<code>&lt;script&gt;</code>标签里面添加defer属性，来延迟脚本的执行。由于浏览器下载脚本是很快的，不会堵塞页面渲染进程，等到页面完全加载完，才会执行脚本里面的代码。还有一件事，我们没有使用像jQuery这些库，所以我们的脚本取决于vanilla脚本的特性。我们只是想要在浏览器加载脚本来支持这些特性。最终的结果就像下面的代码这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">if</span>(<span class="string">'querySelector'</span> <span class="keyword">in</span> <span class="built_in">document</span> &amp;&amp; <span class="string">'addEventListener'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</div><div class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;script src="index.js" defer&gt;&lt;/script&gt;'</span>);</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们把这小段脚本放在页面头部，来检测浏览器是否支持vanilla javascript的document.querySelector和window.addEventListener属性。如果支持，我们通过<code>&lt;script&gt;</code>标签直接给页面加载脚本，并使用defer属性让它不会堵塞页面渲染。</p>
<h3 id="懒加载CSS"><a href="#懒加载CSS" class="headerlink" title="懒加载CSS"></a>懒加载CSS</h3><p>对于首屏来讲，网站最大的渲染堵塞资源就是CSS了。只有当<code>&lt;head&gt;</code>里面的CSS文件完全加载完毕时，浏览器才会开始渲染页面。这种做法是经过深思熟虑的，若不是这样，浏览器就需要在整个渲染过程中不断重新计算布局尺寸，不断重绘。</p>
<p>为了防止CSS堵塞渲染，我们就需要异步加载CSS文件。我们使用了Filament Group的awesome loadCSS函数。该函数提供了一个回调，当CSS文件加载完后，我们设置一个cookie来声明CSS文件已经加载了。我们使用这个cookie来重现页面，这一点我后续会解释到。</p>
<p>CSS异步加载也带来这样一个问题，尽管HTML真的很快被渲染出来，但看起来只有纯粹的HTML，只有等到这个CSS文件加载完且停止时，才会有样式。这时就要提到关键CSS了。</p>
<h3 id="关键部分CSS"><a href="#关键部分CSS" class="headerlink" title="关键部分CSS"></a>关键部分CSS</h3><p>关键部分CSS可以这样来理解：它就是阻塞浏览器渲染出用户可识别的网页的一小部分CSS。我们注意网页的上半版版面。很明显，两个设备的版面的位置有很大的区别。因此我们做了一个大胆的猜测。</p>
<p>手动地检测这部分关键性的CSS是个很耗时的过程，尤其是样式、特性等不断改变时。这里有几个好的脚本，可以在你构建网页时，生成关键CSS。我们采用了Addy Osmani的版本。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们自己部署de Voorhoede网站，因为我们希望能够控制服务器环境。我们也想要尝试，是否可以通过改变服务器的配置来大大提升性能。当前我们使用了Apache服务和HTTPS协议。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了提升性能和安全性，我们研究了如何配置服务端。</p>
<p>我们使用H5BP apache样板配置，这个对改善Apache网络服务的性能和安全性是个很好的开始。他们也有其他服务器环境的配置。对于我们的大部分 HTML、CSS 和 JS，我们使用GZIP压缩。对于我们的所有网站资源，都使用缓存HTTP标头的做法。请阅读下面关于缓存的章节。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>用HTTPS来服务你的网站会对性能造成影响。这主要是设置了SSL握手，引入了大量潜在的东西。但通常情况下，我们可以做一些改变！</p>
<p>HTTP Strict Transport Security是一个HTTP标头，可以让服务器告诉浏览器只能用HTTPS来与它交互。这种方式防止HTTP请求被重定向为HTTPS。所有尝试用HTTP来访问站点的请求都会被自动转换成HTTPS。它可以来回的服务我们的网站。</p>
<p>TLS false start允许客户端在第一个TLS回合结束后，马上开始向后端发送加密的数据。这种优化为给一个回合新建一个TLS连接减少了握手。一旦客户端知道了密钥，就可以开始传输应用数据。剩下的握手用来确认是否有人篡改握手记录，并且可以并行处理。</p>
<p>TLS session resumption通过确认浏览器和服务器是否已经通过TLS取得联系来帮我们节省另一个来回。浏览器会记住这一次的标识符，下次发起连接时，这个标识符就会被重用，节省了一个来回。</p>
<h2 id="cookies的使用"><a href="#cookies的使用" class="headerlink" title="cookies的使用"></a>cookies的使用</h2><p>我们没有用一门服务端的语言，只有静态的Apache网络服务。但一个Apache网络服务仍可以做包括SSI在内的后端服务，并且读取cookies。通过巧用cookies和运行那部分被Apache改写的HTML，我们可以大大提升前端性能。下面这个例子就是。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!-- #if expr="($HTTP_COOKIE!=/css-loaded/) || ($HTTP_COOKIE=/.css-loaded=([^;]+);?.*/&amp;&amp; $&#123;1&#125; != 0d82f.css)" --&gt;</div><div class="line">&lt;noscript&gt;&lt;link rel="stylesheet" href="0d82f.css"&gt;&lt;/noscript&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  (function()&#123;</div><div class="line">    function loadCSS(url)&#123;&#125;</div><div class="line">    function onloadCss(stylesheet,callback)&#123;&#125;</div><div class="line">    function setCookie(name, value, expInDays)&#123;&#125;</div><div class="line"></div><div class="line">    var stylesheet = loadCSS('0d82f.css');</div><div class="line">    onloadCss(stylesheet, function()&#123;</div><div class="line">      setCookie('css-loaded', '0d82f', 100);</div><div class="line">    &#125;)</div><div class="line">  &#125;)()</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;style&gt;/*critical CSS here*/&lt;/styles&gt;</div><div class="line"></div><div class="line">&lt;link rel="stylesheet" href="0d82f.css"&gt;</div></pre></td></tr></table></figure></p>
<p>The Apache server side logic are the comment looking lines starting with Apache 服务端逻辑是一些看起来一行一行的评论，一般这样开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!-- #. Let&apos;s look at this step by step: $HTTP_COOKIE!=/css-loaded/ checks if no CSS cache cookie exists yet. $HTTP_COOKIE=/.css-loaded=([^;]+);?./ &amp;&amp; $&#123;1&#125; != &apos;0d82f.css&apos; checks if the cached CSS version is not the current version.</div></pre></td></tr></table></figure></p>
<p>If <!-- #if expr="..." --> 如果是true的话，我们就假定这是用户的第一次浏览。</p>
<p>第一次浏览我们添加了 <noscript> 标签，里面放置了 <link rel="stylesheet">。之所以这样做，是因为我们要异步加载整份CSS和JS。如果JS不能用的话，这种做法是不能执行的。这意味着，我们要用常规的加载CSS的方法来做回退。</noscript></p>
<p>我们添加了一个行内的脚本来懒加载CSS，onloadCSS 回调里面可以设置cookies.</p>
<p>在同一份脚本里面，我们异步加载了整份CSS。</p>
<p>在 onloadCSS的回调里面，我们用版本号来设置cookie的值。</p>
<p>在这个脚本后面，我们添加了一行关键CSS的样式。这个会阻塞渲染，但时间是非常短的，而且可以避免页面展示出来只有纯粹的HTML而没有样式的情况。</p>
<p><!-- #else --> 声明（意味着 css-loaded 的cookie 已经存在）用户重复浏览。因为我们可以从某种程度上来假定，CSS文件之前已经被加载过了，我们可以利用浏览器缓存来提供样式表。这样从缓存里面加载速度就很快了。同样的方法也被用来在第一次异步加载字体，后续的重复浏览也是从缓存里面获取字体。</p>
<h2 id="文件级缓存"><a href="#文件级缓存" class="headerlink" title="文件级缓存"></a>文件级缓存</h2><p>由于我们在重现页面时很大程度上依赖于浏览器缓存，所以我们需要确认我们的缓存是否合理。理想中我们是要永远的存储资源（CSS、js、 字体、图片），只有当这些文件被修改时才需要更新。当请求的URL是唯一时，缓存就会失效。每更新一个版本，我们都会用 git tag 打个标签。所以最简单的方式就是给我们请求的URL加上一个参数（代码版本号），如 <a href="https://www.voorhoede.nl/assets/css/main-8af99277a6.css?v=1.0.4.。" target="_blank" rel="external">https://www.voorhoede.nl/assets/css/main-8af99277a6.css?v=1.0.4.。</a></p>
<p>但是，这种做法的缺点就是当我们要写一个新的博客post（这也是我们代码库的一部分，并没有永久地存储在CMS），原来缓存的资源将会失效，尽管没有改变原来那些资源。</p>
<p>就在我们尝试去改善这种方法时，我们发现了 gulp-rev 和 gulp-rev-replace 。这些脚本会自动合理地在我们的文件名称后面添加一窜hash值。这意味着只有实际上文件被改变时，才会去改变请求的URL，这样每个文件的缓存就会自动失效。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>如果你看到这里，你应该是想要知道成果的。测试网页的性能可以采用像 PageSpeed Insights 这样的工具，它有很实用的提示。也可以使用 WebPagetest来测试，有扩展性的网络分析。我认为测试网页渲染性能的最好方法就是在疯狂地遏制网络通信时来观察网页的进程。这意味着，用一种不切实际的方法来遏制通信。在谷歌浏览器，你可以这样操作 (via the inspector &gt; Network tab) 来限制通信，观察网页形成过程中，请求是如何缓慢加载的。</p>
<p>下面是我们的网页在 50KB/s 的情况下的加载状况。<br>这是 de Voorhoede site 首屏的网络分析，是网页第一次进程的一个概览。</p>
<p>注意到在50KB/s的网速中，我们是如何让首屏的渲染只用了 2.27 秒的。也就是第一张幻灯片和瀑布图里面的黄色线所代表的位置。黄线恰好绘在就是HTML已经加载完的时间位置。HTML包含了关键CSS，保证页面的可观性。所有其他的CSS都是用懒加载，所以我们可以等到全部资源加载完时才与页面进行交互。这也是我们想要的效果！</p>
<p>另一个值得注意的就是自定义字体从来不在这缓慢的链接上加载。 font face 观察器会自动注意到这一点。但是，如果我们不异步加载字体，你注视大多数浏览器，都会出现 FOIT(不可见文本的闪现，上文有提及)的情况。</p>
<p>所有的CSS文件仅在8s后就都加载完毕。相反，如果我们不采用加载关键CSS的方式，而是采用加载全部CSS，我们在前8秒看到的将会是空白的页面。</p>
<p>如果你感到好奇，想与那些不太注重性能的网站对比一下加载时间，那赶紧试试吧。那个时间肯定是飞涨啊！</p>
<p>用上面介绍的工具测试了我们的网站，结果也是让人满意的。 PageSpeed insights 在移动性能方面给了我们100分，多么了不起啊！</p>
<p>PageSpeed insights 对 voorhoede.nl的测试结果! 速度100分！g</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;What doesn’t kill you makes you stronger.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;性能设计&quot;&gt;&lt;a href=&quot;#性能设计&quot; class=&quot;headerlink&quot; title=&quot;性能设计&quot;&gt;&lt;/
    
    </summary>
    
      <category term="转载笔记" scheme="http://gaoquan.wang/categories/%E8%BD%AC%E8%BD%BD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式二</title>
    <link href="http://gaoquan.wang/2016/08/18/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/"/>
    <id>http://gaoquan.wang/2016/08/18/JavaScript设计模式二/</id>
    <published>2016-08-18T06:06:04.000Z</published>
    <updated>2017-06-04T12:54:20.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Comedy is acting out optimism.</p>
</blockquote>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>字典中中介者的定义是，一个中立方，在谈判和冲突解决过程中起辅助作用。在我们的世界，一个中介者是一个行为设计模式，使我们可以导出统一的接口，这样系统不同部分就可以彼此通信。</p>
<p>如果系统组件之间存在大量的直接关系，就可能是时候，使用一个中心的控制点，来让不同的组件通过它来通信。中介者通过将组件之间显示的直接的引用替换成通过中心点来交互的方式，做到松耦合。这样可以帮助我们解耦和改善组件的重用性。</p>
<p>在现实世界中，类似的系统就是，飞行控制系统。一个航站塔(中介者)处理哪个飞机可以起飞，哪个可以着陆，因为所有的通信(监听的通知或者广播的通知)都是飞机和控制塔之间进行的，而不是飞机和飞机之间进行的额。一个中央集权的控制中心是这个系统成功的关键，也正是中介者在软件设计领域中所扮演的角色。</p>
<p>从实现角度来讲，中介者模式是观察者模式中的共享被观察者对象。在这个系统中的对象之间直接的发布/订阅关系被牺牲掉了，取而代之的是维护一个通信的中心节点。</p>
<p>也可以认为是一种补充-用于应用级别的通知，例如不同子系统之间的通信，子系统本身很复杂，可能需要使用发布/订阅模式来做内部之间的解耦。</p>
<p>另外一个类似的例子是DOM的事件冒泡机制，以及事件代理机制。如果系统中所有的订阅者都是对文档订阅，而不是对独立的节点订阅，那么文档就充当一个中介者的角色。DOM的这种做法，不是将事件绑定到独立节点上，而是用一个更高级别的对象负责通知订阅者关于交互事件的信息。</p>
<h3 id="基础的实现"><a href="#基础的实现" class="headerlink" title="基础的实现"></a>基础的实现</h3><p>中介者模式的一种简单的实现可以在下面找到，publish()和subscribe()犯法都被暴露出来使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Storage for topics that can be broadcast or listened to</span></div><div class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Subscribe to a topic, supply a callback to be executed</span></div><div class="line">  <span class="comment">// when that topic is broadcast to</span></div><div class="line">  <span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span>(<span class="params"> topic, fn </span>)</span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ( !topics[topic] )&#123;</div><div class="line">        topics[topic] = [];</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      topics[topic].push( &#123; <span class="attr">context</span>: <span class="keyword">this</span>, <span class="attr">callback</span>: fn &#125; );</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Publish/broadcast an event to the rest of the application</span></div><div class="line">  <span class="keyword">var</span> publish = <span class="function"><span class="keyword">function</span>(<span class="params"> topic </span>)</span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">var</span> args;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ( !topics[topic] )&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      args = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</div><div class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = topics[topic].length; i &lt; l; i++ ) &#123;</div><div class="line"></div><div class="line">          <span class="keyword">var</span> subscription = topics[topic][i];</div><div class="line">          subscription.callback.apply( subscription.context, args );</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">publish</span>: publish,</div><div class="line">      <span class="attr">subscribe</span>: subscribe,</div><div class="line">      <span class="attr">installTo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">          obj.subscribe = subscribe;</div><div class="line">          obj.publish = publish;</div><div class="line">      &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<h3 id="高级的实现"><a href="#高级的实现" class="headerlink" title="高级的实现"></a>高级的实现</h3><p>更高级的实现方式，首先，让我们实现认购的概念，我们可以考虑一个中介者主题的注册。<br>通过生成对象实体，我们稍后能够简单的更新认购，而不需要去取消注册然后重新注册它们。认购可以写成一个使用被称作一个选项对象或者一个上下文环境的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Pass in a context to attach our Mediator to.</span></div><div class="line"><span class="comment">//By default this will be the window object</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">guidGenerator</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//Our Subscriber constructor</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Subscriber</span>(<span class="params">fn, options, context</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Subscriber))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber(fn, context, options);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//guidGenerator() is a function that generates</span></div><div class="line">        <span class="comment">//GUIDs for instances of our Mediators Subscribers so we can easily reference them later on. We're going to skip its implementation for brevity</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.id = guidGenerator();</div><div class="line">        <span class="keyword">this</span>.fn = fn;</div><div class="line">        <span class="keyword">this</span>.options = options;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">        <span class="keyword">this</span>.topic = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>在我们的中介者模式中包含了一长串的回调和子主题，当中间人发布在我们中间人实体上被调用的时候被启动。它也包含操作数据列表方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Let's model the topic</span></div><div class="line"><span class="comment">//JavaScript lets us use a Function object as a conjunction of a prototype for use with the new object and a constructor function to be invoked.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Topic</span>(<span class="params">namespace</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Topic))&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Topic(namespace);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">this</span>.namespace = namespace || <span class="string">""</span>;</div><div class="line">    <span class="keyword">this</span>._callbacks = [];</div><div class="line">    <span class="keyword">this</span>._topics = [];</div><div class="line">    <span class="keyword">this</span>.stopped = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Define the prototype for our topic, including ways to add new subscribers or retrieve existing ones.</span></div><div class="line">Topic.prototype = &#123;</div><div class="line">  <span class="comment">//Add a new subscriber</span></div><div class="line">  AddSubscriber: <span class="function"><span class="keyword">function</span>(<span class="params">fn,options,context</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> callback = <span class="keyword">new</span> Subscriber(fn, options, context);</div><div class="line">    <span class="keyword">this</span>._callbacks.push(callback);</div><div class="line">    callback.topic = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> callback;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们的主题实体被当做中间人调用的一个参数被传递。使用一个方便实用的calledStopPropagation()方法，回调就可以进一步被传播开来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">StopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.stopped: <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也能够使得当提供一个GUID的标识符的时候检索订购用户更加容易:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">GetSubscriber: <span class="function"><span class="keyword">function</span>(<span class="params">identifier</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>,y=<span class="keyword">this</span>._callbacks.length; x&lt;y ; x++)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._callbacks[x].id == identifier || <span class="keyword">this</span>._callbacks[x].fn == identifier)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._callbacks[x];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> z <span class="keyword">in</span> <span class="keyword">this</span>._topics)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._topics.hasOwnProperty(z))&#123;</div><div class="line">      <span class="keyword">var</span> sub = <span class="keyword">this</span>._topics[z].GetSubscriber(identifier);</div><div class="line">      <span class="keyword">if</span>(sub !== <span class="literal">undefined</span>)(</div><div class="line">        <span class="keyword">return</span> sub;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着，在我们需要它们的情况下，我们也能够提供添加新主题，检查现有的主题或者检索主题的简单方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AddTopic: <span class="function"><span class="keyword">function</span>(<span class="params"> topic </span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>._topics[topic] = <span class="keyword">new</span> Topic( (<span class="keyword">this</span>.namespace ? <span class="keyword">this</span>.namespace + <span class="string">":"</span> : <span class="string">""</span>) + topic );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="attr">HasTopic</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> topic </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._topics.hasOwnProperty( topic );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="attr">ReturnTopic</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> topic </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._topics[topic];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们觉得不再需要它们了,我们也可以明确的删除这些订购用户.下面就是通过它的其子主题递归删除订购用户的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">RemoveSubscriber: <span class="function"><span class="keyword">function</span>(<span class="params"> identifier </span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>( !identifier )&#123;</div><div class="line">    <span class="keyword">this</span>._callbacks = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> z <span class="keyword">in</span> <span class="keyword">this</span>._topics )&#123;</div><div class="line">      <span class="keyword">if</span>( <span class="keyword">this</span>._topics.hasOwnProperty(z) )&#123;</div><div class="line">        <span class="keyword">this</span>._topics[z].RemoveSubscriber( identifier );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> y = <span class="number">0</span>, x = <span class="keyword">this</span>._callbacks.length; y &lt; x; y++ ) &#123;</div><div class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>._callbacks[y].fn == identifier || <span class="keyword">this</span>._callbacks[y].id == identifier )&#123;</div><div class="line">      <span class="keyword">this</span>._callbacks[y].topic = <span class="literal">null</span>;</div><div class="line">      <span class="keyword">this</span>._callbacks.splice( y,<span class="number">1</span> );</div><div class="line">      x--; y--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着我们通过递归子主题将发布任意参数的能够包含到订购服务对象中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Publish: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> y = <span class="number">0</span>, x = <span class="keyword">this</span>._callbacks.length; y &lt; x; y++ ) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> callback = <span class="keyword">this</span>._callbacks[y], l;</div><div class="line">          callback.fn.apply( callback.context, data );</div><div class="line"></div><div class="line">      l = <span class="keyword">this</span>._callbacks.length;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>( l &lt; x )&#123;</div><div class="line">        y--;</div><div class="line">        x = l;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> x <span class="keyword">in</span> <span class="keyword">this</span>._topics )&#123;</div><div class="line">      <span class="keyword">if</span>( !<span class="keyword">this</span>.stopped )&#123;</div><div class="line">        <span class="keyword">if</span>( <span class="keyword">this</span>._topics.hasOwnProperty( x ) )&#123;</div><div class="line">          <span class="keyword">this</span>._topics[x].Publish( data );</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.stopped = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接着我们暴露我们将主要交互的调节实体.这里它是通过注册的并且从主题中删除的事件来实现的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mediator</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Mediator) ) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Mediator();</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">this</span>._topics = <span class="keyword">new</span> Topic( <span class="string">""</span> );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>想要更多先进的用例,我们可以看看调解支持的主题命名空间,下面这样的asinbox:messages:new:read.GetTopic 返回基于一个命名空间的主题实体。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Mediator.prototype = &#123;</div><div class="line"></div><div class="line">  <span class="attr">GetTopic</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> namespace </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> topic = <span class="keyword">this</span>._topics,</div><div class="line">        namespaceHierarchy = namespace.split( <span class="string">":"</span> );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( namespace === <span class="string">""</span> )&#123;</div><div class="line">      <span class="keyword">return</span> topic;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( namespaceHierarchy.length &gt; <span class="number">0</span> )&#123;</div><div class="line">      <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, j = namespaceHierarchy.length; i &lt; j; i++ )&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( !topic.HasTopic( namespaceHierarchy[i]) )&#123;</div><div class="line">          topic.AddTopic( namespaceHierarchy[i] );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        topic = topic.ReturnTopic( namespaceHierarchy[i] );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> topic;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>这一节我们定义了一个Mediator.Subscribe方法，它接受一个主题命名空间,一个将要被执行的函数,选项和又一个在订阅中调用函数的上下文环境.这样就创建了一个主题,如果这样的一个主题存在的话<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Subscribe: <span class="function"><span class="keyword">function</span>(<span class="params"> topiclName, fn, options, context </span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> options = options || &#123;&#125;,</div><div class="line">      context = context || &#123;&#125;,</div><div class="line">      topic = <span class="keyword">this</span>.GetTopic( topicName ),</div><div class="line">      sub = topic.AddSubscriber( fn, options, context );</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sub;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>根据这一点,我们可以进一步定义能够访问特定订阅用户,或者将他们从主题中递归删除的工具<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns a subscriber for a given subscriber id / named function and topic namespace</span></div><div class="line"></div><div class="line">GetSubscriber: <span class="function"><span class="keyword">function</span>(<span class="params"> identifier, topic </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.GetTopic( topic || <span class="string">""</span> ).GetSubscriber( identifier );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Remove a subscriber from a given topic namespace recursively based on</span></div><div class="line"><span class="comment">// a provided subscriber id or named function.</span></div><div class="line"></div><div class="line">Remove: <span class="function"><span class="keyword">function</span>(<span class="params"> topicName, identifier </span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.GetTopic( topicName ).RemoveSubscriber( identifier );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>我们主要的发布方式可以让我们随意发布数据到选定的主题命名空间，这可以在下面的代码中看到。</p>
<p>主题可以被向下递归.例如,一条对inbox:message的post将发送到inbox:message:new和inbox:message:new:read.它将像接下来这样被使用:Mediator.Publish( “inbox:messages:new”, [args] );<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Publish: <span class="function"><span class="keyword">function</span>(<span class="params"> topicName </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span>, <span class="number">1</span>),</div><div class="line">        topic = <span class="keyword">this</span>.GetTopic( topicName );</div><div class="line"></div><div class="line">    args.push( topic );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.GetTopic( topicName ).Publish( args );</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>最后，我们可以很容易的暴露我们的中间人，将它附着在传递到根中的对象上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root.Mediator = Mediator;</div><div class="line">  Mediator.Topic = Topic;</div><div class="line">  Mediator.Subscriber = Subscriber;</div><div class="line"></div><div class="line">  <span class="comment">// Remember we can pass anything in here. I've passed inwindowto</span></div><div class="line">  <span class="comment">// attach the Mediator to, but we can just as easily attach it to another</span></div><div class="line">  <span class="comment">// object if desired.</span></div><div class="line">&#125;)( <span class="built_in">window</span> );</div></pre></td></tr></table></figure></p>
<h3 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点&amp;缺点"></a>优点&amp;缺点</h3><p>中间人模式最大的好处就是，它节约了对象或者组件之间的通信信道，这些对象或者组件存在于从多对多到多对一的系统之中。由于解耦合水平的因素，添加新的发布或者订阅者是相对容易的。</p>
<p>也许使用这个模式最大的缺点是它可以引入一个单点故障。在模块之间放置一个中间人也可能会造成性能损失，因为它们经常是间接地的进行通信的。由于松耦合的特性，仅仅盯着广播很难去确认系统是如何做出反应的。</p>
<p>这就是说，提醒我们自己解耦合的系统拥有许多其它的好处，是很有用的——如果我们的模块互相之间直接的进行通信，对于模块的改变（例如：另一个模块抛出了异常）可以很容易的对我们系统的其它部分产生多米诺连锁效应。这个问题在解耦合的系统中很少需要被考虑到。</p>
<p>在一天结束的时候，紧耦合会导致各种头痛，这仅仅只是另外一种可选的解决方案，但是如果得到正确实现的话也能够工作得很好。</p>
<h3 id="中间人Vs观察者"><a href="#中间人Vs观察者" class="headerlink" title="中间人Vs观察者"></a>中间人Vs观察者</h3><p>中间人模式最大的好处就是，它节约了对象或者组件之间的通信信道，这些对象或者组件存在于从多对多到多对一的系统之中。由于解耦合水平的因素，添加新的发布或者订阅者是相对容易的。</p>
<p>也许使用这个模式最大的缺点是它可以引入一个单点故障。在模块之间放置一个中间人也可能会造成性能损失，因为它们经常是间接地的进行通信的。由于松耦合的特性，仅仅盯着广播很难去确认系统是如何做出反应的。</p>
<p>这就是说，提醒我们自己解耦合的系统拥有许多其它的好处，是很有用的——如果我们的模块互相之间直接的进行通信，对于模块的改变（例如：另一个模块抛出了异常）可以很容易的对我们系统的其它部分产生多米诺连锁效应。这个问题在解耦合的系统中很少需要被考虑到。</p>
<p>在一天结束的时候，紧耦合会导致各种头痛，这仅仅只是另外一种可选的解决方案，但是如果得到正确实现的话也能够工作得很好。</p>
<h3 id="中间人Vs门面"><a href="#中间人Vs门面" class="headerlink" title="中间人Vs门面"></a>中间人Vs门面</h3><p>不久我们的描述就将涵盖门面模式，但作为参考之用，一些开发者也想知道中间人和门面模式之间有哪些相似之处。它们都对模块的功能进行抽象，但有一些细微的差别。</p>
<p>中间人模式让模块之间集中进行通信，它会被这些模块明确的引用。门面模式却只是为模块或者系统定义一个更加简单的接口，但不添加任何额外的功能。系统中其他的模块并不直接意识到门面的概念，而可以被认为是单向的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Comedy is acting out optimism.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://gaoquan.wang/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式</title>
    <link href="http://gaoquan.wang/2016/08/17/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/"/>
    <id>http://gaoquan.wang/2016/08/17/JavaScript设计模式一/</id>
    <published>2016-08-17T02:13:37.000Z</published>
    <updated>2017-06-04T12:54:20.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>A particular fine spring came around.</p>
</blockquote>
<h2 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h2><p>在面向对象编程中，构造器是一个当新建对象的内存被分配后，用来初始化该对象的一个特殊函数。在JavaScript中几乎所有的东西都是对象，我们经常会对对象的构造器十分感兴趣。<br>对象构造器是被用来创建特殊类型的对象的，首先它要准备使用的对象，其次在对象初次被创建时，通过接收参数，构造器要用来对成员的属性和方法进行赋值。</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>下面是我们创建对象的三种基本方式：<br>下面的每一种都会创建一个新的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObject = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">var</span> newObject = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">var</span> newObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure></p>
<p>最后一个例子中”Object”构造器创建了一个针对特殊值的对象包装，只不过这里没有传值给它，所以它将会返回一个空对象。<br>有四种方式可以将一个键值对赋给一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 3 兼容形式</span></div><div class="line"><span class="comment">//1.“点号”法</span></div><div class="line">newObject.someKey = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line"><span class="comment">//获取属性</span></div><div class="line"><span class="keyword">var</span> key = newObject.someKey;</div><div class="line"></div><div class="line"><span class="comment">// 2. “方括号”法</span></div><div class="line"></div><div class="line"><span class="comment">// 设置属性</span></div><div class="line">newObject[<span class="string">"someKey"</span>] = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取属性</span></div><div class="line"><span class="keyword">var</span> key = newObject[<span class="string">"someKey"</span>];</div><div class="line"></div><div class="line"><span class="comment">//ECMAScript 5 仅兼容性形式</span></div><div class="line"><span class="comment">//3.Object.defineProperty方式</span></div><div class="line"></div><div class="line"><span class="comment">//设置属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(newObject, <span class="string">"someKey"</span>, &#123;</div><div class="line">  <span class="attr">value</span>: <span class="string">"hello world"</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//如果上面的方式你感到难以阅读，可以简短的写成下面这样：</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> defineProp = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key, value</span>)</span>&#123;</div><div class="line">  config.value = value;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, config);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为了使用它，我么需要创建一个"person"对象</span></div><div class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//用属性构造对象</span></div><div class="line">defineProp(person, <span class="string">"car"</span>, <span class="string">"Delorean"</span>);</div><div class="line">defineProp(person, <span class="string">"dateOfBirth"</span>, <span class="string">"1981"</span>);</div><div class="line">defineProp(person, <span class="string">"hasBeard"</span>, <span class="string">"false"</span>);</div><div class="line"></div><div class="line"><span class="comment">//4.Object.defineProperties方式</span></div><div class="line"><span class="built_in">Object</span>.defineProperties(newObject, &#123;</div><div class="line">  <span class="string">"someKey"</span>: &#123;</div><div class="line">     <span class="attr">value</span>: <span class="string">"Hello World"</span>,</div><div class="line">     <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">   &#125;,</div><div class="line"></div><div class="line">   <span class="string">"anotherKey"</span>: &#123;</div><div class="line">     <span class="attr">value</span>: <span class="string">"Foo bar"</span>,</div><div class="line">     <span class="attr">writable</span>: <span class="literal">false</span></div><div class="line">   &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 3和4中的读取属行可用1和2中的任意一种</span></div></pre></td></tr></table></figure></p>
<p>在这本书的后面，这些方法会被用于继承，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个继承与person的赛车司机</span></div><div class="line"><span class="keyword">var</span> driver = <span class="built_in">Object</span>.create(person);</div><div class="line"></div><div class="line"><span class="comment">//设置司机的属性</span></div><div class="line">defineProp(driver, <span class="string">"topSpeed"</span>, <span class="string">"100mph"</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取继承的属性</span></div><div class="line"><span class="built_in">console</span>.log(driver.dateOfBirth);</div><div class="line"></div><div class="line"><span class="comment">//获取我们设置的属性</span></div><div class="line"><span class="built_in">console</span>.log(driver.topSpeed);</div></pre></td></tr></table></figure></p>
<h3 id="基础构造器"><a href="#基础构造器" class="headerlink" title="基础构造器"></a>基础构造器</h3><p>正如我们先前所看到的，javascript不支持类的概念，但它有一种与对象一起工作的构造器函数。使用new关键字来调用该函数，我们可以告诉JavaScript把这个函数当做一个构造器来用，它可以用自己所定义的成员来初始化一个对象。</p>
<p>在这个构造器内部，关键字this引用到刚被创建的对象。回到对象创建，一个基本的构造函数看起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">model, year, miles</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.model = model;</div><div class="line">  <span class="keyword">this</span>.year = year;</div><div class="line">  <span class="keyword">this</span>.miles = miles;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="keyword">this</span>.miles;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用，我们可以实例化一个Car</span></div><div class="line"><span class="keyword">var</span> civic = <span class="keyword">new</span> Car(<span class="string">"Honda Civic"</span>, <span class="number">2009</span>, <span class="number">20000</span>);</div><div class="line"><span class="keyword">var</span> mondeo = <span class="keyword">new</span> Car(<span class="string">"Ford Mondeo"</span>, <span class="number">2010</span>, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">//output of the toString() method being called on these objects</span></div><div class="line"><span class="built_in">console</span>.log(civic.toString());</div><div class="line"><span class="built_in">console</span>.log(mondeo.toString());</div></pre></td></tr></table></figure></p>
<p>上面这是个简单版本的构造器模式，但它还是有些问题。一个是难以继承，另一个是每个Car构造函数创建的对象中，toString()之类的函数都被重新定义。这不是非常好，理想的情况是所有Car类型的对象都应该应用同一个函数。ECMAScript3和ECMAScript5-兼容版，对于构造对象他们提供了另外一些选择，解决限制小菜一碟。</p>
<h3 id="使用“原型”的构造器"><a href="#使用“原型”的构造器" class="headerlink" title="使用“原型”的构造器"></a>使用“原型”的构造器</h3><p>在JavaScript中函数有一个prototype的属性。当我们调用JavaScript的构造器创建一个对象时，构造函数prototype上的属性对于所创建的对象来说都可见。照这样，就可以创建多个访问相同prototype的Car对象了。下面，我们来扩展一下原来的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">model, year, miles</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.model = model;</div><div class="line">  <span class="keyword">this</span>.year = year;</div><div class="line">  <span class="keyword">this</span>.miles = miles;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Car.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="string">" has done "</span> + <span class="keyword">this</span>.miles + <span class="string">" miles"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> civic = <span class="keyword">new</span> Car( <span class="string">"Honda Civic"</span>, <span class="number">2009</span>, <span class="number">20000</span> );</div><div class="line"><span class="keyword">var</span> mondeo = <span class="keyword">new</span> Car( <span class="string">"Ford Mondeo"</span>, <span class="number">2010</span>, <span class="number">5000</span> );</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( civic.toString() );</div><div class="line"><span class="built_in">console</span>.log( mondeo.toString() );</div></pre></td></tr></table></figure></p>
<p>通过上面的代码，单个toString()实例被所有的Car对象所共享。</p>
<h2 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h2><p><strong>模块</strong><br>模块是任何健壮的应用程序体系结构不可或缺的一部分，特点是有助于保持应用项目的代码单元技能清晰地分离又有组织。<br>在JavaScript中，实现模块有几个选项，他们包括：</p>
<ul>
<li>模块化模式</li>
<li>对象表示法</li>
<li>AMD模块</li>
<li>CommonJS模块</li>
<li>ECMAScript Harmony模块<br>模块化模式是基于对象的文字部分。</li>
</ul>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>在对象字面值的标记里，一个对象被描述为一组以逗号分隔的名称/值对括在大括号({})的集合。对象内部的名称可以是字符串或是标记符后跟着一个冒号”:”。在对象里最后一个名称/值对不应该以”,”为结束符，因为这样会导致错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObjectLiteral = &#123;</div><div class="line">  <span class="attr">variableKey</span>: variableValue,</div><div class="line">  <span class="attr">functionKey</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象字面量不要求使用新的操作实例，但是不能够在结构体开始使用，因为打开”{“可能被解释为一个块的开始。在对象外新的成员会被加载，使用分配如下：smyModule.prototype = “someValue”;下面我们可以看到一个更完整的使用对象字面值定义一个模块的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = &#123;</div><div class="line">  <span class="attr">myProperty</span>: <span class="string">"someValue"</span>,</div><div class="line">  <span class="attr">myConfig</span>: &#123;</div><div class="line">    <span class="attr">useCaching</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">language</span>: <span class="string">"en"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Where in the world is Paul Irish today?"</span> );</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Caching is:"</span> + ( <span class="keyword">this</span>.myConfig.useCaching ) ? <span class="string">"enabled"</span> : <span class="string">"disabled"</span> );</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> newConfig </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> newConfig === <span class="string">"object"</span> ) &#123;</div><div class="line">      <span class="keyword">this</span>.myConfig = newConfig;</div><div class="line">      <span class="built_in">console</span>.log( <span class="keyword">this</span>.myConfig.language );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 输出: Where in the world is Paul Irish today?</span></div><div class="line">myModule.myMethod();</div><div class="line"></div><div class="line"><span class="comment">// 输出: enabled</span></div><div class="line">myModule.myMethod2();</div><div class="line"></div><div class="line"><span class="comment">// 输出: fr</span></div><div class="line">myModule.myMethod3(&#123;</div><div class="line">  <span class="attr">language</span>: <span class="string">"fr"</span>,</div><div class="line">  <span class="attr">useCaching</span>: <span class="literal">false</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用对象字面值可以协助封装和组织你的代码。也就是说，如果我们选择了这种技术，我们可能对模块模式有同样的兴趣。即使使用对象字面值，但也只有一个函数的返回值。</p>
<h3 id="模块化模式-1"><a href="#模块化模式-1" class="headerlink" title="模块化模式"></a>模块化模式</h3><p>模块化模式最初被定义为一种对传统软件工程的类提供私有和公共封装的方法。<br>在JavaScript中，模块化模式用来进一步模拟类的概念，通过这样一种方式：我们可以在一个单一的对象中包含公共/私有的方法和变量，从而从全局范围中屏蔽特定的部分。这个结果是可以减少我们的函数名称与在页面中其他脚本区域定义的函数名称冲突的可能性。</p>
<h3 id="私有信息"><a href="#私有信息" class="headerlink" title="私有信息"></a>私有信息</h3><p>模块模式使用闭包的方式来将“私有信息”，状态和组织结构封装起来。提供了一种将公有和私有方法，变量封装混合在一起的方式，这种方式防止内部信息泄露到全局中，从而避免了和其他开发者发生冲突的可能性。在这种模式下只有公有的API会返回，其它将全部保留在闭包的私有空间中。</p>
<p>这种方法提供了一个比较清晰的解决方案，在只暴露一个接口供其它部分使用的情况下，将执行繁重任务的逻辑保护起来。这个模式非常类似于立即调用函数表达式，但是这种模式返回的是对象，而立即调用函数表达式返回的是一个函数。</p>
<p>需要注意的是，在javaScript事实上没有一个显式的真正意义上的”私有化”概念，因为与传统语言不同，javaScript没有访问修饰符。从技术上将，变量不能被声明为公有的或私有的，因此我们使用函数域的方式去模拟这个概念。在模块模式中，因为闭包的缘故，声明的变量或者方法只在模块内部有效。在返回对象中定义的变量或者方法可以供任何人使用。</p>
<p><strong>例子</strong><br>下面这个例子通过创建一个自包含的模块实现了模块模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">incrementCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> counter++;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">resetCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"counter: "</span>,counter);</div><div class="line">      counter = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">//Increment our counter</span></div><div class="line">testModule.incrementCounter();</div><div class="line"></div><div class="line"><span class="comment">//Check the counter value and reset</span></div><div class="line"><span class="comment">//Outputs: 1</span></div><div class="line">testModule.resetCounter();</div></pre></td></tr></table></figure></p>
<p>在这里我们看到，其它部分的代码不能访问我们的incrementCounter()或者resetCounter()的值。counter变量被完全从全局域中隔离起来了，因此其表现的就像一个私有变量一样，它的存在只局限于模块的闭包内部，因此只有两个函数可以访问counter。我们的方法是有名字空间限制的，因此在我们代码的测试部分，我们需要给所有函数调用前面加上模块的名字(例如:”testModule”)。</p>
<p>当使用模块模式时，我们会发现通过使用简单的模板，对于开始使用模式非常有用。下面是一个模板包好了命名空间，公共变量和私有变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myNamespace = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> myPrivateVar, myPrivateMethod;</div><div class="line"></div><div class="line">  <span class="comment">//A private counter variable</span></div><div class="line">  myPrivateVar = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">//A private function which logs any arguments</span></div><div class="line">  myPrivateMethod = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(foo);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//A public valiable</span></div><div class="line">    myPublicVar: <span class="string">"foo"</span>,</div><div class="line"></div><div class="line">    <span class="comment">//A public function utilizing privates</span></div><div class="line">    myPublicFunction: <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</div><div class="line">      <span class="comment">// Increment our private counter</span></div><div class="line">      myPrivateVar++;</div><div class="line"></div><div class="line">      <span class="comment">// Call our private method using bar</span></div><div class="line">      myPrivateMethod( bar );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>看一下另外一个例子，下面我们看到一个使用这种模式实现的购物车。这个模块完全自包含在一个叫做basketModule全局变量中。模块中的购物车数组是私有的，应用的其他部分不能直接读取。只存在与模块的闭包中，因此只有可以访问其域的方法可以访问这个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> basketModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// privates</span></div><div class="line">  <span class="keyword">var</span> basket = [];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingPrivate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElsePrivate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return an object exposed to the public</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">// Add items to our basket</span></div><div class="line">    addItem: <span class="function"><span class="keyword">function</span>(<span class="params"> values </span>) </span>&#123;</div><div class="line">      basket.push(values);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// Get the count of items in the basket</span></div><div class="line">    getItemCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> basket.length;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// Public alias to a  private function</span></div><div class="line">    doSomething: doSomethingPrivate,</div><div class="line"></div><div class="line">    <span class="comment">// Get the total value of items in the basket</span></div><div class="line">    getTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> q = <span class="keyword">this</span>.getItemCount(),</div><div class="line">          p = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">while</span> (q--) &#123;</div><div class="line">        p += basket[q].price;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>在模块内部，你可能注意到我们返回了另外一个对象。这个自动赋值给了basketModule因此我们可以这样和这个对象交互。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// basketModule returns an object with a public API we can use</span></div><div class="line"></div><div class="line">basketModule.addItem(&#123;</div><div class="line">  <span class="attr">item</span>: <span class="string">"bread"</span>,</div><div class="line">  <span class="attr">price</span>: <span class="number">0.5</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">basketModule.addItem(&#123;</div><div class="line">  <span class="attr">item</span>: <span class="string">"butter"</span>,</div><div class="line">  <span class="attr">price</span>: <span class="number">0.3</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="comment">// Outputs: 2</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.getItemCount() );</div><div class="line"></div><div class="line"><span class="comment">// Outputs: 0.8</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.getTotal() );</div><div class="line"></div><div class="line"><span class="comment">// However, the following will not work:</span></div><div class="line"></div><div class="line"><span class="comment">// Outputs: undefined</span></div><div class="line"><span class="comment">// This is because the basket itself is not exposed as a part of our</span></div><div class="line"><span class="comment">// the public API</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.basket );</div><div class="line"></div><div class="line"><span class="comment">// This also won't work as it only exists within the scope of our</span></div><div class="line"><span class="comment">// basketModule closure, but not the returned public object</span></div><div class="line"><span class="built_in">console</span>.log( basket );</div></pre></td></tr></table></figure></p>
<p>上面的方法都处于basketModule的名字空间中。<br>请注意在上面的basket模块中，域函数是如何在我们所有的函数中被封装起来的，以及我们如何立即调用这个域函数，并且将返回值保存下来。这种方式有以下的优势：</p>
<ul>
<li>可以创建只能被我们模块访问的私有函数。这些函数没有暴露出来(只有一些API是暴露出来的)，它们被认为是完全私有的。</li>
<li>当我们在一个调试器中，需要发现哪个函数抛出异常的时候，可以很容易的看到调用栈，因为这些函数是正常声明的并且是命名的函数。</li>
<li>这种模式同样可以让我们在不同的情况下返回不同的函数。我见过有开发者使用这种技巧用于执行UA测试，目的是为了在它们的模块里面针对IE专门提供一条代码路径，但是现在我们也可以简单的使用特征检测达到相同的目的。</li>
</ul>
<h3 id="Import-mixins-导入混合"><a href="#Import-mixins-导入混合" class="headerlink" title="Import mixins(导入混合)"></a>Import mixins(导入混合)</h3><p>这个变体展示了如何将全局(例如jQuery, Underscore)作为一个参数传入模块的匿名函数。这种方式允许我们导入全局，并且按照我们的想法在本地为这些全局起一个别名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Global module</span></div><div class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params">jQ, _ </span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    jQ(<span class="string">".container"</span>).html(<span class="string">"test"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(_.min([<span class="number">10</span>,<span class="number">5</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">1000</span>]));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">publicMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      privateMethod1();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)(jQuery, _);</div><div class="line"></div><div class="line">myModule.publicMethod();</div></pre></td></tr></table></figure></p>
<h3 id="Exports-导出"><a href="#Exports-导出" class="headerlink" title="Exports(导出)"></a>Exports(导出)</h3><p>这个变体允许我们声明全局对象而不是使用它们，同样也支持在下一个例子中我们将会看到的全局导入的概念。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Global module</span></div><div class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//Module object</span></div><div class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;, privateVariable = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.publicProperty = <span class="string">"Foobar"</span>;</div><div class="line">  <span class="built_in">module</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(privateVariable);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>工具箱和框架特定的模块模式实现。</p>
<p><strong>jQuery</strong><br>因为jQuery编码规范没有规定插件如何实现模块模式，因此有很多方式可以实现模块模式。在下面的例子中，定义了一个library函数，这个函数声明了一个新的库，并且在新的库(例如模块)创建的时候，自动将初始化函数绑定到document的ready上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">library</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">module</span>.init)&#123;</div><div class="line">      <span class="built_in">module</span>.init();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myLibrary = library(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//module implementation</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p><strong>优势</strong><br>既然我们已经看到单例模式很有用，为什么还是使用模块模式呢？首先，对于有面向对象背景的开发者来讲，至少从javascript语言上来讲，模块模式相对于真正的封装概念更清晰。</p>
<p>其次，模块模式支持私有数据，因此在模块模式中，公共部分代码可以访问私有化数据，但是在模块外部，不能访问类的私有部分。</p>
<p><strong>缺点</strong><br>模块模式的缺点是因为我们采用不同的方式访问公有和私有成员，因此当我们想要改变这些成员的可见性的时候，我们不得不在所有使用这些成员的地方修改代码。</p>
<p>我们也不能在对象之后添加的方法里面访问这些私有变量。也就是说，很多情况下，模块模式很有用，并且当使用正确的时候，潜在地可以改善我们代码的结构。</p>
<p>其它缺点包括不能为私有成员创建自动化的单元测试，以及在紧急修复bug时所带来的额外的复杂性。根本没有可能可以对私有成员打补丁。相反地，我们必须覆盖所有的使用存在bug私有成员的公共方法。开发者不能简单的扩展私有成员，因此我们需要记得，私有成员并非它们表面上看上去那么具有扩展性。</p>
<h2 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h2><p>既然我们对模块模式已经有一些了解，让我们看一下改进版本 - Christian Heilmann的启发模块模式。启发模块模式来自于，当Heilmann对这样一个现状的不满，即当我们想要在一个公有方法中调用链另一个公有方法，或者访问公有变量的时候，我们不得不重复主对象的名称。他也不喜欢模块模式中，当想要将某个成员变成公共成员时，修改文字标记的做法。</p>
<p>因此他工作的结果就是一个更新的模式，在这个模式中，我们可以简单地在私有域中定义我们所有的函数和变量，并且返回一个匿名对象，这个对象包含有一些指针，这些指针指向我们想要暴露出来的私有成员，使这些私有成员公有化。</p>
<p>下面给出了一个如何使用暴露式模块模式的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVar = <span class="string">"Ben Cherry"</span>,</div><div class="line">      publicVar = <span class="string">"Hey there!"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Name: "</span> + privateVar);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicSetName</span>(<span class="params"> strName </span>) </span>&#123;</div><div class="line">      privateVar = strName;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicGetName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      privateFunction();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Reveal public pointers to</span></div><div class="line">  <span class="comment">// private functions and properties</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">setName</span>: publicSetName,</div><div class="line">      <span class="attr">greeting</span>: publicVar,</div><div class="line">      <span class="attr">getName</span>: publicGetName</div><div class="line">  &#125;;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">myRevealingModule.setName(<span class="string">"Paul Kinlan"</span>);</div></pre></td></tr></table></figure></p>
<p>这个模式可以用于将私有函数和属性以更加规范的命名方式展现出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateCounter++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        publicIncrement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicIncrement</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateFunction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicGetCount</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> privateCounter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Reveal public pointers to</span></div><div class="line">    <span class="comment">// private functions and properties       </span></div><div class="line"></div><div class="line">   <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">start</span>: publicFunction,</div><div class="line">        <span class="attr">increment</span>: publicIncrement,</div><div class="line">        <span class="attr">count</span>: publicGetCount</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;();</div><div class="line"></div><div class="line">myRevealingModule.start();</div></pre></td></tr></table></figure></p>
<p> <strong>优势</strong><br>这个模式是我们脚本的语法更加一致。同样在模块的最后关于那些函数和变量可以被公共访问也变得更加清晰，增强了可读性。</p>
<p> <strong>缺点</strong><br>这个模式的一个缺点是如果私有函数需要使用公有函数，那么这个公有函数在需要打补丁的时候就不能被重载。因为私有函数仍然使用的是私有的实现，并且这个迷失不能用于公有成员，只用于函数。<br>公有成员使用私有成员也遵循上面不能打补丁的规则。<br>因为上面的原因，使用暴露式模块模式创建的模块相对于原始的模块模式更容易出问题，因此在使用的时候需要小心。</p>
<h2 id="单例模块"><a href="#单例模块" class="headerlink" title="单例模块"></a>单例模块</h2><p>单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。经典的实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。</p>
<p>单例和静态类不同，因为我们可以退出单例的初始化时间。通常这样做是因为，在初始化的时候需要一些额外的信息，而这些信息在声明的时候无法得知。对于并不知晓对单例模式引用的代码来讲，单例模式没有为它们提供一种方式可以简单的获取单例模式。这是因为，单例模式既不返回对象也不返回类，它只返回一种结构。可以类比闭包中的变量不是闭包，提供闭包的函数域是闭包。</p>
<p>在JavaScript语言中，单例服务作为一个从全局空间的代码实现中隔离出来共享的资源空间是为了提供一个单独的函数访问指针。</p>
<p>我们能像这样实现一个单例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//Instance stores a reference to the Singleton</span></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//单例</span></div><div class="line">    <span class="comment">//私有方法和变量</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"I am private"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="string">"I am also private"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">// 共有方法和变量</span></div><div class="line">      publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"The public can see me!"</span> );</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      <span class="attr">publicProperty</span>: <span class="string">"I am also public"</span>,</div><div class="line"></div><div class="line">      <span class="attr">getRandomNumber</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> privateRandomNumber;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//如果存在获取此单例实例，如果不存在创建一个单例实例</span></div><div class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(!instance)&#123;</div><div class="line">        instance = init();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> myBadSingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//存储单例实例的引用</span></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//单例</span></div><div class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">getRandomNumber</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> privateRandomNumber;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//总是创建一个新的实例</span></div><div class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      instance = init();</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="keyword">var</span> singleA = mySingleton.getInstance();</div><div class="line"><span class="keyword">var</span> singleB = mySingleton.getInstance();</div><div class="line"><span class="built_in">console</span>.log( singleA.getRandomNumber() === singleB.getRandomNumber() ); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> badSingleA = myBadSingleton.getInstance();</div><div class="line"><span class="keyword">var</span> badSingleB = myBadSingleton.getInstance();</div><div class="line"><span class="built_in">console</span>.log( badSingleA.getRandomNumber() !== badSingleB.getRandomNumber() ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>创建一个全局访问的单例实例(通常通过MySingleton.getInstance())因为我们不能(至少在静态语言中)直接调用new MySingleton()创建实例。这在javascript语言中是不可能的。<br>单例模式的描述如下：</p>
<ul>
<li>每个类只有一个实例，这个实例必须通过一个广为人知的接口，来被客户访问。</li>
<li>子类如果要扩展这个唯一的实例，客户可以不用修改代码就能使用这个扩展后的实例。<br>关于第二点，可以参考如下的实例，我们需要这样编码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mySingleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>._instance == <span class="literal">null</span>)&#123;</div><div class="line">    <span class="keyword">this</span>._instance = <span class="keyword">new</span> FooSingleton();</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">this</span>._instance = <span class="keyword">new</span> BasicSingleton();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里，getInstance 有点类似于工厂方法，我们不需要去更新每个访问单例的代码。FooSingleton可以是BasicSinglton的子类，并且实现了相同的接口。<br>为什么对于单例模式来讲，延迟执行这么重要？</p>
<p><strong>在C++代码中，单例模式将不可预知的动态初始化顺序问题隔离掉，将控制权返回给程序员。</strong><br>区分类的静态实例和单例模式很重要：尽管单例模式可以被实现成一个静态实例，但是单例可以懒构造，在真正用到之前，单例模式不需要分配资源或者内存。<br>如果我们有个静态对象可以被直接初始化，我们需要保证代码总是以同样的顺序执行当你有很多源文件的时候，这种方式没有可扩展性。<br>单例模式和静态对象都很有用，但是不能滥用-同样的我们也不能滥用其他模式。<br>在实践中，当一个对象需要和另外的对象进行跨系统协作的时候，单例模式很有用。下面是一个单例模式在这种情况下使用的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SingletonTester = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// options: an object containing configuration options for the singleton</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    options = options || &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"SingletonTesterer"</span>;</div><div class="line">    <span class="keyword">this</span>.pointX = options.pointX || <span class="number">6</span>;</div><div class="line">    <span class="keyword">this</span>.pointY = options.pointX || <span class="number">10</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line">  <span class="keyword">var</span> _static = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"SingletonTesterer"</span>,</div><div class="line">    <span class="attr">getInstance</span>: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(instance === <span class="literal">undefined</span>)&#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton(options);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> _static;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> singletonTest = SingletonTesterer.getInstance(&#123;</div><div class="line">  <span class="attr">pointX</span>: <span class="number">5</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(singletonTest.pointX);</div></pre></td></tr></table></figure></p>
<p>尽管单例模式有着合理的使用需求，但是通常当我们发现自己需要在javascript使用它的时候，这是一种信号，表明我们可能需要去重新评估自己的设计。<br>这通常表明系统中的模块要么紧耦合要么逻辑过于分散在代码库的多个部分。单例模式更难测试，因为可能有多种多样的问题出现，例如隐藏的依赖关系，很难去创建多个实例，很难理清依赖关系，等等。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是这样一种设计模式。一个被称作被观察者的对象，维护一组被称为观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给它们。</p>
<p>当一个被观察者需要将一些变化通知给观察者的时候，它将采用广播的方式，这条广播可能包含特定于这条通知的一些数据。</p>
<p>当特定的观察者不再需要接受来自于它所注册的被观察者通知的时候，被观察者可以将其从所维护的组中删除。在这里提及一下设计模式现有的定义很有必要。这个定义是与所使用的语言无关的。通过这个定义，最终我们可以更深层次地了解设计模式如何使用以及其优势。在四人帮的《设计模式：可重用的面向对象软件的元素》这本书中，是这样定义观察者模式的：</p>
<p>一个或者更多的观察者对一个被观察者的状态感兴趣，将自身的这种感兴趣通过附着自身的方式注册在被观察者身上。防备观察者发生变化，而这种便可也是观察者所关心的，就会产生一个通知，这个通知将会被送出去，最后将会调用每个观察者的更新方法。当观察者不在对被观察者的状态感兴趣的时候，它们只需要简单的将自身剥离即可。</p>
<p>我们现在可以通过实现一个观察者模式来进一步扩展我们刚才所学的东西。这个实现包含以下组件：</p>
<ul>
<li>被观察者：维护一组观察者，提供用于增加和移除观察者的方法。</li>
<li>观察者：提供一个更新接口，用于当被观察者状态变化时，得到通知。</li>
<li>具体的被观察者：状态变化时广播通知给观察者，保持具体的观察者的信息。</li>
<li>具体的观察者：保持一个纸箱具体被观察者的引用，实现一个更新接口，用于观察，以便保证自身状态总是和被观察者状态一致的。</li>
</ul>
<p>首先，让我们对被观察者可能有的一组依赖其的观察者进行建模：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Add = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.push(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Get = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(index &gt; <span class="number">-1</span> &amp;&amp; index &lt; <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList[index]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Insert = <span class="function"><span class="keyword">function</span>(<span class="params">obj,index</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> pointer = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.unshift(obj);</div><div class="line">    pointer = index;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.push(obj);</div><div class="line">    pointer = index;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> pointer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.IndexOf = <span class="function"><span class="keyword">function</span>(<span class="params">obj,startIndex</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i = startIndex, pointer = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span>(i&lt; <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.observerList[i] === obj)&#123;</div><div class="line">      pointer = i;</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> pointer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ObserverList.prototype.RemoveAt = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.shift();</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="keyword">this</span>.observerList.length <span class="number">-1</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.pop();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//Extend an object with an extension</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">extension, obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> extension)&#123;</div><div class="line">    obj[key] = extension[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着，我们对被观察者以及其增加、删除，通知在观察者列表中的观察者的能力进行建模：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Subject.prototype.AddObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.Add(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Subject.prototype.RemoveObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.RemoveAt(<span class="keyword">this</span>.observers.IndexOf(observer,<span class="number">0</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Subject.prototype.Notify = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> observerCount = <span class="keyword">this</span>.observers.Count();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; observerCount; i++)&#123;</div><div class="line">    <span class="keyword">this</span>.observers.Get(i).Update(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们接着定义建立新的观察者的一个框架。这里的update函数之后会被具体的行为覆盖。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//The Observer</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们的样例应用里面，我们使用上面的观察者组件，现在我们定义：</p>
<ul>
<li>一个按钮，这个按钮用于增加新的充当观察者的选择框到页面上</li>
<li>一个控制用的额选择框，充当一个被观察者，通知其它选择框是否用该被选中</li>
<li>一个容器，用于放置新的选择框</li>
</ul>
<p>我们接着定义具体被观察者和具体观察者，用于给页面增加新的观察者，以及实现更新接口。通过查看下面的内联的注释，搞清楚在我们的样例中的这些组件是如何工作的。</p>
<p><strong>HTML</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button id="addNewObserver"&gt;Add New Observer checkbox&lt;/button&gt;</div><div class="line">&lt;input id="mainCheckbox" type="checkbox"/&gt;</div><div class="line">&lt;div id="observersContainer"&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Sample script</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们DOM 元素的引用</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> controlCheckbox = <span class="built_in">document</span>.getElementById( <span class="string">"mainCheckbox"</span> ),</div><div class="line">addBtn = <span class="built_in">document</span>.getElementById( <span class="string">"addNewObserver"</span> ),</div><div class="line">container = <span class="built_in">document</span>.getElementById( <span class="string">"observersContainer"</span> );</div><div class="line"></div><div class="line"><span class="comment">// 具体的被观察者</span></div><div class="line"></div><div class="line"><span class="comment">//Subject 类扩展controlCheckbox 类</span></div><div class="line">extend( <span class="keyword">new</span> Subject(), controlCheckbox );</div><div class="line"></div><div class="line"><span class="comment">//点击checkbox 将会触发对观察者的通知</span></div><div class="line">controlCheckbox[<span class="string">"onclick"</span>] = <span class="keyword">new</span> <span class="built_in">Function</span>( <span class="string">"controlCheckbox.Notify(controlCheckbox.checked)"</span> );</div><div class="line"></div><div class="line">addBtn[<span class="string">"onclick"</span>] = AddNewObserver;</div><div class="line"></div><div class="line"><span class="comment">// 具体的观察者</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddNewObserver</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">//建立一个新的用于增加的checkbox</span></div><div class="line">  <span class="keyword">var</span> check  = <span class="built_in">document</span>.createElement( <span class="string">"input"</span> );</div><div class="line">  check.type = <span class="string">"checkbox"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 使用Observer 类扩展checkbox</span></div><div class="line">  extend( <span class="keyword">new</span> Observer(), check );</div><div class="line"></div><div class="line">  <span class="comment">// 使用定制的Update函数重载</span></div><div class="line">  check.Update = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.checked = value;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 增加新的观察者到我们主要的被观察者的观察者列表中</span></div><div class="line">  controlCheckbox.AddObserver( check );</div><div class="line"></div><div class="line">  <span class="comment">// 将元素添加到容器的最后</span></div><div class="line">  container.appendChild( check );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子里面，我们看到了如何实现和配置观察者模式，了解了被观察者，观察者，具体被观察者，具体观察者的概念。</p>
<p><strong>观察者模式和发布/订阅模式的不同</strong><br>观察者模式确实有用，但是在javaScript世界里面，通常我们使用一种叫做发布/订阅模式的变体来实现观察者模式。这两种模式很相似，但是也有一些值得注意的不同。</p>
<p>观察者模式要求想要接收相关通知的观察者必须到发起这个事件的被观察者上注册这个事件。</p>
<p>发布/订阅模式使用一个主题/事件频道，这个频道处于想要获取通知的订阅者和发起事件的发布者之间。这个事件系统允许代码定义应用相关的事件，这个事件可以传递特殊的参数，参数中包含有订阅者所需要的值。这种想法是为了避免订阅者和发布者之间的依赖性。</p>
<p>这种和观察者模式之间的不同，使订阅者可以实现一个合适的事件处理函数，用于注册和接受由发布者广播的相关通知。</p>
<p>这里给出一个关于如何使用发布者/订阅者模式的例子，这个例子中完整地实现了功能强大的publish(), subscribe() 和 unsubscribe()。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个非常简单的邮件处理器</span></div><div class="line"><span class="comment">//接受的消息的计数器</span></div><div class="line"><span class="keyword">var</span> mailCounter = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//初始化一个订阅者，这个订阅者监听名叫"indox/newMessage"的频道</span></div><div class="line"></div><div class="line"><span class="comment">//渲染新消息的粗略信息</span></div><div class="line"><span class="keyword">var</span> subscribe1 = subscribe(<span class="string">"inbox/newMessage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic,data</span>)</span>&#123;</div><div class="line">  <span class="comment">//日志记录主题，用于调试</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"A new message was received: "</span>, topic);</div><div class="line"></div><div class="line">  <span class="comment">//使用来自于被观察者的数据，用于给用户展示一个消息的粗略信息</span></div><div class="line">  $(<span class="string">".messageSender"</span>).html(data.sender);</div><div class="line">  $(<span class="string">".messagePriview"</span>).html(data.body);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//这是另外一个订阅者，使用相同的数据执行不同的任务</span></div><div class="line"><span class="comment">//更新计数器，显示当前来自于发布者的新信息的数量</span></div><div class="line"><span class="keyword">var</span> subscribe2 = subscribe(<span class="string">"inbox/newMessage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic,data</span>)</span>&#123;</div><div class="line">  $(<span class="string">".newMessageCounter"</span>).html(mailCounter++);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">publish(<span class="string">"inbox/newMessage"</span>,[&#123;</div><div class="line">  <span class="attr">sender</span>: <span class="string">"hello@ceair.com"</span>,</div><div class="line">  <span class="attr">body</span>: <span class="string">"Hello world!"</span></div><div class="line">&#125;]);</div><div class="line"></div><div class="line"><span class="comment">//在之后，我们可以让我们的订阅者通过下面的方式取消订阅来自于新主题的通知</span></div><div class="line"><span class="comment">//unsubscribe(subscribe1);</span></div><div class="line"><span class="comment">//unsubscribe(subscribe2);</span></div></pre></td></tr></table></figure></p>
<p>这个例子的更广的意义是对松耦合的原则的一种推崇。不是一个对象直接调用另外一个对象的方法，而是通过订阅另外一个对象的一个特定的任务或者活动，从而在这个任务或者活动出现的时候得到通知。</p>
<p><strong>优势</strong><br>观察者和发布/订阅模式鼓励人们认真考虑应用不同部分之间的关系，同时帮助我们找出这样的层，该层中包含有直接的关系，这些关系可以通过一系列的观察者和被观察者来替换掉。这种方式可以有效地将一个应用程序切割成小块，这些小块耦合度低，从而改善代码的管理，以及用于潜在的代码复用。</p>
<p>使用观察者模式更深层次的动机是，当我们需要维护相关对象的一致性的时候，我们可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。</p>
<p>两种模式下，观察者和被观察者之间都可以存在动态关系。这提供很好的灵活性，而当我们的应用中不同的部分之间紧密耦合的时候，是很难实现这种灵活性的。</p>
<p>尽管这些模式并不是万能的灵丹妙药，这些模式仍然是作为最好的设计松耦合系统的工具之一，因此在任何的JavaScript开发者的工具箱里面，都应该有这样一个重要的工具。</p>
<p><strong>缺点</strong><br>事实上，这些模式的一些问题实际上正是来自于它们所带来的一些好处。在发布/订阅模式中，将发布者共订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。</p>
<p>例如，发布者可以假设有一个或者多个订阅者正在监听他们。比如我们基于这样的假设，在某些应用处理过程中来记录或者输出错误日志。如果订阅者执行日志功能崩溃了，因为系统本身的解耦本质，发布者没有办法感知到这些事情。</p>
<p>另外一个这种模式的缺点是，订阅者对彼此之间存在没有感知，对切换发布者的代价无从得知。因为订阅者和发布者之间的动态关系，更新依赖也很难去追踪。</p>
<p><strong>发布/订阅实现</strong><br>发布/订阅在JavaScript的生态系统中非常合适，主要是因为作为核心的ECMAScript实现是事件驱动的。尤其是在浏览器环境下更是如此，因为DOM使用事件作为其主要的用于脚本的交互API。</p>
<p>也就是说，无论是ECMAScript还是DOM都没有在实现代码中提供核心对象或者方法用于创建定制的事件系统。</p>
<p>幸运的是，流行的JavaScript库例如dojo, jQuery(定制事件)以及YUI已经有相关的工具，可以帮助我们方便的实现一个发布/订阅者系统。下面我们看一些例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发布</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).trigger("channel", [arg1, arg2, arg3]);</span></div><div class="line">$( el ).trigger( <span class="string">"/login"</span>, [&#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125;] );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.publish("channel", [arg1, arg2, arg3] );</span></div><div class="line">dojo.publish( <span class="string">"/login"</span>, [&#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125;] );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.publish("channel", [arg1, arg2, arg3]);</span></div><div class="line">el.publish( <span class="string">"/login"</span>, &#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125; );</div><div class="line"></div><div class="line"><span class="comment">// 订阅</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).on( "channel", [data], fn );</span></div><div class="line">$( el ).on( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>)</span>&#123;...&#125; );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.subscribe( "channel", fn);</span></div><div class="line"><span class="keyword">var</span> handle = dojo.subscribe( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;..&#125; );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.on("channel", handler);</span></div><div class="line">el.on( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;...&#125; );</div><div class="line"></div><div class="line"><span class="comment">// 取消订阅</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).off( "channel" );</span></div><div class="line">$( el ).off( <span class="string">"/login"</span> );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.unsubscribe( handle );</span></div><div class="line">dojo.unsubscribe( handle );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.detach("channel");</span></div><div class="line">el.detach( <span class="string">"/login"</span> );</div></pre></td></tr></table></figure></p>
<p>尤其对于jQuery 开发者来讲，他们拥有很多其它的选择，可以选择大量的良好实现的代码，从Peter Higgins 的jQuery插件到Ben Alman 在GitHub 上的（优化的）发布/订阅 jQuery gist。下面给出了这些代码的链接。</p>
<ul>
<li><a href="https://gist.github.com/661855" target="_blank" rel="external">Ben Alman的发布/订阅 gist(推荐)</a></li>
<li><a href="https://gist.github.com/705311" target="_blank" rel="external">Rick Waldron 在上面基础上修改的 jQuery-core 风格的实现</a></li>
<li><a href="http://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js" target="_blank" rel="external">Peter Higgins 的插件</a></li>
<li><a href="http://amplifyjs.com/" target="_blank" rel="external">AppendTo 在AmplifyJS中的 发布/订阅实现</a></li>
<li><a href="https://gist.github.com/826794" target="_blank" rel="external">Ben Truyman的 gist</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A particular fine spring came around.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构造器模式&quot;&gt;&lt;a href=&quot;#构造器模式&quot; class=&quot;headerlink&quot; title=&quot;构造器模式&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://gaoquan.wang/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript秘密花园</title>
    <link href="http://gaoquan.wang/2016/08/05/JavaScript%E7%A7%98%E5%AF%86%E8%8A%B1%E5%9B%AD/"/>
    <id>http://gaoquan.wang/2016/08/05/JavaScript秘密花园/</id>
    <published>2016-08-05T08:22:23.000Z</published>
    <updated>2017-06-04T12:54:20.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Laughing is the most touching mask.</p>
</blockquote>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象使用和属性"><a href="#对象使用和属性" class="headerlink" title="对象使用和属性"></a>对象使用和属性</h3><p>JavaScript中所有变量都可以当作对象使用，除了两个例外<code>null</code>和<code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="literal">false</span>.toString(); <span class="comment">//'false'</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString(); <span class="comment">//'1,2,3'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.bar = <span class="number">1</span>;</div><div class="line">Foo.bar; <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.</span>toString(); <span class="comment">//SyntaxError</span></div></pre></td></tr></table></figure></p>
<p>有很多变通方法可以让数字的字面值看起来像对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.</span>.toString(); <span class="comment">//第二个点号可以正常解析</span></div><div class="line"><span class="number">2</span> .toString(); <span class="comment">//注意点号前面的空格</span></div><div class="line">(<span class="number">2</span>).toString(); <span class="comment">//2先被计算</span></div></pre></td></tr></table></figure></p>
<h3 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h3><p>JavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。<br>使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从<code>Object.prototye</code>继承下来，没有任何自定义属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;; <span class="comment">//一个空对象</span></div><div class="line"><span class="comment">//一个新对象，拥有一个值为12的自定义属性'test'</span></div><div class="line"><span class="keyword">var</span> bar = &#123;<span class="attr">test</span>: <span class="number">12</span>&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>: <span class="string">'kitten'</span>&#125;;</div><div class="line">foo.name; <span class="comment">// kitten</span></div><div class="line">foo[<span class="string">'name'</span>]; <span class="comment">// kitten</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> get = <span class="string">'name'</span>;</div><div class="line">foo[get]; <span class="comment">// kitten</span></div><div class="line"></div><div class="line">foo<span class="number">.1234</span>; <span class="comment">// SyntaxError</span></div><div class="line">foo[<span class="string">'1234'</span>]; <span class="comment">// works</span></div></pre></td></tr></table></figure></p>
<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>
<ul>
<li>动态设置属性</li>
<li>属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)</li>
</ul>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>删除属性的唯一方法是使用<code>delete</code>操作符;设置属性为<code>undefined</code>或者<code>null</code>并不能真正的删除属性，而仅仅是移除了属性和值的关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">bar</span>: <span class="number">1</span>, <span class="attr">foo</span>:<span class="number">2</span>, <span class="attr">baz</span>:<span class="number">3</span>&#125;;</div><div class="line">obj.bar = <span class="literal">undefined</span>;</div><div class="line">obj.foo = <span class="literal">null</span>;</div><div class="line"><span class="keyword">delete</span> obj.baz;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</div><div class="line">  <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">    <span class="built_in">console</span>.log(i, <span class="string">''</span>+obj[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的输出的结果有<code>bar undefined</code>和<code>foo null</code>只有<code>baz</code>被真正的删除了，所以从输出结果中消失。</p>
<h3 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = &#123;</div><div class="line">  <span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span>,</div><div class="line">  <span class="attr">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出<code>SyntaxError</code>的错误。<br>这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript不包含传统的类继承模型，而是使用prototype原型模型。<br>虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>
<p>第一个不同之处在于JavaScript使用原型链的继承方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line">Foo.prototype = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置Bar的prototype属性为Foo的实例对象</span></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo();</div><div class="line">Bar.prototype.foo = <span class="string">'Hello World'</span>;</div><div class="line"></div><div class="line"><span class="comment">//修正Bar.prototype.constructor为Bar本身</span></div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Bar() <span class="comment">// 创建Bar的一个新实例</span></div><div class="line"></div><div class="line"><span class="comment">//原型链</span></div><div class="line">test [Bar的实例]</div><div class="line">  Bar.prototype [Foo的实例]</div><div class="line">    &#123;<span class="attr">foo</span>: <span class="string">'Hello World'</span>&#125;</div><div class="line">    Foo.prototype</div><div class="line">      &#123;<span class="attr">method</span>: ...&#125;;</div><div class="line">      <span class="built_in">Object</span>.prototype</div><div class="line">        &#123;<span class="attr">toString</span>: ...&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 简单的使用<code>Bar.prototype = Foo.prototype</code>将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用<code>Bar.prototype = Foo</code>，因为这不会执行<code>Foo</code>的原型，而是指向函数<code>Foo</code>。因此原型链将会回溯到<code>Function.prototype</code>而不是<code>Foo.prototype</code>，因此<code>method</code>将不会在<code>Bar</code>的原型链上。</p>
<p>上面的例子中，<code>test</code>对象从<code>Bar.prototype</code>和<code>Foo.prototype</code>继承下来;因此，它能访问<code>Foo</code>的原型方法<code>method</code>。同时，它也能够访问那个定义在原型上的<code>Foo</code>实例属性<code>value</code>。需要注意的是<code>new Bar()</code>不会创造出一个新的<code>Foo</code>实例，而是重复使用它原型上的那个实例；因此，所有的<code>Bar</code>实例都会共享相同的<code>value</code>属性。</p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。<br>到查找到达原型链的顶部-也就是<code>Object.prototype</code>-但是仍然没有找到指定的属性，就会返回<code>undefined</code>。</p>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype = <span class="number">1</span>; <span class="comment">//无效</span></div></pre></td></tr></table></figure></p>
<p>而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。<br>并且，当使用<code>for in</code>循环遍历对象属性时，原型链上的所有的属性都将被访问。</p>
<h3 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是拓展<code>Object.prototype</code>或者其他内置类型的原型对象。<br>这种技术被称之为<code>mobkey patching</code>并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如<code>Prototype</code>，但是为内置类型添加一些非标准的函数仍然不是一个好主意。<br>扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如<code>Array.forEach</code>.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。</p>
<h3 id="hasOwnProperty函数"><a href="#hasOwnProperty函数" class="headerlink" title="hasOwnProperty函数"></a>hasOwnProperty函数</h3><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自<code>Object.prototype</code>的<code>hasOwnProperty</code>方法。<br><code>hasOwnProperty</code>是JavaScript中唯一一个处理属性但是不查找原型链的函数。<br><strong>注意：</strong> 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改Object.prototype</span></div><div class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">goo</span>: <span class="literal">undefined</span>&#125;;</div><div class="line"></div><div class="line">foo.bar; <span class="comment">//1</span></div><div class="line"><span class="string">'bar'</span> <span class="keyword">in</span> foo; <span class="comment">//true</span></div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">//false</span></div><div class="line">foo.hasOwnProperty(<span class="string">'goo'</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>只有<code>hasOwnProperty</code>可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>
<p><strong>hasOwnProperty</strong> 作为属性<br><code>Javascript</code>不会保护<code>hasOwnProperty</code>被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的<code>hasOwnProperty</code>函数来获取正确的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">hasOwnProperty</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">bar</span>: <span class="string">'Here be dragons'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>) <span class="comment">// 总是返回false</span></div><div class="line"></div><div class="line"><span class="comment">//使用其他对象的hasOwnProperty，并将其上下文设置为foo</span></div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo,<span class="string">'bar'</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code>是唯一可用的方法。同时在使用<code>for in</code>loop遍历对象时，推荐总是使用<code>hasOwnProperty</code>方法，这将会避免原型对象扩展带来的干扰。</p>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h3><p>和<code>in</code>操作符一样，<code>for in</code>循环同样在查找对象属性时遍历原型链上的所有的属性。<br><strong>注意：</strong> <code>for in</code>循环不会遍历那些<code>enumerable</code>设置为<code>false</code>的属性；比如数组的<code>length</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改Object.prototype</span></div><div class="line">Obkect.prototype.bar = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">moo</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出两个属性： bar和moo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于不可能改变<code>for in</code>自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过<code>Object.prototype</code>原型上的额<code>hasOwnProperty</code>函数来完成。</p>
<h3 id="使用hasOwnProperty过滤"><a href="#使用hasOwnProperty过滤" class="headerlink" title="使用hasOwnProperty过滤"></a>使用hasOwnProperty过滤</h3><p><strong>注意：</strong> 由于<code>for in</code>总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//foo 变量是上例中的</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo)&#123;</div><div class="line">  <span class="keyword">if</span>(foo.hasOwnProperty(i))&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个版本的代码是唯一正确的写法。由于我们使用<code>hasOwnProperty</code>，所以这次只输出<code>moo</code>。如果不使用<code>hasOwnProperty</code>，则这段代码在原生对象原型(比如<code>Object.prototype</code>)被扩展时可能会出错。<br>推荐总是使用<code>hasOwnProperty</code>。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明与表达式"><a href="#函数声明与表达式" class="headerlink" title="函数声明与表达式"></a>函数声明与表达式</h3><p>函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p>
<p><strong>函数声明</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">//正常运行，因为foo在代码前已经被创建</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>函数赋值表达式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子把一个匿名函数赋值给变量<code>foo</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; <span class="comment">//'undefined'</span></div><div class="line">foo(); <span class="comment">//Error: TypeError</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>var</code>定义了一个声明语句，对变量<code>foo</code>的解析是在代码运行之前，因此<code>foo</code>变量在代码运行时已经被定义过了。<br>但是由于赋值语句只在运行时执行，因此在相应代码执行之前，<code>foo</code>的值缺省为<code>undefined</code>。</p>
<p><strong>命名函数的赋值表达式</strong><br>另一个特殊的情况是将命名函数赋值给一个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  bar(); <span class="comment">//正常运行</span></div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">//Error: ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>bar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。<br><strong>注意：</strong> 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数<code>foo</code>和<code>bar</code></p>
<h3 id="this的工作原理"><a href="#this的工作原理" class="headerlink" title="this的工作原理"></a>this的工作原理</h3><p>JavaScript有一套完全不同于其他语言的对<code>this</code>的处理机制。在五种不同的情况下，this指向的各不相同。</p>
<p><strong>全局范围内</strong></p>
<blockquote>
<p>this  </p>
</blockquote>
<p>当在全局范围内使用this，它将会指向全局对象。</p>
<p><strong>函数调用</strong></p>
<blockquote>
<p>foo();</p>
</blockquote>
<p>这里的this也会指向全局对象。</p>
<p><strong>方法调用</strong></p>
<blockquote>
<p>test.foo();</p>
</blockquote>
<p>这个例子中，this指向test对象。<em>ES5注意：</em> 在严格模式下，不存在全局变量，这种情况下this将会是undefined。</p>
<p><strong>调用构造函数</strong></p>
<blockquote>
<p>new foo();</p>
</blockquote>
<p>如果函数倾向于和<code>new</code>关键词一块使用，则我们称这个函数是 <em>构造函数</em> 。在函数内部，<code>this</code>指向新创建的对象。</p>
<p><strong>显示的设置this</strong></p>
<blockquote>
<p>function foo(a,b,c){}<br>  var bar = {};<br>  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示<br>  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3</p>
</blockquote>
<p>当使用<code>Function.prototype</code>上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。<br>因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。</p>
<p><strong>常见误解</strong><br>尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// this将会被设置为全局对象(浏览器环境中也就是window对象)</span></div><div class="line">  &#125;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 在对象的字面声明语法中，this不能用来指向对象本身。因此<code>var obj = {me: this}</code>中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。</p>
<p>一个常见的误解是<code>test</code>中的<code>this</code>将会指向<code>Foo</code>对象，实际上不是这样子的。<br>为了在<code>test</code>中获取对<code>Foo</code>对象的引用，我们需要在<code>method</code>函数内部创建一个局部变量指向<code>Foo</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//使用that来指向Foo对象</span></div><div class="line">  &#125;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>that只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。</p>
<h3 id="方法的赋值表达式"><a href="#方法的赋值表达式" class="headerlink" title="方法的赋值表达式"></a>方法的赋值表达式</h3><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = someObject.methodTest;</div><div class="line">test();</div></pre></td></tr></table></figure></p>
<p>上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到<code>someObject</code>对象。<br>虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Bar.prototype = Foo.prototype;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar().method();</div></pre></td></tr></table></figure></p>
<p>让method被调用时，this将会指向Bar的实例对象。</p>
<h3 id="闭包和引用"><a href="#闭包和引用" class="headerlink" title="闭包和引用"></a>闭包和引用</h3><p>闭包是JavaScript一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。因为 <strong>函数</strong> 是JavaScript中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。<br><strong>模拟私有变量</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">start</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> count = start;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      count++;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = Counter(<span class="number">4</span>);</div><div class="line">foo.increment();</div><div class="line">foo.get(); <span class="comment">//5</span></div></pre></td></tr></table></figure></p>
<p>这里,<code>COunter</code>函数返回两个闭包，函数<code>increment</code>和函数<code>get</code>。这两个函数都维持着对外部作用域<code>Counter</code>的引用，因此总可以访问此作用域内定义的变量<code>count</code>。</p>
<p><strong>为什么不可以在外部访问私有变量</strong><br>因为JavaScript中不可以对作用域进行引用或赋值，因此没有办法在外部访问count变量。唯一的途径就是通过那两个闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Counter(<span class="number">4</span>);</div><div class="line">foo.hack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  count = <span class="number">1337</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码不会改变定义在Counter作用域中的count变量的值，因为foo.hack没有定义在那个作用域内。它将会创建或者覆盖全局变量count。</p>
<p><strong>循环中的闭包</strong><br>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>-;i++)&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i)</div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码不会输出数字0到9，而是会输出数字10十次。<br>当console.log被调用的时候，匿名函数保持对外部变量i的引用，此时for循环已经结束，i的值被修改成了10.<br>为了得到想要的结果，需要在每次循环中创建变量i的拷贝。</p>
<p><strong>避免引用错误</strong><br>为了正确的获得循环序号，最好使用 <em>匿名包装器</em> (就是我们通常说的自执行匿名函数)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">  &#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>外部匿名函数会立即执行，并把i作为它的参数，此时函数内e变量就拥有了i的一个拷贝。<br>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p>
<p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">  setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;</div><div class="line">  &#125;)(i),<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>Javascript中每个函数内都能访问一个特别变量<code>arguments</code>。这个变量维持着所有传递到这个函数中的参数列表。<br>arguments变量不是一个数组(Array)。尽管在语法上它有数组相关的属性length，但它不从Array.prototype继承，实际上它是一个对象(Object)。<br><strong>注意：</strong> 由于<code>arguments</code>已经被定义为函数内的一个变量。因此通过<code>var</code>关键字定义<code>arguments</code>或者将<code>arguments</code>声明为一个形式参数，都将导致原生的<code>arguments</code>不会被创建。</p>
<p>因此，无法对<code>arguments</code>变量使用标准的数组方法，比如push、pop或者slice。虽然使用for循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>
<p><strong>转化为数组</strong><br>下面的代码将会创建一个新的数组，包含所有arguments对象中的元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>这个转化比较慢，在性能不好的代码中不推荐这种做法。</p>
<p><strong>传递参数</strong><br>下面是将参数从一个函数传递到另一个函数的推荐做法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  bar.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个技巧是同时使用call和apply，创建一个快速的解绑定包装器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,a,b,c);</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个解绑定的'method'</span></div><div class="line"><span class="comment">//输入参数为:this, arg1, arg2, ...argN</span></div><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//结果： Foo.prototype.method.call(this,arg1,arg2...argN)</span></div><div class="line">  <span class="built_in">Function</span>.call.apply(Foo.prototype.method,<span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的Foo.method函数和下面代码的效果是一样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  Foo.prototype.method.apply(args[<span class="number">0</span>],args.slice(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>自动更新</strong><br><code>arguments</code>对象为其内部属性以及函数形式参数创建getter和setter方法。<br>因此，改变形参的值会影响到<code>arguments</code>对象的值，反之亦然。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">  a; <span class="comment">//2</span></div><div class="line"></div><div class="line">  b = <span class="number">4</span>;</div><div class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>]; <span class="comment">//4</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> d = c;</div><div class="line">  d = <span class="number">9</span>;</div><div class="line">  c; <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)；</div></pre></td></tr></table></figure></p>
<p><strong>性能真相</strong><br>不管它是否有被使用，arguments对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。<br>arguments的getters和setters方法总会被创建；因此使用arguments对性能不会有什么影响。除非是需要对<code>arguments</code>对象的属性进行多次访问。</p>
<p>在严格模式下，arguments的描述有助于我们的理解，请看下面的代码：<br><strong>注意：</strong> ES5提示，这些getters和setters在严格模式下不会被创建。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阐述在ES5的严格模式下`arguments`的特性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span></div><div class="line">  a= <span class="number">42</span>;</div><div class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> pair = f(<span class="number">17</span>);</div><div class="line"><span class="built_in">console</span>.assert(pair[<span class="number">0</span>] === <span class="number">42</span>);</div><div class="line"><span class="built_in">console</span>.assert(pair[<span class="number">1</span>] === <span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>然而，的确有一种情况会显著的影响现在JavaScript引擎的性能。这就是使用arguments.callee。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">arguments</span>.callee; <span class="comment">//do something with this function object</span></div><div class="line">  <span class="built_in">arguments</span>.callee.caller; <span class="comment">//and the calling function object</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigLoop</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</div><div class="line">    foo();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，foo不再是一个单纯的内联函数inlining(指的是解析器可以做内联处理)，因为它需要知道它自己和它的调用者。这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>
<p>因此强烈建议不要使用<code>arguments.callee</code>和它的属性。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JavaScript中的构造函数和其它语言中的构造函数是不同的。通过new关键字方式调用的函数都被认为是构造函数。</p>
<p>在构造函数内部 - 也就是被调用的函数内 - this指向新创建的对象Object。这个新创建的对象的prototye被指向到构造函数的prototye。</p>
<p>如果被调用的函数没有显式的return表达式，则隐式的会返回this对象 - 也就是新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.bar = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.bla);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p>上面代码把Foo作为构造函数调用，并设置新创建对象的prototype为Foo.prototype.</p>
<p>显式的return表达式将会影响返回结果，但仅限于返回的是一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Bar(); <span class="comment">//返回新创建的对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Test(); <span class="comment">//返回的对象</span></div></pre></td></tr></table></figure></p>
<p>new Bar()返回的是新创建的对象，而不是数字的字面值2.因此<code>new Bar().constructor === Bar</code>，但是如果返回的是数字对象，结果就不同了，如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span></div></pre></td></tr></table></figure></p>
<p>这里得到的<code>new Test()</code>是函数返回的对象，而不是通过new关键字新创建的对象，因此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> Test()).value === <span class="literal">undefined</span></div><div class="line">(<span class="keyword">new</span> Test()).foo === <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>如果<code>new</code>被遗漏了，则函数不会返回新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.bla = <span class="number">1</span>; <span class="comment">//获取设置全局参数</span></div><div class="line">&#125;</div><div class="line">Foo(); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>虽然上例在有些情况下也能正常运行，但是由于JavaScript中this的工作原理，这里的this指向全局对象。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>为了不使用new关键字，构造函数必须显示的返回一个值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> value = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Bar.prototype = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar();</div><div class="line">Bar();</div></pre></td></tr></table></figure></p>
<p>上面两种对Bar函数的调用返回的值 完全相同，一个新创建的拥有method属性的对象被返回，其实这里创建了一个闭包。<br>还需要注意，<code>new Bar()</code>并不会改变返回对象的原型(也就是返回对象的原型不会指向Bar.prototype)。因为构造函数的原型会被指向到刚刚创建的新对象，而这里的Bar没有把这个新对象返回，而是返回了一个包含method属性的自定义对象。<br>上面两种方式创建的对象不能访问Bar原型链上的属性，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar1 = <span class="keyword">new</span> Bar()</div><div class="line"><span class="keyword">typeof</span>(bar1.method); <span class="comment">//'function'</span></div><div class="line"><span class="keyword">typeof</span>(bar1.foo); <span class="comment">//'undefined'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar2 = Bar();</div><div class="line"><span class="keyword">typeof</span>(bar2.method); <span class="comment">//'function'</span></div><div class="line"><span class="keyword">typeof</span>(bar2.foo); <span class="comment">//'undefined'</span></div></pre></td></tr></table></figure></p>
<h3 id="通过工厂模式创建新对象"><a href="#通过工厂模式创建新对象" class="headerlink" title="通过工厂模式创建新对象"></a>通过工厂模式创建新对象</h3><p>我们常听到的一条忠告是不要使用new关键字来调用函数，因为如果忘记使用它就会导致错误。<br>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;</div><div class="line">  obj.value = <span class="string">'blub'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> private = <span class="number">2</span>;</div><div class="line">  obj.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> private;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然上面的方式比起new的调用不容易出错，并且可以充分利用私有变量带来的便利，但是随之而来的是一些不好的地方。</p>
<ol>
<li>会占用更多的内容，因为新创建的对象不能共享原型上的方法。</li>
<li>为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li>放弃原型链仅仅是因为防止遗漏new带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<p>虽然遗漏new关键字可能会导致问题，但这并不是放弃使用原型链的借口。最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并坚持下去才是最重要的。</p>
<h3 id="作用域与命名空间"><a href="#作用域与命名空间" class="headerlink" title="作用域与命名空间"></a>作用域与命名空间</h3><p>尽管JavaScript支持一对花括号创建的代码段，但是并不支持块级作用域；而仅仅支持函数作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123; <span class="comment">//一个作用域</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; <span class="comment">//不是一个作用域</span></div><div class="line">    <span class="comment">//count</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 如果return对象左括号和return不在一行上就会出错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span></div><div class="line">    a + b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</div><div class="line"><span class="comment">//输出undefined</span></div></pre></td></tr></table></figure></p>
<p>如果不是在赋值语句中，而是在return表达式或者函数参数中，{…}将会作为代码段解析，而不是作为对象的字面语法解析。如果考虑到自动分号插入，这可能会导致一些不易察觉的错误。<br>JavaScript中没有显示的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。<br>每次引用一个变量，JavaScript会向上遍历整个作用域知道找到这个变量为止。如果到达全局作用域但是这个变量仍未找到，则会抛出<code>ReferenceError</code>异常。</p>
<p><strong>名称解析顺序</strong><br>JavaScript中的所有作用域，包括全局作用域，都有一个特别的名称this指向当前对象。<br>函数作用域内也有默认的变量arguments，其中包含了传递到函数中的参数。<br>比如，当访问函数内的foo变量时，JavaScript会按照下面顺序查找：</p>
<ol>
<li>当前作用域内是否有<code>var foo</code>的定义。</li>
<li>函数形式参数是否有使用foo名称的。</li>
<li>函数自身是否叫做foo。</li>
<li>回溯到上一级作用域，然后从#1重新开始。</li>
</ol>
<p><strong>命名空间</strong><br>只有一个全局作用域导致的常见错误是命名冲突。在JavaScript中，这可以通过匿名包装器轻松解决。 <em>注意：</em> 自定义arguments参数会阻止原生的arguments对象的创建。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//函数创建一个命名空间</span></div><div class="line"></div><div class="line">  <span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//对外公开的函数，创建了闭包</span></div><div class="line">  &#125;</div><div class="line">&#125;)(); <span class="comment">//立即执行此匿名函数</span></div></pre></td></tr></table></figure></p>
<p>匿名函数被认为是表达式；因此为了可调用新，它们首先会被执行。</p>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//另外两种方式</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</div></pre></td></tr></table></figure></p>
<p>推荐使用匿名包装器，也就是自执行的匿名函数，来创建命名空间。这样不仅可以防止命名冲突，而且有利于程序的模块化。<br>另外，使用全局变量被认为是不好的习惯。这样的代码容易出错并且维护成本较高。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组遍历与属性"><a href="#数组遍历与属性" class="headerlink" title="数组遍历与属性"></a>数组遍历与属性</h3><p>虽然在JavaScript中数组是对象，但是没有好的理由去使用<code>for in循环</code>遍历数组。相反，有一些好的理由不去使用for in遍历数组。<br>由于for in循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用hasOwnProperty函数，因此会比普通的for循环慢上好多倍。</p>
<p><strong>遍历</strong><br>为了达到遍历数组的最佳性能，推荐使用经典的for循环。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,..<span class="number">.1000</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,l=list.length;i&lt;l;i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(list[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码有一个处理，就是通过<code>l = list.length</code>来缓存数组的长度。<br>虽然length是数组的一个属性，但是在每次循环中访问它还是有性能开销。可能最新的JavaScript引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。<br>实际上，不使用缓存数组长度的方式比缓存版本要慢很多。</p>
<p><strong>length属性</strong><br>length属性的getter方式会简单的返回数组的长度，而setter方式会截断数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">foo.length = <span class="number">3</span>;</div><div class="line">foo; <span class="comment">//[1,2,3]</span></div><div class="line"></div><div class="line">foo.length = <span class="number">6</span>;</div><div class="line">foo; <span class="comment">//[1,2,3]</span></div></pre></td></tr></table></figure></p>
<p>在Firebug中查看此时foo的值是：[1,2,3,undefined,undefined,undefined]但是这个结果并不准确，如果你在Chrome的控制台查看foo的结果，你会发现是这样的，[1,2,3]因为在javaScript中undefined是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。<br>为length设置一个更小的值会截断数组，但是增大length属性值不会对数组产生影响。</p>
<p>为了更好的性能，推荐使用普通的for循环并缓存数组的length属性。使用for in遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
<h3 id="Array构造函数"><a href="#Array构造函数" class="headerlink" title="Array构造函数"></a>Array构造函数</h3><p>由于Array的构造函数在如何处理参数时有点模棱两口，因此总是推荐使用数组的字面语法 - [] - 来创建数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//[1,2,3]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//[1,2,3]</span></div><div class="line"></div><div class="line">[<span class="number">3</span>]; <span class="comment">//[3]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'3'</span>); <span class="comment">//['3']</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//[3,4,5]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[],此数组长度为3</span></div></pre></td></tr></table></figure></p>
<p>由于只有一个参数传递到构造函数中，并且这个参数时数组，构造函数会返回一个length属性被设置为此参数的空数组。需要特别注意的是，此时只有length属性被设置，真正的数组并没有生成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</div><div class="line">arr[<span class="number">1</span>]; <span class="comment">//undefined</span></div><div class="line"><span class="number">1</span> <span class="keyword">in</span> arr; <span class="comment">//false,数组还没有生成</span></div></pre></td></tr></table></figure></p>
<p>这种优先于设置数组长度属性的做法只在少数几种情况下有用，<strong>比如需要循环字符串，可以避免for循环的麻烦。</strong><br><code>new Array(count + 1).join(stringToRepeat);</code><br>new Array(3).join(‘#’) 将会返回##</p>
<p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>typeof操作符(和 instanceof一起)或许是JavaScript中最大的设计缺陷，因为几乎不可能从它们那里得到想要的结果。<br>尽管instanceof还有一些极少数的应用场景，typeof只有一个实际的应用，就是用来检测一个对象是否已经定义或者是否已经赋值，而不是用来检查对象的类型。</p>
<p><strong>JavaScript类型表格</strong><br>| Value | Class | Type |<br>| —— | :——-: | :———– |<br>| “foo” | String | string |<br>| new String(‘foo’) | String | object |<br>| 1.2 | Number | number |<br>| new Number(1.2) | Number | number |<br>| true | Boolean | boolean |<br>| new Boolean(true) | Boolean | object |<br>| new Date() | Date | object |<br>| new Error() | Error | object |<br>| [1,2,3] | Array | object |<br>| new Array(1,2,3) | Array | object |<br>| new Function(“”) | Function | function |<br>| /abc/g | RegExp | object |<br>| new RegExp(“co”) | RegExp | object |<br>| {} | Object | object |<br>| new Object() | Object | object |<br>上面表格中，Type一列表示typeof操作符的运算结果。可以看到，这个值在大多数情况下都返回”object”。<br>Class一列表示对象的内部属性[[Class]]的值。<br>为了获取对象的[[Class]]，我们需要使用定义在Object.prototype上的方法toString。<br>Javascript标准文档中定义：[[Class]]的值只可能是下面字符串中的一个：Arguments、Array、Boolean、Date、Error、Function、JSON、Math、Number、Object、RegExp、String.</p>
<p><strong>对象的类定义</strong><br>JavaScript标准文档只给出了一种获取[[Class]]值的方法，那就是使用Object.prototype.toString<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type,obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="class"><span class="keyword">class</span> </span>= <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !==<span class="literal">null</span> &amp;&amp; <span class="class"><span class="keyword">class</span> </span>=== type;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">//true</span></div><div class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>上面例子中，Object.prototype.toString方法被调用，this被设置为需要获取[[Class]]值的对象。<br>Object.prototype.toString 返回一种标准格式字符串，所以上例可以通过slice截取指定位置的字符串，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">// "[object Object]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>); <span class="comment">// "[object Number]"</span></div></pre></td></tr></table></figure></p>
<p><strong>ES5提示：</strong> 在ECMAScript5中，为了方便，对null和undefined调用Object.prototype.toString方法，其返回值由Object变成了Null和Undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IE8</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//"[object Object]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line"><span class="comment">//Firefox 4</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//"[object Null]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">//"[object Undefined]"</span></div></pre></td></tr></table></figure></p>
<p><strong>测试为定义变量</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> foo !== <span class="string">'undefined'</span></div></pre></td></tr></table></figure></p>
<p>上面代码会检测foo是否已经定义；如果没有定义而直接使用会导致ReferenceError的异常。这是typeof唯一有用的地方。</p>
<p>为了检测一个对象的类型，强烈推荐使用Object.prototype.toString方法；因为这是唯一一个可依赖的方式。正如上面表格所示，typeof的一些返回值在标准文档中并未定义，因此不同的引擎实现可能不同。<br>除非为了检测一个变量是否已经定义，我们应尽量避免使用typeof操作符。</p>
<h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>instanceof操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。如果用来比较内置类型，将会和typeof操作符一样用处不大。</p>
<p><strong>比较自定义对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">//true</span></div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//如果仅仅设置Bar.prototype为函数Foo本身，而不是Foo构造函数的一个实例</span></div><div class="line">Bar.prototype = Foo;</div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>instanceof 比较内置类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></div><div class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>有一点需要注意，instanceof用来比较属于不同javaScript上下文的对象时将会出错，因为他们的构造函数不会是同一个对象。</p>
<p>instanceof操作符应该仅仅用来比较来自同一个JavaScript上下文的自定义对象。正如typeof操作符一样，任何其它的用法都应该是避免的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JavaScript是弱类型语言，所以会在任何可能的情况下应用强制类型转换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的比较结果是：true</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) == <span class="number">10</span>; <span class="comment">// Number.toString() 返回的字符串被再次转换为数字</span></div><div class="line"></div><div class="line"><span class="number">10</span> == <span class="string">'10'</span>;           <span class="comment">// 字符串被转换为数字</span></div><div class="line"><span class="number">10</span> == <span class="string">'+10 '</span>;         <span class="comment">// 同上</span></div><div class="line"><span class="number">10</span> == <span class="string">'010'</span>;          <span class="comment">// 同上</span></div><div class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>) == <span class="literal">false</span>; <span class="comment">// null 被转换为数字 0</span></div><div class="line">                    <span class="comment">// 0 当然不是一个 NaN（译者注：否定之否定）</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的比较结果是：false</span></div><div class="line"><span class="number">10</span> == <span class="number">010</span>;</div><div class="line"><span class="number">10</span> == <span class="string">'-10'</span>;</div></pre></td></tr></table></figure></p>
<p><strong>ES5提示：</strong> 以 0 开头的数字字面值会被作为八进制数字解析。而在ECMAScript 5严格模式下，这个特性被移除了。<br>为了避免上面复杂的强制类型转换，强烈推荐使用严格的等于操作符。 虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。</p>
<p><strong>内置类型的构造函数</strong><br>内置类型（比如 Number 和 String）的构造函数在被调用时，使用或者不使用 new 的结果完全不同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;     <span class="comment">// False, 对象与数字的比较</span></div><div class="line"><span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;         <span class="comment">// True, 数字与数字的比较</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) + <span class="number">0</span> === <span class="number">10</span>; <span class="comment">// True, 由于隐式的类型转换</span></div></pre></td></tr></table></figure></p>
<p>使用内置类型 Number 作为构造函数将会创建一个新的 Number 对象， 而在不使用 new 关键字的 Number 函数更像是一个数字转换器。</p>
<p>另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。</p>
<p>最好的选择是把要比较的值显式的转换为三种可能的类型之一。</p>
<p><strong>转换为字符串</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">''</span> + <span class="number">10</span> === <span class="string">'10'</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>将一个值加上空字符串可以轻松转换为字符串类型</p>
<p><strong>转换为数字</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+<span class="string">'10'</span> === <span class="number">10</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>使用一元的加号操作符，可以把字符串转换为数字。</p>
<p>字符串转换为数字的常用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+<span class="string">'010'</span> === <span class="number">10</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">'010'</span>) === <span class="number">10</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'010'</span>, <span class="number">10</span>) === <span class="number">10</span>  <span class="comment">// 用来转换为整数</span></div><div class="line"></div><div class="line">+<span class="string">'010.2'</span> === <span class="number">10.2</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">'010.2'</span>) === <span class="number">10.2</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'010.2'</span>, <span class="number">10</span>) === <span class="number">10</span></div></pre></td></tr></table></figure></p>
<p><strong>转换为布尔值</strong><br>通过使用两次否操作符，可以把一个值转换为布尔型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></div><div class="line">!!<span class="string">''</span>;      <span class="comment">// false</span></div><div class="line">!!<span class="string">'0'</span>;     <span class="comment">// true</span></div><div class="line">!!<span class="string">'1'</span>;     <span class="comment">// true</span></div><div class="line">!!<span class="string">'-1'</span>     <span class="comment">// true</span></div><div class="line">!!&#123;&#125;;      <span class="comment">// true</span></div><div class="line">!!<span class="literal">true</span>;    <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h3 id="为什么不要使用eval"><a href="#为什么不要使用eval" class="headerlink" title="为什么不要使用eval"></a>为什么不要使用eval</h3><p>eval函数会在当前作用域中执行一段JavaScript代码字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">eval</span>(<span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">//3</span></div><div class="line">foo; <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 但是eval只在被直接调用并且调用函数就是eval本身时，才在当前作用域中执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="keyword">var</span> bar = <span class="built_in">eval</span>;</div><div class="line">  bar(<span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">//2</span></div><div class="line">foo; <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等价于在全局作用域中调用eval，和下面两种写法效果一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：直接调用全局作用域下的 foo 变量</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">window</span>.foo = <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">// 2</span></div><div class="line">foo; <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">eval</span>.call(<span class="built_in">window</span>, <span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">// 2</span></div><div class="line">foo; <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>在任何情况下我们都应该避免使用 eval 函数。99.9% 使用 eval 的场景都有不使用 eval 的解决方案。</p>
<p><strong>伪装的eval</strong><br>定时函数setTimeout和setInterval都可以接受字符串作为它们的第一个参数。这个字符串总是在全局作用域中执行，因此eval在这种情况下没有被直接调用。</p>
<p><strong>安全问题</strong><br>eval也存在安全问题，因为它会执行任意传给它的代码，在代码字符串未知或者是来自一个不信任的源时，绝对不要使用eval函数。</p>
<p>绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案， 一个更好的不使用 eval 的解决方案应该得到充分考虑并优先采用。</p>
<h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><p>JavaScript有两个表示‘空’的值，其中比较有用的是undefined.</p>
<p><strong>undefined的值</strong><br>undefined是一个值为undefined的类型。<br>这个语言也定义了一个全局变量，它的值是undefined，这个变量也被称为undefined。但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。</p>
<p>下面的情况会返回undefined值：</p>
<ul>
<li>访问未修改的全局变量undefined。</li>
<li>由于没有定义return表达式的函数隐式返回。</li>
<li>return表达式没有显式的返回任何内容。</li>
<li>访问不存在的属性。</li>
<li>函数参数没有被显式的传递值。</li>
<li>任何被设置为undefined值得变量。</li>
</ul>
<p>处理undefined值得改变<br>由于全局变量undefined只是保存了undefined类型实际值的副本，因此对它赋新值不会改变类型undefined的值。</p>
<p>然而，为了方便其它变量和undefined做比较，我们需要事先获取类型undefined的值。</p>
<p>为了避免可能对undefined值得改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。在调用时，这个参数不会获取任何值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">123</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">sth,foo,undefined</span>)</span>&#123;</div><div class="line">  <span class="comment">//局部作用域里的undefined变量重新获得了'undefined'值</span></div><div class="line">&#125;)(<span class="string">'Hello World'</span>,<span class="number">42</span>)</div></pre></td></tr></table></figure></p>
<p>另外一种达到相同目的方法是在函数内使用变量声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">undefined</span> =  <span class="number">123</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">sth,foo</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="literal">undefined</span>;</div><div class="line">&#125;)(<span class="string">'Hello World'</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p>这里唯一的区别是，在压缩后并且函数内没有其他需要使用var声明变量的情况下，这个版本的代码会多出4个字节的代码。</p>
<p><strong>null的用处</strong><br>JavaScript中的undefined的使用场景类似于其他语言中的null，实际上JavaScript中的null是另一种数据类型。</p>
<p>它在JavaScript内部有一些使用场景(比如声明原型链的终结<code>Foo.prototype = null</code>)，但是大多数情况下都可以使用undefined来代替。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="setTimeout和setInterval"><a href="#setTimeout和setInterval" class="headerlink" title="setTimeout和setInterval"></a>setTimeout和setInterval</h3><p>由于JavaScript是异步的，可以使用setTimeout和setInterval来计划执行函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> id = setTimeout(foo,<span class="number">1000</span>); <span class="comment">//返回一个大于零的数字</span></div></pre></td></tr></table></figure></p>
<p>当setTimeout被调用时，它会返回一个ID标识并且计划在将来大约1000毫秒后调用foo函数。foo函数只会被调用一次。</p>
<p>基于JavaScript引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞 此线程。因此没法确保函数会在setTimeout指定的时刻被调用。</p>
<p>作为第一个参数的函数将会在全局作用域中执行，因此函数内的this将会指向这个全局对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">42</span>;</div><div class="line">  <span class="keyword">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//this指向全局对象</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">//输出undefined</span></div><div class="line">  &#125;;</div><div class="line">  setTimeout(<span class="keyword">this</span>.method, <span class="number">500</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p><strong>setInterval的堆调用</strong><br>setTimeout只会执行回调函数一次，不过setInterval会每隔x毫秒执行函数一次。但是却不鼓励使用这个函数。</p>
<p>当回调函数的执行被阻塞时，setInterval仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//阻塞执行1s</span></div><div class="line">&#125;</div><div class="line">setInterval(foo,<span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码中,foo会执行一次随后被阻塞了一秒钟。</p>
<p>在foo被阻塞的时候，setInterval仍然在组织将来对回调函数的调用。因此，当第一次foo函数调用结束时，已经有10次函数在等待执行。</p>
<p><strong>处理可能的阻塞调用</strong><br>最简单也是最容易控制的方案，是在回调函数内部使用setTimeout函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//阻塞执行1s</span></div><div class="line">  setTimeout(foo,<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>这样不仅封装了setTimeout回调函数，而且阻止了调用指令的堆积，可以有更多的控制。foo函数现在可以控制是否继续执行还是终止执行。</p>
<p><strong>手工清空定时器</strong><br>可以通过将定时时产生的 ID 标识传递给 clearTimeout 或者 clearInterval 函数来清除定时， 至于使用哪个函数取决于调用的时候使用的是 setTimeout 还是 setInterval。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> id = setTimeout(foo, <span class="number">1000</span>);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure></p>
<p><strong>清除所有定时器</strong><br>由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清空"所有"的定时器</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">    clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能还有些定时器不会在上面代码中被清除（译者注：如果定时器调用时返回的 ID 值大于 1000）， 因此我们可以事先保存所有的定时器 ID，然后一把清除。</p>
<p>绝对不要使用字符串作为setTimeout或者setInterval的第一个参数，这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。</p>
<p>另外，应该避免使用setInterval，因为它的定时执行不会被JavaScript阻塞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Laughing is the most touching mask.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h2&gt;&lt;h3
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>初始Promise</title>
    <link href="http://gaoquan.wang/2016/07/28/%E5%88%9D%E5%A7%8BPromise/"/>
    <id>http://gaoquan.wang/2016/07/28/初始Promise/</id>
    <published>2016-07-28T03:21:39.000Z</published>
    <updated>2017-06-04T12:54:20.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Don’t let yesterday take up too much of today.</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Promise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
<p><strong>语法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123; ... &#125;);</div></pre></td></tr></table></figure></p>
<p><strong>参数</strong><br>executor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Promise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。</p>
<p>Promise对象有以下几种状态：</p>
<ul>
<li>pedding: 初始状态，既不是fulfilled也不是rejected.</li>
<li>fulfilled: 成功的操作</li>
<li>rejected: 失败的操作</li>
</ul>
<p>pending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。</p>
<p>因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用–一种被称为composition的操作。</p>
<p><img src="/images/promise/promises.png" alt="Promise"></p>
<p><code>注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。</code></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Promise.length<br>长度属性，其值为1(构造器参数的数目)<br>Promise.prototype<br>表示Promise构造器的原型</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Promise.all(iterable)<br>返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。<br>Promise.race(iterable)<br>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。<br>Promise.reject(reason)<br>调用Promise的rejected句柄，并返回这个Promise对象<br>Promise.resolve(value)<br>用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。</p>
<h2 id="Promise原型"><a href="#Promise原型" class="headerlink" title="Promise原型"></a>Promise原型</h2><p><strong>原型</strong><br>Promise.prototype.constructor<br>返回创建了实例原型的函数。默认为Promise函数。</p>
<p><strong>方法</strong><br>Promise.prototype.catch(onRejected)<br>添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。</p>
<p>Promise.prototype.then(onFulfilled.onRejected)<br>添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>创建Promise</strong><br>这个小例子展示了Promise的机制。每当<code>&lt;button&gt;</code>被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。<br>这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"log"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  <span class="string">'use strict'</span></div><div class="line">  <span class="keyword">var</span> promiseCount = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> thisPromiseCount = ++promiseCount;</div><div class="line">    <span class="keyword">var</span> log = <span class="built_in">document</span>.getElementById(<span class="string">'log'</span>);</div><div class="line">    log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') 开始(同步代码开始)&lt;br/&gt;'</span>);</div><div class="line"></div><div class="line">    <span class="comment">//我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">      <span class="comment">//完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行</span></div><div class="line">      log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') Promise开始(异步代码开始)&lt;br/&gt;'</span>);</div><div class="line"></div><div class="line">      <span class="comment">//这只是个创建异步完成的示例</span></div><div class="line">      <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//我们满足(fullfil)了这个promise！</span></div><div class="line">        resolve(thisPromiseCount)</div><div class="line">      &#125;,<span class="built_in">Math</span>.random() *<span class="number">2000</span> + <span class="number">1000</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//定义当promise被满足时应做什么</span></div><div class="line">    p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">      <span class="comment">//输出一段信息和一个值</span></div><div class="line">      log.insertAdjacentHTML(<span class="string">'beforeend'</span>,val + <span class="string">') Promise被满足了(异步代码结束)&lt;br/&gt;'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') 建立了Promise(同步代码结束)&lt;br/&gt;&lt;br/&gt;'</span>);</div><div class="line">  &#125;</div><div class="line">  testPromise();</div><div class="line">  testPromise();</div><div class="line">  testPromise();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。</p>
<h2 id="Example-using-new-XMLHttpRequest"><a href="#Example-using-new-XMLHttpRequest" class="headerlink" title="Example using new XMLHttpRequest()"></a>Example using new XMLHttpRequest()</h2><p><strong>创建一个promise</strong><br>这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$http</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> core = &#123;</div><div class="line">    <span class="attr">ajax</span>: <span class="function"><span class="keyword">function</span>(<span class="params">method,url,args</span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        <span class="keyword">var</span> uri = url;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(args &amp;&amp; (method === <span class="string">'POST'</span> || method === <span class="string">'PUT'</span>))&#123;</div><div class="line">          uri += <span class="string">'?'</span>;</div><div class="line">          <span class="keyword">var</span> argcount = <span class="number">0</span>;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> args)&#123;</div><div class="line">            <span class="keyword">if</span>(args.hasOwnProperty(key))&#123;</div><div class="line">              <span class="keyword">if</span>(argcount++)&#123;</div><div class="line">                uri += <span class="string">'&amp;'</span>;</div><div class="line">              &#125;</div><div class="line">              uri += encodeURIcomponent(key) + <span class="string">'='</span> + encodeURIcomponent(args[key]);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        client.open(method, uri);</div><div class="line">        client.send();</div><div class="line"></div><div class="line">        client.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt;<span class="number">300</span>)&#123;</div><div class="line">            resolve(<span class="keyword">this</span>.response);</div><div class="line">          &#125;<span class="keyword">else</span>&#123;</div><div class="line">            reject(<span class="keyword">this</span>.statusText);</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        client.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          reject(<span class="keyword">this</span>.statusText);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//Adapter patten</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'GET'</span>,url,args);</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'post'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'POST'</span>,url,args);</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'delete'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'DELETE'</span>,url,args);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//End A</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mdnAPI = <span class="string">'https://developer.mozilla.org/en-US/search.json'</span>;</div><div class="line"><span class="keyword">var</span> payload = &#123;</div><div class="line">  <span class="string">'topic'</span>: <span class="string">'js'</span>,</div><div class="line">  <span class="string">'q'</span>: <span class="string">'Promise'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> callback = &#123;</div><div class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>,<span class="string">'success'</span>,<span class="built_in">JSON</span>.parse(data));</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>,<span class="string">'error'</span>,<span class="built_in">JSON</span>.parse(data));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//End B</span></div><div class="line"></div><div class="line"><span class="comment">//Executes the method call</span></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success)</div><div class="line">  .catch(callback.error);</div><div class="line"></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success,callback.error);</div><div class="line"></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success)</div><div class="line">  .then(<span class="literal">undefined</span>, callback.error);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Don’t let yesterday take up too much of today.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="promise" scheme="http://gaoquan.wang/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>使用ServiceWorkers</title>
    <link href="http://gaoquan.wang/2016/07/27/%E4%BD%BF%E7%94%A8ServiceWorkers/"/>
    <id>http://gaoquan.wang/2016/07/27/使用ServiceWorkers/</id>
    <published>2016-07-27T15:02:50.000Z</published>
    <updated>2017-06-04T12:54:20.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Don’t let yesterday take up too much of today.</p>
</blockquote>
<p><code>这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</code></p>
<p>本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。</p>
<h2 id="Service-workers出现的背景"><a href="#Service-workers出现的背景" class="headerlink" title="Service workers出现的背景"></a>Service workers出现的背景</h2><p>有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。</p>
<p>之前的尝试–APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。</p>
<p><code>注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。</code></p>
<p>Service workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。</p>
<h2 id="使用Service-workers前的设置"><a href="#使用Service-workers前的设置" class="headerlink" title="使用Service workers前的设置"></a>使用Service workers前的设置</h2><p>在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：</p>
<ul>
<li>FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；</li>
<li>Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；</li>
<li>Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。</li>
</ul>
<p>另外，你需要通过HTTPS来访问你的页面代码–出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>使用service workers，通常遵循以下基本步骤：</p>
<ol>
<li>service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。</li>
<li>如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。</li>
<li>service worker现在可以处理事件了。</li>
<li>受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的–让所有资源可离线访问。</li>
<li>当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。</li>
<li><p>下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。<br>7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。<br><img src="/images/serviceWorker/sw-lifecycle.png" alt="Worker lifecycle"></p>
<p>下图表示了service worker所有支持的事件：<br><img src="/images/serviceWorker/sw-events.png" alt="Events"></p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promises</a>是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。</p>
<p>Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。</p>
<p>接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：</p>
</li>
</ol>
<p><strong>同步</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="keyword">var</span> value = myFunction();</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125; <span class="keyword">catch</span>(err)&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>异步</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFunction().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。</p>
<p>现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgLoad</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.open(<span class="string">'Get'</span>,url);</div><div class="line">    request.responseType = <span class="string">'blob'</span>;</div><div class="line"></div><div class="line">    request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(request.status == <span class="number">200</span>)&#123;</div><div class="line">        resolve(request.response);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        reject(<span class="built_in">Error</span>(<span class="string">'Image didn\'t load successfully; error code:'</span> + request.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      reject(<span class="built_in">Error</span>(<span class="string">'There was a network error.'</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request.send();</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。</p>
<p>当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</div><div class="line"><span class="keyword">var</span> myImage = <span class="keyword">new</span> Image();</div><div class="line"></div><div class="line">imgLoad(<span class="string">'myLittleVader.jpg'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> imageURL = <span class="built_in">window</span>.URL.createObjectURL(response);</div><div class="line">myImage.src = imageURL;</div><div class="line">body.appendChild(myImage);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">Error</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Error</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Don’t let yesterday take up too much of today.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="service worker" scheme="http://gaoquan.wang/tags/service-worker/"/>
    
  </entry>
  
  <entry>
    <title>初识ServiceWorker</title>
    <link href="http://gaoquan.wang/2016/07/26/%E5%88%9D%E8%AF%86ServiceWorker/"/>
    <id>http://gaoquan.wang/2016/07/26/初识ServiceWorker/</id>
    <published>2016-07-26T15:50:01.000Z</published>
    <updated>2017-06-04T12:54:20.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The best preparation for tomorrow is doing your best today.</p>
</blockquote>
<p><code>Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.</code></p>
<h2 id="Service-worker的概念和用法"><a href="#Service-worker的概念和用法" class="headerlink" title="Service worker的概念和用法"></a>Service worker的概念和用法</h2><p>serviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。</p>
<p>service worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。</p>
<p>为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。</p>
<p><code>注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。</code></p>
<p><code>注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。</code></p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>使用<code>ServiceWorkerContainer.register()</code>方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。</p>
<h2 id="下载、安装和激活"><a href="#下载、安装和激活" class="headerlink" title="下载、安装和激活"></a>下载、安装和激活</h2><p>此时，你的service worker会遵守以下的生命周期。</p>
<ol>
<li>下载</li>
<li>安装</li>
<li>激活</li>
</ol>
<p>当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。</p>
<p>之后它会至少每24小时被下载一次。它<strong>可能</strong>被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。</p>
<p>当下载的文件被发现是新的，就会尝试进行安装–无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。</p>
<p>如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。</p>
<p>如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活–此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。</p>
<p>你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。</p>
<p>同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.</p>
<p>service worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。</p>
<p>你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。</p>
<p><code>注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。</code></p>
<h2 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h2><p>Service workers也可以被用来做这些事情：</p>
<ul>
<li>后台数据同步</li>
<li>响应其他源的资源请求</li>
<li>集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了</li>
<li>为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理</li>
<li>为监控后台服务提供钩子</li>
<li>针对特定URL的个性化模板</li>
<li>增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片</li>
</ul>
<p>在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：</p>
<ul>
<li>后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。</li>
<li>对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容</li>
<li>对时间或日期作出响应</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The best preparation for tomorrow is doing your best today.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Service worker本质上作为一个代理坐落于web应用和浏览器与网
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="service worker" scheme="http://gaoquan.wang/tags/service-worker/"/>
    
  </entry>
  
  <entry>
    <title>这个API很迷人</title>
    <link href="http://gaoquan.wang/2016/07/25/%E8%BF%99%E4%B8%AAAPI%E5%BE%88%E8%BF%B7%E4%BA%BA/"/>
    <id>http://gaoquan.wang/2016/07/25/这个API很迷人/</id>
    <published>2016-07-25T07:25:12.000Z</published>
    <updated>2017-06-04T12:54:20.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章转载自<a href="http://www.w3ctech.com/topic/854" target="_blank" rel="external">这个API很“迷人”——(新的Fetch API)</a>，仅供学习和参考</p>
</blockquote>
<h2 id="原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思"><a href="#原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思" class="headerlink" title="原标题是This API is so Fetching, Fetching也可以表示迷人的意思"></a>原标题是This API is so Fetching, Fetching也可以表示迷人的意思</h2><p>Javascript通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说他很有用，但他不是最佳API。他在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近Javascript流行的Promise以及基于生成器的异步编程模型不太搭。</p>
<p>新的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch</a> API打算修正上面提到的那些缺陷。他向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个使用的函数fetch()用来捕捉从网络上检索一个资源的意图。</p>
<p><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch规范</a>的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：</p>
<ol>
<li>改善离线体验</li>
<li>保持可扩展性</li>
</ol>
<h2 id="特性检测"><a href="#特性检测" class="headerlink" title="特性检测"></a>特性检测</h2><p>要检查是否支持Fetch API，可以通过检查Headers、Request、Response或者fetch在window或者worker作用域中是否存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(self.fetch)&#123;</div><div class="line">  <span class="comment">//run my fetch request here</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">// do something with XMLHttpRequest</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简单的fetching示例"><a href="#简单的fetching示例" class="headerlink" title="简单的fetching示例"></a>简单的fetching示例</h3><p>在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'./data.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="comment">// res instanceof response == true</span></div><div class="line">  <span class="keyword">if</span>(res.ok)&#123;</div><div class="line">    res.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Looks like the response'</span>,res.status);</div><div class="line">  &#125;</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Fetch failed'</span>,e);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果是提交一个POST请求，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'http://www.example.org/submit.php'</span>,&#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="string">'firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess'</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(res.ok)&#123;</div><div class="line">    alert(<span class="string">'Perfect! Your settings are saved.'</span>);</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res.status == <span class="number">401</span>)&#123;</div><div class="line">    alert(<span class="string">'Oops! You are not authorized.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  alert(<span class="string">'Error submitting form!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>fetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch().</p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Fetch引入了3个接口，它们分别是Headers、Request以及Response。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。<br>Headers接口是一个简单的多映射的名-值表<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = <span class="string">'Hello World'</span>;</div><div class="line"><span class="keyword">var</span> reqHeaders = <span class="keyword">new</span> Headers();</div><div class="line">reqHeaders.append(<span class="string">'Content-Type'</span>,<span class="string">'text/plain'</span>);</div><div class="line">reqHeaders.append(<span class="string">'Content-Length'</span>,content.length.toString());</div><div class="line">reqHeaders.append(<span class="string">'X-Custom-Header'</span>,<span class="string">'ProcessThisImmediately'</span>);</div></pre></td></tr></table></figure></p>
<p>也可以传一个多维数组或者json：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reqHeaders = <span class="keyword">new</span> Headers(&#123;</div><div class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</div><div class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</div><div class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Headers的内容可以被检索：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">'Content-Type'</span>));</div><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">"Set-Cookie"</span>));</div><div class="line">reqHeaders.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>);</div><div class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"AnotherValue"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reqHeaders.get(<span class="string">"Content-Length"</span>));</div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>));</div><div class="line"></div><div class="line">reqHeaders.delete(<span class="string">"X-Custom-Header"</span>);</div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>));</div></pre></td></tr></table></figure></p>
<p>一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API。</p>
<p>由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。<br>可能的值如下：</p>
<ul>
<li>“none”: 默认值。</li>
<li>“request”: 从Request中获得的Headers只读。</li>
<li>“request-no-cors”: 从不同域的Request中获得的Headers只读。</li>
<li>“response”: 从Response获得的Headers只读.</li>
<li>“immutable”: 在ServiceWorkers中最常用，所有的Headers都只读。</li>
</ul>
<p>哪一种guard作用于Headers导致什么行为，详细定义在这个<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">规范</a>中。例如，你不可以添加或者修改一个guard属性是”request”的Request Headers的”Content-Length”属性。同样地，插入”Set-Cookie”属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Request的headers添加一些cookies。</p>
<p>如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出TypeError异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = Response.error();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  res.headers.set(<span class="string">'Origin'</span>, <span class="string">'http://myback.com'</span>)</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Cannot pretend to be a bank!'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Requset"><a href="#Requset" class="headerlink" title="Requset"></a>Requset</h3><p>Request接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers,同时Requset也接受一个特定的body、mode、credentials以及cache hints.<br>最简单的Request当然是一个URL，可以通过URL来GET一个资源。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(<span class="string">'./index.html'</span>);</div><div class="line"><span class="built_in">console</span>.log(req.method); <span class="comment">//"GET"</span></div><div class="line"><span class="built_in">console</span>.log(req.url);</div></pre></td></tr></table></figure></p>
<p>你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> copy = <span class="keyword">new</span> Request(req);</div><div class="line"><span class="built_in">console</span>.log(copy.method);</div><div class="line"><span class="built_in">console</span>.log(copy.url);</div></pre></td></tr></table></figure></p>
<p>这种用法通常见于ServiceWorkers.<br>URL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uploadReq = <span class="keyword">new</span> Request(<span class="string">'/uploadImage'</span>,&#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'image/png'</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="string">'image data'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>mode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为<code>same-origin</code>,<code>no-cors</code>以及<code>cors</code>。</p>
<p><code>same-origin</code>模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arbitraryUrl = <span class="built_in">document</span>.getElementById(<span class="string">'url-input'</span>).value;</div><div class="line">fetch(arbitraryUrl, &#123;<span class="attr">mode</span>:<span class="string">'same-origin'</span>&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Response succeeded '</span>, res.ok);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Please enter a same-orgin URL!'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>no-cors</code>模式允许来自CDN的脚本、其他域的图片和其他一些跨域的资源，但是首先有个前提条件，就是请求的method只能是’HEAD’、’GET’或者’POST’。此外，任何ServiceWorkers拦截了这些请求，它不能随意添加或者改写任何headers，除了<a href="https://fetch.spec.whatwg.org/#simple-header" target="_blank" rel="external">这些</a>。第三，javascript不能访问Response中的任何属性，这保证了ServiceWorkers不会导致任何跨域下的安全问题而隐私信息泄露。</p>
<p><code>cros</code>模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS协议</a>.只有有限的<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-cors" target="_blank" rel="external">一些</a>headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> URLSearchParams();</div><div class="line">u.append(<span class="string">'method'</span>, <span class="string">'flickr.interestingness.getList'</span>);</div><div class="line">u.append(<span class="string">'api_key'</span>, <span class="string">'&lt;insert api key here&gt;'</span>);</div><div class="line">u.append(<span class="string">'format'</span>, <span class="string">'json'</span>);</div><div class="line">u.append(<span class="string">'nojsoncallback'</span>, <span class="string">'1'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> apiCall = fetch(<span class="string">'https://api.flickr.com/services/rest?'</span> + u);</div><div class="line"></div><div class="line">apiCall.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">    <span class="comment">// photo is a list of photos.</span></div><div class="line">    <span class="keyword">return</span> json.photos.photo;</div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">photos</span>) </span>&#123;</div><div class="line">  photos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">photo</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(photo.title);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>你无法从Headers中读取’Date’属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.headers.get(<span class="string">'Date'</span>); <span class="comment">//null</span></div></pre></td></tr></table></figure></p>
<p><code>credentials</code>枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是’omit(默认)’、’same-origin’以及’include’。<br>Request对象也可以提供caching hints给用户代理。这个属性还在安全复审阶段。Firefox提供了这个属性，但是它目前还不起作用。<br>Request还有两个只读的属性与ServiceWorkers拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用fetch()函数，这个值是fetch。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。<br>Response中最常见的成员是status(一个整数默认值是200)和status Text(默认值是’OK’)，对应HTTP请求的status和reason。还有一个’ok’属性，当status为2xx的时候它是true.<br>headers属性是Response的Headers对象，它是只读的，url属性是当前Response的来源URL.<br>Response也有一个type属性，它的值可能是’basic’、’cors’、’default’、’error’或者’opaque’。</p>
<ul>
<li>‘basic’: 正常的，同域的请求，包含所有的headers除开’Set-Cookie’和’Set-Cookie2’.</li>
<li>‘cros’: Response从一个合法的跨域请求获得，<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-cors" target="_blank" rel="external">一部分headers和body</a>可读.</li>
<li>‘error’: 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。</li>
<li>‘opaque’: Response从’no-cros’请求了跨域资源。依靠Server端来做限制。</li>
</ul>
<p>‘error’类型会导致fetch()函数的Promise被reject并回调一个TypeError.<br>还有一些属性只在ServiceWorkers作用域下有效。以正确的方式返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  event.responseWith(<span class="keyword">new</span> Response(<span class="string">'Response body'</span>, &#123;</div><div class="line">    <span class="attr">headers</span>: &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;</div><div class="line">  &#125;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如你所见，Response有个接收两个可选参数的构造器。第一个参数返回的body，第二个参数是一个json,设置status、statusText以及headers.<br>静态方法Response.error()简单返回一个错误的请求。类似的，Response.redirect(url,status)返回一个跳转URL的请求。</p>
<h3 id="处理body"><a href="#处理body" class="headerlink" title="处理body"></a>处理body</h3><p>无论Request还是Response都可能带着body。由于body可以是各种类型。body可以是以下任何一种类型的示例:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView" target="_blank" rel="external">ArrayBufferView</a>(Unit8Array and friends)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="external">File</a></li>
<li>字符串</li>
<li><a href="https://url.spec.whatwg.org/#interface-urlsearchparams" target="_blank" rel="external">URLSearchParams</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="external">FormData</a></li>
</ul>
<p>此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。</p>
<ul>
<li>arrayBuffer()</li>
<li>blof()</li>
<li>json()</li>
<li>text()</li>
<li>formData()<br>在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。</li>
</ul>
<p>可以通过传body参数来设置Request的body：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'login-form'</span>));</div><div class="line">fetch(<span class="string">'/login'</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">  <span class="attr">body</span>: form</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Response的第一个参数是body:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="keyword">new</span> File([<span class="string">'chunk'</span>, <span class="string">'chunk'</span>], <span class="string">'archive.zip'</span>,&#123; <span class="attr">type</span>: <span class="string">'application/zip'</span> &#125;));</div></pre></td></tr></table></figure></p>
<p>Request和Response(通过fetch()方法)都能够<a href="https://fetch.spec.whatwg.org/#concept-bodyinit-extract" target="_blank" rel="external">自动识别自己的content type</a>，Request还可以自动设置’Content-Type’header,如果开发者没有设置它的话。</p>
<h3 id="流和克隆"><a href="#流和克隆" class="headerlink" title="流和克隆"></a>流和克隆</h3><p>非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed,读取一次之后设置为true，就不能再读取了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="string">'one time use'</span>);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//false</span></div><div class="line">res.text().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//true</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//true</span></div><div class="line"></div><div class="line">res.text().catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Tried to read already consumed Response'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。<br>有时候，我们希望多次访问body，例如，你可能想用即将支持的<a href="http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects" target="_blank" rel="external">Cache API</a>去缓存Request和Response,以便于可以离线使用，Cache要求body能被再次读取。</p>
<p>所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，<strong>clone()必须要在读取之前调用，也就是先clone()在读取</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> sheep = <span class="keyword">new</span> Response(<span class="string">'Dolly'</span>);</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">//false</span></div><div class="line">  <span class="keyword">var</span> clone = sheep.clone();</div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">//false</span></div><div class="line"></div><div class="line">  clone.text();</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">//false</span></div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">//true</span></div><div class="line"></div><div class="line">  evt.responseWith(cache.add(sheep.clone()).then(fucntion(e)&#123;</div><div class="line">    <span class="keyword">return</span> sheep;</div><div class="line">  &#125;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="未来的改进"><a href="#未来的改进" class="headerlink" title="未来的改进"></a>未来的改进</h3><p>为了支持流，Fetch最终将提供可以中断执行读取资源的能力，并且提供可以得到读取进度的API。这些能力在XHR中有，但是想要实现成Promise-based的Fetch API有些麻烦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转载自&lt;a href=&quot;http://www.w3ctech.com/topic/854&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个API很“迷人”——(新的Fetch API)&lt;/a&gt;，仅供学习和参考&lt;/p&gt;
&lt;/b
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="protocol" scheme="http://gaoquan.wang/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>迭代协议</title>
    <link href="http://gaoquan.wang/2016/06/27/%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE/"/>
    <id>http://gaoquan.wang/2016/06/27/迭代协议/</id>
    <published>2016-06-27T13:13:55.000Z</published>
    <updated>2017-06-04T12:54:20.338Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Success is getting what you want, happiness is wanting what you get.  </p>
</blockquote>
<p>作为ECMAScript 2015(ES6)新增加的一部分，它不是新语法或一个新的内置对象，而是一种协议(protocol)。这种协议能被任何遵循某些约定的对象实现。</p>
<p>它们是两类协议：可遍历(可迭代)协议和迭代器协议。</p>
<h2 id="可遍历-可迭代-协议"><a href="#可遍历-可迭代-协议" class="headerlink" title="可遍历(可迭代)协议"></a>可遍历(可迭代)协议</h2><p><strong>可遍历(可迭代)</strong>协议允许javascript对象去定义或定制它们的迭代行为，例如(定义)在一个for…of结构中什么值可以被循环(得到)。一些内置类型都是内置的可遍历对象并且有默认的迭代行为，比如Array or Map,另一些类型则不是(比如Object)</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Success is getting what you want, happiness is wanting what you get.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为ECMAScript 2015(ES6)新增加的一部分，它不
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="protocol" scheme="http://gaoquan.wang/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>JSON.stringify--JSON.parse</title>
    <link href="http://gaoquan.wang/2016/06/23/JSON-stringify-JSON-parse/"/>
    <id>http://gaoquan.wang/2016/06/23/JSON-stringify-JSON-parse/</id>
    <published>2016-06-23T07:54:07.000Z</published>
    <updated>2017-06-04T12:54:20.266Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>When things go wrong, don’t go with them.</p>
</blockquote>
<h2 id="JSON-stringify-概述"><a href="#JSON-stringify-概述" class="headerlink" title="JSON.stringify()概述"></a>JSON.stringify()概述</h2><p>JSON.stringify()方法可以将任意的javascript值序列化成JSON字符串。<br><code>JSON.stringify(value[, replacer [, space]])</code></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>value – 将要序列化成JSON字符串的值。<br>replacer – (可选)如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中。<br>space – (可选)指定缩进用的空白字符，用于美化输出(pretty-print)。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>关于序列化，有下面五点注意事项：</p>
<ul>
<li>非数组对象的属性不能保证以特定的顺序出现序列化后的字符串中。</li>
<li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li>
<li>undefined、任意的函数以及symbol值，在序列化过程中会被忽略(出现在非数组对象的属性值中时)或者被转换成null(出现在数组中时)。</li>
<li>所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。</li>
<li>不可枚举的属性会被忽略。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(&#123;&#125;);   <span class="comment">//'&#123;&#125;'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">true</span>);   <span class="comment">//'true'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="string">"foo"</span>);   <span class="comment">//'"foo"'</span></div><div class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">"false"</span>, <span class="literal">false</span>]);   <span class="comment">//'[1, "false", false]'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>:<span class="number">5</span>&#125;);    <span class="comment">//'&#123;"x":5&#125;'</span></div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>&#125;);              </div><div class="line"><span class="comment">// '&#123;"x":5,"y":6&#125;' 或者 '&#123;"y":6,"x":5&#125;' 都可能</span></div><div class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"false"</span>), <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)]);</div><div class="line"><span class="comment">// '[1,"false",false]'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="built_in">Object</span>, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">""</span>)&#125;);</div><div class="line"><span class="comment">// '&#123;&#125;'</span></div><div class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">""</span>)]);          </div><div class="line"><span class="comment">// '[null,null,null]'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;[<span class="built_in">Symbol</span>(<span class="string">"foo"</span>)]: <span class="string">"foo"</span>&#125;);                 </div><div class="line"><span class="comment">// '&#123;&#125;'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;[<span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>)]: <span class="string">"foo"</span>&#125;, [<span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>)]);</div><div class="line"><span class="comment">// '&#123;&#125;'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;[<span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>)]: <span class="string">"foo"</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">k, v</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> k === <span class="string">"symbol"</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"a symbol"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// '&#123;&#125;'  </span></div><div class="line"></div><div class="line"><span class="comment">// 不可枚举的属性默认会被忽略：</span></div><div class="line"><span class="built_in">JSON</span>.stringify( <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123; <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="string">'x'</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;, <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="string">'y'</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125; &#125;) );</div><div class="line"><span class="comment">// '&#123;"y":"y"&#125;'</span></div></pre></td></tr></table></figure>
<h3 id="space参数"><a href="#space参数" class="headerlink" title="space参数"></a>space参数</h3><p>space参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格(最多10个空格);如果是一个字符串，则每一级别会比上一级别多缩进用该字符串(或该字符串的前十个字符)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="literal">null</span>, <span class="string">' '</span>);    <span class="comment">//'&#123;\n"a": 2\n&#125;'</span></div></pre></td></tr></table></figure></p>
<p>使用制表符(\t)来缩进<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">uno</span>: <span class="number">1</span>, <span class="attr">doc</span>: <span class="number">2</span>&#125;, <span class="literal">null</span>, <span class="string">'\t'</span>);</div><div class="line"><span class="comment">// '&#123;            \</span></div><div class="line"><span class="comment">//     "uno": 1, \</span></div><div class="line"><span class="comment">//     "dos": 2  \</span></div><div class="line"><span class="comment">// &#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="toJSON方法"><a href="#toJSON方法" class="headerlink" title="toJSON方法"></a>toJSON方法</h3><p>如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是按个对象被序列化，而是调用toJSON方法后的返回值会被序列化，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify(obj);  <span class="comment">//'"bar"'</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: obj&#125;);  <span class="comment">//'&#123;"x": "bar"&#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="使用JSON-stringify结合localStorage的例子"><a href="#使用JSON-stringify结合localStorage的例子" class="headerlink" title="使用JSON.stringify结合localStorage的例子"></a>使用JSON.stringify结合localStorage的例子</h3><p>一些时候，你想存储用户创建的一个对象，并且即使在浏览器被关闭后仍能恢复该对象。下面的例子是JSON.stringify适用于这种情形的一个样板：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个示例数据</span></div><div class="line"><span class="keyword">var</span> session = &#123;</div><div class="line">  <span class="string">'screens'</span>: [],</div><div class="line">  <span class="string">'state'</span>: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenA"</span>, <span class="string">"width"</span>:<span class="number">450</span>, <span class="string">"height"</span>:<span class="number">250</span>&#125;);</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenB"</span>, <span class="string">"width"</span>:<span class="number">650</span>, <span class="string">"height"</span>:<span class="number">350</span>&#125;);</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenC"</span>, <span class="string">"width"</span>:<span class="number">750</span>, <span class="string">"height"</span>:<span class="number">120</span>&#125;);</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenD"</span>, <span class="string">"width"</span>:<span class="number">250</span>, <span class="string">"height"</span>:<span class="number">60</span>&#125;);</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenE"</span>, <span class="string">"width"</span>:<span class="number">390</span>, <span class="string">"height"</span>:<span class="number">120</span>&#125;);</div><div class="line">session.screens.push(&#123;<span class="string">"name"</span>:<span class="string">"screenF"</span>, <span class="string">"width"</span>:<span class="number">1240</span>, <span class="string">"height"</span>:<span class="number">650</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//使用JSON.stringify转换为JSON字符串</span></div><div class="line"><span class="comment">//然后使用localStorage保存在session名称里</span></div><div class="line">localStorage.setItem(<span class="string">'session'</span>, <span class="built_in">JSON</span>.stringify(session));</div><div class="line"></div><div class="line"><span class="comment">//然后是如何转换通过JSON.stringify生成的字符串，该字符串以JSON格式保存在localStorage里</span></div><div class="line"><span class="keyword">var</span> restoreSession = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'session'</span>));</div><div class="line"></div><div class="line"><span class="comment">//现在restoreSession 包含了保存在localStorage里的对象</span></div><div class="line"><span class="built_in">console</span>.log(restoreSession);</div></pre></td></tr></table></figure></p>
<h2 id="JSON-parse-概述"><a href="#JSON-parse-概述" class="headerlink" title="JSON.parse()概述"></a>JSON.parse()概述</h2><p>JSON.parse()方法可以将一个JSON字符串解析成为一个javascript值。在解析过程中，还可以选择性的修改某些属性的原始解析值。<br><code>JSON.parse(text[, reviver])</code></p>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>text – 要解析的JSON字符串<br>reviver – 一个函数，用来转换解析出的属性值</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>从text字符串解析出的一个Object</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>如果解析的JSON字符串包含语法错误，则会抛出SyntaxError异常。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="使用JSON-parse"><a href="#使用JSON-parse" class="headerlink" title="使用JSON.parse()"></a>使用JSON.parse()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>);              <span class="comment">// &#123;&#125;</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>);            <span class="comment">// true</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'"foo"'</span>);           <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1, 5, "false"]'</span>); <span class="comment">// [1, 5, "false"]</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'null'</span>);            <span class="comment">// null</span></div></pre></td></tr></table></figure>
<h3 id="使用reviver函数"><a href="#使用reviver函数" class="headerlink" title="使用reviver函数"></a>使用reviver函数</h3><p>如果指定了reviver函数，则解析出的javascript值(解析值)会经过一次转换后才将被最终返回(返回值)。更具体点就是：解析值本身以及它所包含的所有属性，会按照一定的顺序(从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身)分别的去调用reviver函数，在调用过程中，当前属性所属的对象回作为this值，当前属性名和属性值会分别作为第一个和第二个参数传入reviver中。如果reviver返回undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。</p>
<p>当遍历到最顶层的值(解析值)时，传入reviver函数的参数会是空字符串””(因为此时已经没有真正的属性)和当前的解析值(有可能已经被修改过)，当前的this值会是{“”:修改过得解析值}，在编写reviver函数时，要注意到这个特例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"p":5&#125;'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(k === <span class="string">''</span>) <span class="keyword">return</span> v;  <span class="comment">// 如果到了最顶层，则直接返回属性值，</span></div><div class="line">  <span class="keyword">return</span> v*<span class="number">2</span>;             <span class="comment">// 否则将属性值变为原来的 2 倍。</span></div><div class="line">&#125;)                        <span class="comment">// &#123; p: 10 &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"1": 1, "2": 2,"3": &#123;"4": 4, "5": &#123;"6": 6&#125;&#125;&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">k, v</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(k); <span class="comment">// 输出当前的属性名，从而得知遍历顺序是从内向外的，</span></div><div class="line">                  <span class="comment">// 最后一个属性名会是个空字符串。</span></div><div class="line">  <span class="keyword">return</span> v;       <span class="comment">// 返回原始属性值，相当于没有传递 reviver 参数。</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="comment">// 5</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// ""</span></div></pre></td></tr></table></figure>
<h3 id="JSON-parse-不允许用逗号作为结尾"><a href="#JSON-parse-不允许用逗号作为结尾" class="headerlink" title="JSON.parse()不允许用逗号作为结尾"></a>JSON.parse()不允许用逗号作为结尾</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//both will throw a SyntaxError</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">"[1,2,3,4, ]"</span>);</div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"foo":1, &#125;'</span>);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;When things go wrong, don’t go with them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;JSON-stringify-概述&quot;&gt;&lt;a href=&quot;#JSON-stringify-概述&quot; class=&quot;h
    
    </summary>
    
      <category term="笔记" scheme="http://gaoquan.wang/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="JSON" scheme="http://gaoquan.wang/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>数组中插入元素</title>
    <link href="http://gaoquan.wang/2016/06/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/"/>
    <id>http://gaoquan.wang/2016/06/20/数组中插入元素/</id>
    <published>2016-06-20T07:01:12.000Z</published>
    <updated>2017-06-04T12:54:20.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在数组中插入元素"><a href="#在数组中插入元素" class="headerlink" title="在数组中插入元素"></a>在数组中插入元素</h1><p>在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过<code>push</code>来在一个数组的尾部插入一个元素，或者用<code>unshift</code>在数组的开头插入一个元素，或者用<code>splice</code>在元素的中间。这些都是被广泛使用的方法，但是这并不意味着我们没有更加高效的方法。比如：</p>
<h2 id="在数组的尾部新增一个元素"><a href="#在数组的尾部新增一个元素" class="headerlink" title="在数组的尾部新增一个元素"></a>在数组的尾部新增一个元素</h2><p>在数组的尾部新增一个元素最简单的方法是<code>push()</code>，但是还是有其他的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [];</div><div class="line"></div><div class="line">arr.push(<span class="number">6</span>);</div><div class="line">arr[arr.length] = <span class="number">6</span>;</div><div class="line">arr2 = arr.concat([<span class="number">6</span>]);</div></pre></td></tr></table></figure></p>
<p>上面的方法都能够修改原始的数组。</p>
<h3 id="那我们看看在移动设备上性能比较："><a href="#那我们看看在移动设备上性能比较：" class="headerlink" title="那我们看看在移动设备上性能比较："></a>那我们看看在移动设备上性能比较：</h3><p><strong>Android(v4.2.2)</strong></p>
<ol>
<li>arr.push(6);以及arr[arr.length] = 6; 性能是相同的，都是3 319 694 ops/sec</li>
<li>arr2 = arr.concat([6]); 相比较上面的两个方法在性能上慢50.61%<br><strong>Chrome Mobile(v33.0.0)</strong></li>
<li>arr[arr.length] = 6; //6 125 975 ops/sec</li>
<li>arr.push(6); //慢66.74%</li>
<li>arr2 = arr.concat([6]); //慢87.63%<br><strong>Safari Mobile</strong></li>
<li>arr[arr.length] = 6; //7 452 898 ops/sec</li>
<li>arr.push(6); //慢40.19%</li>
<li>arr2 = arr.concat([6]); //慢49.78%<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最终的比较结果</span></div><div class="line">arr[arr.length] = <span class="number">6</span>; <span class="comment">//平均为5 632 856 ops/sec</span></div><div class="line">arr.push(<span class="number">6</span>); <span class="comment">//慢33.64%</span></div><div class="line">arr2 = arr.concat([<span class="number">6</span>]); <span class="comment">//慢62.67%</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="我们再看看在桌面设备上的性能比较"><a href="#我们再看看在桌面设备上的性能比较" class="headerlink" title="我们再看看在桌面设备上的性能比较"></a>我们再看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>
<ol>
<li>arr[arr.length] = 6; //21 602 722 ops/sec</li>
<li>arr.push(6); //慢61.94%</li>
<li>arr2 = arr.concat([6]); //慢87.45%<br><strong>Firefox(v44)</strong></li>
<li>arr[arr.length] = 6; //56 032 805 ops/sec</li>
<li>arr.push(6); //慢0.52%</li>
<li>arr2 = arr.concat([6]); //慢87.36%<br><strong>IE(v11)</strong></li>
<li>arr[arr.length] = 6; //67 197 046 ops/sec</li>
<li>arr.push(6); //慢39.61%</li>
<li>arr2 = arr.concat([6]); //慢93.41%<br><strong>Opera(v35.0.2066.68)</strong></li>
<li>arr[arr.length] = 6; //30 775 071 ops/sec</li>
<li>arr.push(6); //慢71.60%</li>
<li>arr2 = arr.concat([6]); //慢83.70%<br><strong>Safari(v9.0.3)</strong></li>
<li>arr[arr.length] = 6; //42 670 978 ops/sec</li>
<li>arr.push(6); //慢0.80%</li>
<li>arr2 = arr.concat([6]); //慢76.07%<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最终的比较结果</span></div><div class="line">arr[arr.length] = <span class="number">6</span>; <span class="comment">//平均为42 345 449 ops/sec</span></div><div class="line">arr.push(<span class="number">6</span>); <span class="comment">//慢34.66%</span></div><div class="line">arr2 = arr.concat([<span class="number">6</span>]); <span class="comment">//慢85.79%</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="在数组的开头新增一个元素"><a href="#在数组的开头新增一个元素" class="headerlink" title="在数组的开头新增一个元素"></a>在数组的开头新增一个元素</h2><p>现在我们尝试在数组的开头新增一个元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"></div><div class="line">arr.unshift(<span class="number">0</span>);</div><div class="line">[<span class="number">0</span>].concat(arr);</div></pre></td></tr></table></figure></p>
<h3 id="我们看看在移动设备上的性能比较"><a href="#我们看看在移动设备上的性能比较" class="headerlink" title="我们看看在移动设备上的性能比较"></a>我们看看在移动设备上的性能比较</h3><p><strong>Android(v4.2.2)</strong></p>
<ol>
<li>[0].concat(arr); //1 808 717 ops/sec</li>
<li>arr.unshift(0); //慢97.85%<br><strong>Chrome Mobile(v33.0.0)</strong></li>
<li>[0].concat(arr); //1 269 498 ops/sec</li>
<li>arr.unshift(0); //慢99.86%<br><strong>Safari Mobile(v9)</strong></li>
<li>arr.unshift(0); //3 250 184 ops/sec</li>
<li>[0].concat(arr); //慢33.67%<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最终的比较结果</span></div><div class="line">[<span class="number">0</span>].concat(arr); <span class="comment">//平均为4 972 622 ops/sec</span></div><div class="line">arr.unshift(<span class="number">0</span>); <span class="comment">//慢64.70%</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="我们看看在桌面设备上的性能比较"><a href="#我们看看在桌面设备上的性能比较" class="headerlink" title="我们看看在桌面设备上的性能比较"></a>我们看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>
<ol>
<li>[0].concat(arr); //2 656 685 ops/sec</li>
<li>arr.unshift(0); //慢96.77%<br><strong>Firefox(v44)</strong></li>
<li>[0].concat(arr); //8 039 759 ops/sec</li>
<li>arr.unshift(0); //慢99.72%<br><strong>IE(v11)</strong></li>
<li>[0].concat(arr); //3 604 226 ops/sec</li>
<li>arr.unshift(0); //慢98.31%<br><strong>Opera(v35.0.2066.68)</strong></li>
<li>[0].concat(arr); //4 102 128 ops/sec</li>
<li>arr.unshift(0); //慢97.44%<br><strong>Safari(v9.0.3)</strong></li>
<li>arr.unshift(0); //12 356 477 ops/sec</li>
<li>[0].concat(arr); //慢15.17%<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最终的比较结果</span></div><div class="line">[<span class="number">0</span>].concat(arr); <span class="comment">//平均为6 032 573 ops/sec</span></div><div class="line">arr.unshift(<span class="number">0</span>); <span class="comment">//慢78.65%</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="在数组的中间新增一个元素"><a href="#在数组的中间新增一个元素" class="headerlink" title="在数组的中间新增一个元素"></a>在数组的中间新增一个元素</h2><p>在数组中间新增一个元素的最简单的方法是<code>splice</code>，并且用它是最高效的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = [<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>];</div><div class="line">items.splice(item.length/<span class="number">2</span>, <span class="number">0</span>, <span class="string">'hello'</span>);</div></pre></td></tr></table></figure></p>
<p>我尝试在各个不同类型的浏览器和移动设备中进行了测试，结果是类似的。我希望这些tips能够对你有所帮助并且鼓励你也尝试自己做这些尝试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在数组中插入元素&quot;&gt;&lt;a href=&quot;#在数组中插入元素&quot; class=&quot;headerlink&quot; title=&quot;在数组中插入元素&quot;&gt;&lt;/a&gt;在数组中插入元素&lt;/h1&gt;&lt;p&gt;在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过&lt;code&gt;push&lt;/code
    
    </summary>
    
      <category term="翻译" scheme="http://gaoquan.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="tips" scheme="http://gaoquan.wang/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>es6系列教程四</title>
    <link href="http://gaoquan.wang/2016/06/06/es6%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B/"/>
    <id>http://gaoquan.wang/2016/06/06/es6系列教程四/</id>
    <published>2016-06-06T04:15:00.000Z</published>
    <updated>2017-06-04T12:54:20.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Fading is true while flowering is past.  </p>
</blockquote>
<h1 id="Map-Set-和-WeakMap-WeakSet"><a href="#Map-Set-和-WeakMap-WeakSet" class="headerlink" title="Map,Set 和 WeakMap,WeakSet"></a>Map,Set 和 WeakMap,WeakSet</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>集合(Set)对象允许你存储任意类型的唯一值(不能重复)，无论是原始数据还是对象引用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>new Set([iterable]);  </p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>iterable – 一个可迭代对象，其中的所有元素都会被加入到Set中。null被视作undefined。</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。</p>
<h4 id="值的相等"><a href="#值的相等" class="headerlink" title="值的相等"></a>值的相等</h4><p>因为Set中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等(===操作符)不同。具体来说，对于Set, +0(+0严格相等于-0)和-0是不同的值。尽管在最新的ECMAScript6规范中这点已被更改。另外NaN和undefined都可被存储在Set中，NaN之间被视为相同的值(尽管NaN !== NaN)。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Set.length – length属性的值为0</p>
<p>Set.prototype – 表示Set构造器的原型，允许向所有Set对象添加新的属性。</p>
<h3 id="Set实例"><a href="#Set实例" class="headerlink" title="Set实例"></a>Set实例</h3><p>所有的Set实例继承自Set.prototype。示例：使用Set对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">mySet.add(<span class="number">1</span>);</div><div class="line">mySet.add(<span class="number">5</span>);</div><div class="line">mySet.add(<span class="string">"Some text"</span>);</div><div class="line"></div><div class="line">mySet.has(<span class="number">1</span>); <span class="comment">//true</span></div><div class="line">mySet.has(<span class="number">3</span>); <span class="comment">//false,3没有被添加到set中</span></div><div class="line">mySet.has(<span class="number">5</span>); <span class="comment">//true</span></div><div class="line">mySet.has(<span class="built_in">Math</span>.sqrt(<span class="number">25</span>));  <span class="comment">// true</span></div><div class="line">mySet.has(<span class="string">"Some Text"</span>.toLowerCase()); <span class="comment">// true</span></div><div class="line"></div><div class="line">mySet.size; <span class="comment">// 3</span></div><div class="line"></div><div class="line">mySet.delete(<span class="number">5</span>); <span class="comment">// 从set中移除5</span></div><div class="line">mySet.has(<span class="number">5</span>);    <span class="comment">// false, 5已经被移除</span></div><div class="line"></div><div class="line">mySet.size; <span class="comment">// 2, 我们刚刚移除了一个值</span></div></pre></td></tr></table></figure></p>
<p>示例：迭代Set<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//迭代整个set</span></div><div class="line"><span class="comment">//按顺序输出：1, "some text"</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet) <span class="built_in">console</span>.log(item);</div><div class="line"></div><div class="line"><span class="comment">//按顺序输出：1,,"some text"</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet.keys()) <span class="built_in">console</span>.log(item);</div><div class="line"></div><div class="line"><span class="comment">//按顺序输出：1,"some text"</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet.values()) <span class="built_in">console</span>.log(item);</div><div class="line"></div><div class="line"><span class="comment">//按顺序输出：1,"some text"(键与值相等)</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span>[key,value] <span class="keyword">of</span> mySet.entries()) <span class="built_in">console</span>.log(key);</div><div class="line"></div><div class="line"><span class="comment">//转换Set为Array(with Array coprehensions)</span></div><div class="line"><span class="keyword">var</span> myArr = [v <span class="keyword">for</span> (v <span class="keyword">of</span> mySet)]; <span class="comment">//[1,"some text"]</span></div><div class="line"><span class="comment">//替代方案(with Array.from)</span></div><div class="line"><span class="keyword">var</span> myArr = <span class="built_in">Array</span>.from(mySet); <span class="comment">// [1,"some text"]</span></div><div class="line"></div><div class="line"><span class="comment">//如果在HTML文档中工作，也可以：</span></div><div class="line">mySet.add(<span class="built_in">document</span>.body);</div><div class="line">mySet.has(<span class="built_in">document</span>.querySelector(<span class="string">"body"</span>)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//Set和Array转换</span></div><div class="line">mySet2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</div><div class="line">mySet2.size; <span class="comment">//4</span></div><div class="line">[...mySet2]; <span class="comment">//[1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">//截取</span></div><div class="line"><span class="keyword">var</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>([x <span class="keyword">for</span>(x <span class="keyword">of</span> set1) <span class="keyword">if</span> (set2 has(x))]);</div><div class="line"></div><div class="line"><span class="comment">//用forEach迭代</span></div><div class="line">mySet.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>示例：和Array对象的关系<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="string">"value1"</span>, <span class="string">"value2"</span>, <span class="string">"value3"</span>];</div><div class="line"></div><div class="line"><span class="comment">//用Set构造器将Set转换为Array</span></div><div class="line"><span class="keyword">var</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>(myArray);</div><div class="line"></div><div class="line">mySet.has(<span class="string">"value1"</span>); <span class="comment">//returns true</span></div><div class="line"></div><div class="line"><span class="comment">//用...(展开操作符)操作符将Set转换为Array</span></div><div class="line">alert(uneval([...mySet])); <span class="comment">//与myArray完全一致</span></div></pre></td></tr></table></figure></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Map对象就是简单的键/值映射。其中键和值可以是任意值(原始值或对象值).</p>
<p>在判断两个值是否为同一个键的时候，使用的并不是===运算符，而是使用了一种称之为”same-value”的内部算法，该算法很特殊，对于Map对象来说,+0(按照以往的经验与-0是严格相等的)和-0是两个不同的键。而NaN在作为Map对象的键时和另外一个NaN是一个相同的键(尽管NaN !== NaN)</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th><strong>Constructor</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>new Map([iterable])</td>
<td style="text-align:center">返回一个新的Map对象。如果参数iterable是一个数组或者其他可迭代的对象 – 它的元素是键值对，这样这些每一个键值对都可以添加到新的Map里面去</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td style="text-align:center"><strong>描述</strong></td>
</tr>
<tr>
<td>myMap.get(key)</td>
<td style="text-align:center">返回键key关联的值，如果该键不存在则返回undefined</td>
</tr>
<tr>
<td>myMap.set(key,value)</td>
<td style="text-align:center">设置键key在myMap中的值为value。返回undefined</td>
</tr>
<tr>
<td>myMap.has(key)</td>
<td style="text-align:center">返回一个布尔值，表明键key是否存在于myMap中</td>
</tr>
<tr>
<td>myMap.delete(key)</td>
<td style="text-align:center">删除键key及对应的值.在这之后,myMap.has(key)将会返回false</td>
</tr>
<tr>
<td>myMap.entries()</td>
<td style="text-align:center">返回一个迭代器，迭代器按照对象的插入顺序返回[key,value];</td>
</tr>
<tr>
<td>myMap.forEach(callbackFn[,thisArg])</td>
<td style="text-align:center">循环执行函数并把键/值对作为参数;thisArg为可选的，如果有thisArg的话将会作为执行函数的上下文this;</td>
</tr>
<tr>
<td>myMap.keys()</td>
<td style="text-align:center">返回一个迭代器，迭代器按照Map实例的插入顺序返回每一个key元素;</td>
</tr>
<tr>
<td>myMap.clear()</td>
<td style="text-align:center">清空myMap中的所有键值对</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td style="text-align:center"><strong>描述</strong></td>
</tr>
<tr>
<td>myMap.size</td>
<td style="text-align:center">返回myMap中键值对的数量。</td>
</tr>
</tbody>
</table>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,</div><div class="line">    keyFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    keyString = <span class="string">"a string"</span>;</div><div class="line"></div><div class="line"><span class="comment">//添加键</span></div><div class="line">myMap.set(keyString, <span class="string">"和键'a string'关联的值"</span>);</div><div class="line">myMap.set(keyObj, <span class="string">"和键keyObj关联的值"</span>);</div><div class="line">myMap.set(keyFunc, <span class="string">"和键keyFunc关联的值"</span>);</div><div class="line"></div><div class="line">myMap.size; <span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="comment">//读取值</span></div><div class="line">myMap.get(keyString); <span class="comment">// "和键'a string'关联的值"</span></div><div class="line">myMap.get(keyObj); <span class="comment">// "和键keyObj关联的值"</span></div><div class="line">myMap.get(keyFunc); <span class="comment">//"和键keyFunc关联的值"</span></div><div class="line"></div><div class="line">myMap.get(<span class="string">"a string"</span>); <span class="comment">//"和键'a string'关联的值"</span></div><div class="line">                       <span class="comment">//因为keyString == "a string"</span></div><div class="line">myMap.get(&#123;&#125;);         <span class="comment">//undefined,因为keyObj !== &#123;&#125;</span></div><div class="line">myMap.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)<span class="comment">//undefined,因为keyFunc !== function()&#123;&#125;</span></div></pre></td></tr></table></figure>
<p>NaN也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN返回true)，但下面的例子表明，两个NaN作为Map的键来说是没有区别的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">myMap.set(<span class="literal">NaN</span>,<span class="string">"not a number"</span>);</div><div class="line"></div><div class="line">myMap.get(<span class="literal">NaN</span>); <span class="comment">//"not a number"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> otherNaN = <span class="built_in">Number</span>(<span class="string">"foo"</span>);</div><div class="line">myMap.get(otherNaN); <span class="comment">//"not a number"</span></div></pre></td></tr></table></figure></p>
<p>javascript有两个0值，+0和-0.虽然+0 === -0,但是当这两个0作为Map的键时，被认为是两个不同的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">myMap.set(<span class="number">0</span>,<span class="string">"正零"</span>);</div><div class="line">myMap.set(<span class="number">-0</span>,<span class="string">"负零"</span>);</div><div class="line"></div><div class="line"><span class="number">0</span> === <span class="number">-0</span>; <span class="comment">// true</span></div><div class="line"></div><div class="line">myMap.get(<span class="number">-0</span>); <span class="comment">// "负零"</span></div><div class="line">myMap.get(<span class="number">0</span>);  <span class="comment">// "正零"</span></div></pre></td></tr></table></figure></p>
<h3 id="Object和Map的比较"><a href="#Object和Map的比较" class="headerlink" title="Object和Map的比较"></a>Object和Map的比较</h3><p>Object和Map类似的一点是，它们都允许你按键存取一个值，都可以删除键，还可以检测一个键是否绑定了值。因此，一直以来，我们都把对象当成Map来使用，现在有了Map,下面的区别解释了为什么使用Map更好点。</p>
<ul>
<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键，不过，现在可以使用map = Object.create(null)来创建一个没有原型的对象。</li>
<li>一个对象的键只能是字符串，但一个Map的键可以是任意值。</li>
<li>你可以很容易的得到一个Map的键值对个数，而只能跟踪一个对象的键值对个数。</li>
</ul>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>一个WeakSet对象是一个无序的集合，可以用它来存储任意的对象值，并且对这些对象值保持弱引用。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>new WeakSet([iterable]);  </p>
</blockquote>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>iterable – 如果传入一个可迭代对象作为参数，则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>WeakSet对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。</p>
<p>它和Set对象的区别有两点：</p>
<ul>
<li>WeakSet对象中只能存放对象值，不能存放原始值，而Set对象都可以。</li>
<li>WeakSet对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值，则这个对象值会被当成垃圾回收掉。正因为这样，WeakSet对象是无法被枚举的，没有办法拿到它包含的所有元素。</li>
</ul>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>WeakSet.length – length属性的值为0</p>
<p>WeakSet.prototype – WeakSet实例的所有继承属性和继承方法都在该对象上。</p>
<h3 id="WeakSet实例"><a href="#WeakSet实例" class="headerlink" title="WeakSet实例"></a>WeakSet实例</h3><p>所有WeakSet实例都继承自WeakSet.prototype</p>
<p>属性 – WeakSet.prototype.constructor(返回构造函数即WeakSet本身)。</p>
<p>方法</p>
<ul>
<li>WeakSet.prototype.add(value) – 在该 WeakSet 对象中添加一个新元素 value.</li>
<li>WeakSet.prototype.clear() – 清空该 WeakSet 对象中的所有元素.</li>
<li>WeakSet.prototype.delete(value) – 从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false.</li>
<li>WeakSet.prototype.has(value) – 返回一个布尔值,  表示给定的值 value 是否存在于这个 WeakSet 中.</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(<span class="built_in">window</span>);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line">ws.has(foo);    <span class="comment">// false, 对象 foo 并没有被添加进 ws 中</span></div><div class="line"></div><div class="line">ws.delete(<span class="built_in">window</span>); <span class="comment">// 从集合中删除 window 对象</span></div><div class="line">ws.has(<span class="built_in">window</span>);    <span class="comment">// false, window 对象已经被删除了</span></div><div class="line"></div><div class="line">ws.clear(); <span class="comment">// 清空整个 WeakSet 对象</span></div></pre></td></tr></table></figure>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>WeakMap对象就是简单的键/值映射。但键只能是对象值，不可以是原始值。</p>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>myWeakMap.get(key [,defaultValue])</td>
<td style="text-align:center">返回键key关联的值，如果该键不存在则返回默认值defaultValue</td>
</tr>
<tr>
<td>myWeakMap.set(key,value)</td>
<td style="text-align:center">设置键key在myWeakMap中的值，返回undefined</td>
</tr>
<tr>
<td>myWeakMap.has(key)</td>
<td style="text-align:center">返回一个布尔值来表明键key是否在myWeakMap中</td>
</tr>
<tr>
<td>myWeakMap.delete(key)</td>
<td style="text-align:center">删除键key及对应的值。在这之后，myWeakMap.has(key)将返回false</td>
</tr>
<tr>
<td>myWeakMap.clear()</td>
<td style="text-align:center">清空myWeakMap中的所有的键值对，返回undefined</td>
</tr>
</tbody>
</table>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</div><div class="line">    wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</div><div class="line">    wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="keyword">var</span> o1 = &#123;&#125;,</div><div class="line">    o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    o3 = <span class="built_in">window</span>;</div><div class="line"></div><div class="line">wm1.set(o1, <span class="number">37</span>);</div><div class="line">wm1.set(o2, <span class="string">"azerty"</span>);</div><div class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象</span></div><div class="line">wm2.set(o3, <span class="literal">undefined</span>);</div><div class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></div><div class="line">wm1.get(o2); <span class="comment">// "azerty"</span></div><div class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></div><div class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></div><div class="line"></div><div class="line">wm1.has(o2); <span class="comment">// true</span></div><div class="line">wm2.has(o2); <span class="comment">// false</span></div><div class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></div><div class="line"></div><div class="line">wm3.set(o1, <span class="number">37</span>);</div><div class="line">wm3.get(o1); <span class="comment">// 37</span></div><div class="line">wm3.clear();</div><div class="line">wm3.get(o1); <span class="comment">// undefined,wm3已被清空</span></div><div class="line">wm1.has(o1);   <span class="comment">// true</span></div><div class="line">wm1.delete(o1);</div><div class="line">wm1.has(o1);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="为什么要使用WeakMap"><a href="#为什么要使用WeakMap" class="headerlink" title="为什么要使用WeakMap?"></a>为什么要使用WeakMap?</h3><p>经验丰富的JavaScript程序员会注意到，WeakMap完全通过两个数组(一个存放键，一个存放值)来实现。但这样的实现会有两个很大的缺点，首先是O(n)的时间复杂度(n是键值对的个数)。另外一个则可能或导致内存泄漏；在这种自己实现的WeakMap中，存放键的数组中的每个索引将会保持对所引用对象的引用，阻止他们被当做垃圾回收。而在原生的WeakMap中，每个键对自己所引用对象的引用是“弱引用”，这意味着，如果没有其他引用和该键引用同一个对象，这个对象将会被当做垃圾回收。</p>
<p>正由于这样的弱引用, WeakMap 的keys是无法遍历的 (无法列举出所有的keys). 如果允许被遍历的话, 遍历的结果将会受垃圾回收的影响, 从而得到不确定的结果. 因此,如果你想得到所有keys的值,你应该自己管理他们. 另外ECMAScript提案中还介绍了另外两种集合类型,Map和Set,他们没有使用弱引用,所以是可遍历的.</p>
<h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Proxy对象用来为基础操作(例如：属性查找、赋值、枚举、方法调用等)定义用户自定义行为。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>handler – 包含traps的对象。<br>traps – 提供访问属性的途径，与操作系统中的traps定义相似<br>target – 被代理虚拟化的对象，这个对象常常用作代理的存储后端。关于对象不可拓展性和不可修改属性的不变量会被代理拦截。</p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p>var p = new Proxy(target, handler);  </p>
</blockquote>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>target – 目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。<br>handler – 处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Proxy.revocable() – 创建一个可撤销的代理对象。</p>
<h2 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h2><p>handler是占位符对象，它包含代理的traps</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><p>以下简单的例子中，当对象不存在属性名时，缺省返回数37.例子中使用了get处理器(get handler)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target,name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target? target[name] : <span class="number">37</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</div><div class="line">p.a = <span class="number">1</span>;</div><div class="line">p.b = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p.a, p.b); <span class="comment">// 1, undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></div></pre></td></tr></table></figure></p>
<h3 id="无操作转发代理"><a href="#无操作转发代理" class="headerlink" title="无操作转发代理"></a>无操作转发代理</h3><p>在以下例子中，我们使用了一个原生JavaScript对象，代理会将所有应用到它的操作转发到这个对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;&#125;);</div><div class="line"></div><div class="line">p.a = <span class="number">37</span>; <span class="comment">//被转发到代理的操作</span></div><div class="line"><span class="built_in">console</span>.log(target.a); <span class="comment">//37 操作已经被正确地转发。</span></div></pre></td></tr></table></figure></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>通过代理，你可以轻松地验证向一个对象的传值。以下例子使用了set处理器(set handler)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> validator = &#123;</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj,prop,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(pop === <span class="string">'age'</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(!<span class="built_in">Number</span>.isInteger(value))&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(value &gt; <span class="number">200</span>)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//The default behavior to store the value</span></div><div class="line">    obj[prop] = value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">//100</span></div><div class="line">person.age = <span class="string">'young'</span>; <span class="comment">//抛出异常</span></div><div class="line">person.age = <span class="number">300</span>; <span class="comment">//抛出异常</span></div></pre></td></tr></table></figure></p>
<h3 id="扩展构造函数"><a href="#扩展构造函数" class="headerlink" title="扩展构造函数"></a>扩展构造函数</h3><p>方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。以下的例子中使用了constructor处理器(construct handler)和apply处理器(apply handler).<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fading is true while flowering is past.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Map-Set-和-WeakMap-WeakSet&quot;&gt;&lt;a href=&quot;#Map-Set-和-WeakMap-W
    
    </summary>
    
      <category term="原创" scheme="http://gaoquan.wang/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="es6" scheme="http://gaoquan.wang/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6系列教程三</title>
    <link href="http://gaoquan.wang/2016/06/02/es6%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89/"/>
    <id>http://gaoquan.wang/2016/06/02/es6系列教程三/</id>
    <published>2016-06-02T12:45:03.000Z</published>
    <updated>2017-06-04T12:54:20.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Experience is the mother.</p>
</blockquote>
<h1 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h1><p>解构赋值(destructuring assignment)语法是一个Javascript表达式，它使得从数组或者对象中提取数据赋值给不同的变量成为可能。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[a,b] = [<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">[a,b,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">&#123;a,b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</div><div class="line">&#123;a,b,...rest&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">4</span>&#125; <span class="comment">//ES7</span></div></pre></td></tr></table></figure>
<blockquote>
<p>{a,b} = {a:1,b:2}作为独立语法是非法的，左侧的{a,b}会被当成块结构而不是一个对象。<br>然而({a,b} = {a:1,b:2})的形式是允许的，其等价于var {a,b} = {a:1,b:2}.  </p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。一旦你创建了这类数据组，你可以用任意的方法使用这些数据组，甚至从函数中返回它们。</p>
<p>解构赋值的一个特别有用的功能是：你可以用一个表达式读取整个结构。你可以从后面的例子中了解到很多它的其他的有趣应用。</p>
<p>解构赋值的作用类似于Perl和Python语言中的相似特性。</p>
<h2 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h2><h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>];</div><div class="line"></div><div class="line"><span class="comment">//没有解构赋值</span></div><div class="line"><span class="keyword">var</span> one = foo[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> two = foo[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> three = foo[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">//解构赋值</span></div><div class="line"><span class="keyword">var</span> [one,two,three] = foo;</div></pre></td></tr></table></figure>
<h3 id="变换变量"><a href="#变换变量" class="headerlink" title="变换变量"></a>变换变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">[a,b] = [b,a];</div></pre></td></tr></table></figure>
<p>执行这段代码后，b是1、a是3.没有解构赋值的情况下，交换两个变量需要一个临时变量.</p>
<h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>感谢解构赋值，函数现在可以返回多个值。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，两个返回值被括号括起来，用类似数组表示法的方式被返回。你可用这种方法返回任意量的变量。这个方法中，f()返回[1,2].<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a,b;</div><div class="line">[a,b] = f();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"A is "</span> + a + <span class="string">" B is "</span> + b);</div></pre></td></tr></table></figure></p>
<p>[a,b] = f()把函数的返回值按顺序赋值给括号中的变量：a赋值为1、b赋值为2.</p>
<p>你也可以把返回值当作数组对待：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = f();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"A is "</span> + a);</div></pre></td></tr></table></figure></p>
<p>这样a就是一个包含1和2两个值的数组。</p>
<h3 id="忽略某些返回值"><a href="#忽略某些返回值" class="headerlink" title="忽略某些返回值"></a>忽略某些返回值</h3><p>你也可以忽略你不感兴趣的返回值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> [a,b] = f();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"A is "</span> + a + <span class="string">" B is "</span> + b);</div></pre></td></tr></table></figure></p>
<p>运行这段代码后，a是1、b是3。2这个值被忽略，你可以忽略任意(或全部)返回值。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[,,] = f();</div></pre></td></tr></table></figure></p>
<h3 id="用正则表达式匹配提取值"><a href="#用正则表达式匹配提取值" class="headerlink" title="用正则表达式匹配提取值"></a>用正则表达式匹配提取值</h3><p>用正则表达式方法exec()匹配字符串返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串–如果不需要的话。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"https://developer.mozilla.org/en-US/Web/JavaScript"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> parsedURL = <span class="regexp">/^(\w+)\:\/\/([]^\/]+)\/(.*)$/</span>.exec(url);</div><div class="line"><span class="keyword">var</span> [,protocol,fullhost,fullpath] = parseURL;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(protocol); <span class="comment">//输出"https:"</span></div></pre></td></tr></table></figure></p>
<h2 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p</span>:<span class="number">42</span>,<span class="attr">q</span>:<span class="literal">true</span>&#125;;</div><div class="line"><span class="keyword">var</span> &#123;p,q&#125; = o;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p);</div><div class="line"><span class="built_in">console</span>.log(q);</div><div class="line"></div><div class="line"><span class="comment">//用新变量名赋值</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">p</span>:foo,<span class="attr">q</span>:bar&#125; = o;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//42</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><p>ES5版本<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES5Chart</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  options = options === <span class="literal">undefined</span> ? &#123;&#125; : options;</div><div class="line">  <span class="keyword">var</span> size = options.size === <span class="literal">undefined</span> ? <span class="string">'big'</span> : options.size;</div><div class="line">  <span class="keyword">var</span> cords = options.cords === <span class="literal">undefined</span> ? &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; : options.cords;</div><div class="line">  <span class="keyword">var</span> radius = options.radius === <span class="literal">undefined</span> ? <span class="number">25</span> : options.radius;</div><div class="line">  <span class="built_in">console</span>.log(size, cords, radius);</div><div class="line">  <span class="comment">// now finally do some chart drawing</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">drawES5Chart(&#123;</div><div class="line">  <span class="attr">cords</span>: &#123; <span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</div><div class="line">  <span class="attr">radius</span>: <span class="number">30</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>ES6版本<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES6Chart</span>(<span class="params">&#123;size = <span class="string">'big'</span>,cords = &#123;x:<span class="number">0</span>,y:<span class="number">0</span>&#125;,radius = <span class="number">25</span>&#125; = &#123;&#125;</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(size,cords,radius);</div><div class="line">&#125;</div><div class="line"></div><div class="line">drawES6Chart(&#123;</div><div class="line">  <span class="attr">cords</span>: &#123;<span class="attr">x</span>:<span class="number">18</span>,<span class="attr">y</span>:<span class="number">30</span>&#125;,</div><div class="line">  <span class="attr">radius</span>: <span class="number">30</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="解构嵌套对象和数组"><a href="#解构嵌套对象和数组" class="headerlink" title="解构嵌套对象和数组"></a>解构嵌套对象和数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> metadata = &#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">"Scratchpad"</span>,</div><div class="line">  <span class="attr">translations</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">locale</span>: <span class="string">"de"</span>,</div><div class="line">      <span class="attr">localization_tags</span>: [ ],</div><div class="line">      <span class="attr">last_edit</span>: <span class="string">"2014-04-14T08:43:37"</span>,</div><div class="line">      <span class="attr">url</span>: <span class="string">"/de/docs/Tools/Scratchpad"</span>,</div><div class="line">      <span class="attr">title</span>: <span class="string">"JavaScript-Umgebung"</span></div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="attr">url</span>: <span class="string">"/en-US/docs/Tools/Scratchpad"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">title</span>: englishTitle, <span class="attr">translations</span>: [&#123; <span class="attr">title</span>: localeTitle &#125;] &#125; = metadata;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(englishTitle); <span class="comment">// "Scratchpad"</span></div><div class="line"><span class="built_in">console</span>.log(localeTitle);  <span class="comment">// "JavaScript-Umgebung"</span></div></pre></td></tr></table></figure>
<h3 id="For-of迭代和解构"><a href="#For-of迭代和解构" class="headerlink" title="For of迭代和解构"></a>For of迭代和解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> people = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Mike Smith"</span>,</div><div class="line">    <span class="attr">family</span>: &#123;</div><div class="line">      <span class="attr">mother</span>: <span class="string">"Jane Smith"</span>,</div><div class="line">      <span class="attr">father</span>: <span class="string">"Harry Smith"</span>,</div><div class="line">      <span class="attr">sister</span>: <span class="string">"Samantha Smith"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">age</span>: <span class="number">35</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Tom Jones"</span>,</div><div class="line">    <span class="attr">family</span>: &#123;</div><div class="line">      <span class="attr">mother</span>: <span class="string">"Norah Jones"</span>,</div><div class="line">      <span class="attr">father</span>: <span class="string">"Richard Jones"</span>,</div><div class="line">      <span class="attr">brother</span>: <span class="string">"Howard Jones"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">age</span>: <span class="number">25</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> &#123;<span class="attr">name</span>:n,<span class="attr">family</span>:&#123; <span class="attr">father</span>:f &#125;&#125; <span class="keyword">of</span> people)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Name: "</span> + n + <span class="string">",Father: "</span> + f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// "Name: Mike Smith, Father: Harry Smith"</span></div><div class="line"><span class="comment">// "Name: Tom Jones, Father: Richard Jones"</span></div></pre></td></tr></table></figure>
<h3 id="从作为函数实参的对象中提取数据"><a href="#从作为函数实参的对象中提取数据" class="headerlink" title="从作为函数实参的对象中提取数据"></a>从作为函数实参的对象中提取数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">userId</span>(<span class="params">&#123;id&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> id;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whois</span>(<span class="params">&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(displayName + <span class="string">" is "</span> + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">42</span>,</div><div class="line">  <span class="attr">displayName</span>: <span class="string">"jdoe"</span>,</div><div class="line">  <span class="attr">fullName</span>: &#123;</div><div class="line">      <span class="attr">firstName</span>: <span class="string">"John"</span>,</div><div class="line">      <span class="attr">lastName</span>: <span class="string">"Doe"</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"userId: "</span> + userId(user)); <span class="comment">// "userId: 42"</span></div><div class="line">whois(user); <span class="comment">// "jdoe is John"</span></div></pre></td></tr></table></figure>
<p>这段代码从user对象中提取并输出id、displayName和firstName。</p>
<h3 id="对象属性计算名和解构"><a href="#对象属性计算名和解构" class="headerlink" title="对象属性计算名和解构"></a>对象属性计算名和解构</h3><p>计算属性名，如object literals，可以被解构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> key = <span class="string">"z"</span>;</div><div class="line"><span class="keyword">let</span> &#123; [key]:foo &#125; = &#123; <span class="attr">z</span>:<span class="string">"bar"</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//"bar"</span></div></pre></td></tr></table></figure></p>
<h1 id="Default-Rest-Spread"><a href="#Default-Rest-Spread" class="headerlink" title="Default + Rest + Spread"></a>Default + Rest + Spread</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>如果一个参数没有被传入对应的实参或者传入了undefined，则该形参会被赋一个默认值。现在我们可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="comment">//传统的指定默认参数的方式</span></div><div class="line">  <span class="keyword">var</span> name = name || <span class="string">'coffee'</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//运用ES6的默认参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name = <span class="string">'coffee'</span></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello(); <span class="comment">//输出：Hello coffee</span></div><div class="line">sayHello(<span class="string">'gaoquan'</span>); <span class="comment">//输出：Hello gaoquan</span></div><div class="line">sayHello2(); <span class="comment">//输出：Hello coffee</span></div><div class="line">sayHello2(<span class="string">'gaoquan'</span>); <span class="comment">//输出：Hello gaoquan</span></div></pre></td></tr></table></figure></p>
<h2 id="Rest剩余参数"><a href="#Rest剩余参数" class="headerlink" title="Rest剩余参数"></a>Rest剩余参数</h2><p>在函数被调用时，剩余参数表示为一个数组名，该数组包含了那些没有对应形参的，长度不确定的剩余实参。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a,b, ...theArgs</span>)</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>如果一个函数的最后一个形参是以<code>...</code>为前缀的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。</p>
<p>在上例中，theArgs会包含传递给函数的从第三个实参开始到最后所有的实参(第一个实参映射到a，第二个实参映射到b).</p>
<h4 id="剩余参数和arguments对象之间的区别"><a href="#剩余参数和arguments对象之间的区别" class="headerlink" title="剩余参数和arguments对象之间的区别"></a>剩余参数和arguments对象之间的区别</h4><p>剩余参数和arguments对象之间的区别主要有三个：</p>
<ul>
<li>剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。</li>
<li>arguments对象不是一个真实的数组，而剩余参数是真实的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort、forEach、pop</li>
<li>arguments对象还有一些附加的属性(比如callee属性)</li>
</ul>
<h4 id="arguments对象转换为剩余参数"><a href="#arguments对象转换为剩余参数" class="headerlink" title="arguments对象转换为剩余参数"></a>arguments对象转换为剩余参数</h4><p>使用剩余参数可以避免将arguments转为数组的麻烦.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的代码模拟了剩余数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,f.length);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//现在代码可以简化为这样了</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a,b,...args</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>)</span>&#123;</div><div class="line">  alert(theArgs.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun1(); <span class="comment">//弹出"0"，因为theArgs没有元素</span></div><div class="line">fun1(<span class="number">5</span>); <span class="comment">//弹出"1"，因为theArgs只有一个元素</span></div><div class="line">fun1(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>); <span class="comment">//弹出"3"，因为theArgs有三个元素</span></div></pre></td></tr></table></figure></p>
<p>下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier,...theArgs</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> multiplier * element;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//弹出“2,4,6”</span></div></pre></td></tr></table></figure></p>
<p>下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortRestArgs</span>(<span class="params">...theArgs</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> sortedArgs = theArgs.sort();</div><div class="line">  <span class="keyword">return</span> sortedArgs;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(sortRestArgs(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">//弹出 1,3,5,7</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sortedArgs = <span class="built_in">arguments</span>.sort();</div><div class="line">  <span class="keyword">return</span> sortedArgs; <span class="comment">// 不会执行到这里</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(sortArguments(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 抛出TypeError异常:arguments.sort is not a function</span></div></pre></td></tr></table></figure></p>
<p>如果想在arguments对象上使用数组方法，你首先得将它转换为真实的数组，比如使用 <code>[].slice.call(arguments)</code></p>
<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>展开运算符允许一个表达式在某处展开，在多个参数(用于函数调用)或者多个元素(用于数组字面量)或者多个变量(用于解构赋值)的地方就会这样。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>用于函数调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myFunction(...iterableObj);</div></pre></td></tr></table></figure></p>
<p>用于数组字面量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...iterableObj,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure></p>
<p>用于解构赋值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a,b,...iterableObj] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="更好的apply方法"><a href="#更好的apply方法" class="headerlink" title="更好的apply方法"></a>更好的apply方法</h4><p><strong>例子：</strong> 目前为止，我们都是使用<code>Function.prototype.apply</code>方法来将一个数组展开成多个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x,y,z</span>)</span>&#123; &#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">myFunction.apply(<span class="literal">null</span>,args);</div></pre></td></tr></table></figure></p>
<p>如果使用了ES6的展开运算符，你可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x,y,z</span>)</span>&#123; &#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">myFunction(...args);</div></pre></td></tr></table></figure></p>
<p>还可以使用多个数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">v,w,x,y,z</span>)</span>&#123; &#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>];</div><div class="line">myFunction(<span class="number">-1</span>,...args,<span class="number">2</span>,...[<span class="number">3</span>]);</div></pre></td></tr></table></figure></p>
<h4 id="更强大的数组字面量"><a href="#更强大的数组字面量" class="headerlink" title="更强大的数组字面量"></a>更强大的数组字面量</h4><p><strong>例子：</strong> 目前为止，如果你想创建一个包含某些已有数组里的元素的新数组，通常会用到push、splice、concat等数组方法。有了新的展开运算符，可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parts = [<span class="string">'shoulder'</span>,<span class="string">'knees'</span>];</div><div class="line"><span class="keyword">var</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>]; <span class="comment">// ["head", "shoulders", "knees", "and", "toes"]</span></div></pre></td></tr></table></figure></p>
<p>和函数调用一样，数组字面量中也可以使用…多次。</p>
<h4 id="配合new运算符"><a href="#配合new运算符" class="headerlink" title="配合new运算符"></a>配合new运算符</h4><p><strong>例子：</strong> 在ES5中，我们无法同时使用new运算符合apply方法(apply方法调用[[Call]]而不是[[Construct]])。在ES6中，我们可以使用展开运算符，和普通的函数调用一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dataFields = readDateFields(database);</div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dataFields);</div></pre></td></tr></table></figure></p>
<h4 id="更好的push方法"><a href="#更好的push方法" class="headerlink" title="更好的push方法"></a>更好的push方法</h4><p><strong>例子：</strong> 在ES5中，我们可以使用push方法将一个数组添加到另一个数组的末尾：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="comment">//将arr2中的所有元素添加到arr1中</span></div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1,arr2);</div></pre></td></tr></table></figure></p>
<p>在ES6中，可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">arr1.push(...arr2);</div></pre></td></tr></table></figure></p>
<h4 id="将类数组对象转换成数组"><a href="#将类数组对象转换成数组" class="headerlink" title="将类数组对象转换成数组"></a>将类数组对象转换成数组</h4><p>展开操作可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中，这样就可以得到一个真正的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">var</span> array = [...nodeList];</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Experience is the mother.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Destructuring&quot;&gt;&lt;a href=&quot;#Destructuring&quot; class=&quot;headerlink&quot; title=&quot;Destru
    
    </summary>
    
      <category term="原创" scheme="http://gaoquan.wang/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="es6" scheme="http://gaoquan.wang/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6系列教程二</title>
    <link href="http://gaoquan.wang/2016/06/02/es6%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C/"/>
    <id>http://gaoquan.wang/2016/06/02/es6系列教程二/</id>
    <published>2016-06-02T02:06:25.000Z</published>
    <updated>2017-06-04T12:54:20.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>It’s an imperfect world, but it’s the only one we’ve got.</p>
</blockquote>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>从ECMAScript 6开始，JavaScript有了类(class)这个概念。但是需要注意的是，这并不是说：JavaScript从此变得像其他基于面向对象语言一样，有了一种全新的继承模式。JavaScript中的类只是javascript现有的、基于原型的继承模型的一种语法包装(语法糖)，它能让我们用更简洁明了的语法实现继承。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>ES6中的类实际上就是个函数，而且正如函数的定义方式有函数声明和函数表达式两种一样，类的定义方式也有两种，分别是：</p>
<ul>
<li>类声明</li>
<li>类表达式</li>
</ul>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>类声明是定义类的一种方式，就像下面这样，使用class关键字后跟一个类名（这里是Polygon），就可以定义一个类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height,width)&#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。也就是说，你必须先声明类，然后才能使用它，否则代码会抛出ReferenceError异常，像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Polygon(); <span class="comment">//ReferenceError</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类表达式是定义类的另一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。如果定义了类名，则类名只有在类体内部才能访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//匿名类表达式</span></div><div class="line"><span class="keyword">var</span> Polygon = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height,width)&#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//命名类表达式</span></div><div class="line"><span class="keyword">var</span> Polygon = <span class="class"><span class="keyword">class</span> <span class="title">Polygon</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height,width)&#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h2><p>类的成员需要定义在一对花括号{}里，花括号里的代码和花括号本身组成了类体。类成员包括类构造器和类方法(包括静态方法和实例方法)。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类体中的代码都强制在严格模式中执行，即便你没有写”use strict”。</p>
<h3 id="构造器-constructor方法"><a href="#构造器-constructor方法" class="headerlink" title="构造器(constructor方法)"></a>构造器(constructor方法)</h3><p>constructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化一个类的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常。</p>
<p>在子类的构造器中可以使用super关键字调用父类的构造器。</p>
<h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height,width)&#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get area()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  calcArea()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x,y)&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> distance(a,b)&#123;</div><div class="line">    <span class="keyword">const</span> dx = a*x - b*y;</div><div class="line">    <span class="keyword">const</span> dy = a*y - b*y;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>,<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Point.distance(p1,p2));</div></pre></td></tr></table></figure></p>
<h2 id="使用extends关键字创建子类"><a href="#使用extends关键字创建子类" class="headerlink" title="使用extends关键字创建子类"></a>使用extends关键字创建子类</h2><p>extends 关键字可以用来创建继承于某个类的子类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  speak()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' make a noise.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  speak()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' barks.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="为内置对象类型-Array-RegExp等-创建子类"><a href="#为内置对象类型-Array-RegExp等-创建子类" class="headerlink" title="为内置对象类型(Array,RegExp等)创建子类"></a>为内置对象类型(Array,RegExp等)创建子类</h2><h3 id="使用super关键字引用父类"><a href="#使用super关键字引用父类" class="headerlink" title="使用super关键字引用父类"></a>使用super关键字引用父类</h3><p>super这个关键字。有两种用法，含义不同。</p>
<ol>
<li>作为函数调用时(即super(…args)),super代表父类的构造函数。</li>
<li>作为对象调用时(即super.prop或super.method()),super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  get m()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._p * <span class="keyword">super</span>._p;</div><div class="line">  &#125;</div><div class="line">  set m()&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'该属性只读'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，子类通过super关键字，调用父类实例的_p属性。</p>
<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"MyObject: "</span> + <span class="keyword">super</span>.toString();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.toString(); <span class="comment">//MyObject: [Object Object]</span></div></pre></td></tr></table></figure>
<h2 id="Class的取值函数-getter-和存值函数-setter"><a href="#Class的取值函数-getter-和存值函数-setter" class="headerlink" title="Class的取值函数(getter)和存值函数(setter)"></a>Class的取值函数(getter)和存值函数(setter)</h2><p>与ES5一样，在class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;...&#125;</div><div class="line"></div><div class="line">  get prop()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set prop(value)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line">inst.prop = <span class="number">123</span>;</div><div class="line"><span class="comment">//setter: 123</span></div><div class="line"></div><div class="line">inst.prop</div><div class="line"><span class="comment">//getter</span></div></pre></td></tr></table></figure>
<p>上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(element)&#123;</div><div class="line">    <span class="keyword">this</span>.element = element;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get html()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set html(value)&#123;</div><div class="line">    <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</div><div class="line">  CustomHTMLElement.ptoperty,<span class="string">"html"</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor <span class="comment">//ture</span></div><div class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<h1 id="Enhanced-Object-Literals-增强的对象字面量"><a href="#Enhanced-Object-Literals-增强的对象字面量" class="headerlink" title="Enhanced Object Literals 增强的对象字面量"></a>Enhanced Object Literals 增强的对象字面量</h1><p>对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：</p>
<ul>
<li>可以在对象字面量里面定义原型</li>
<li>定义方法可以不用function关键字</li>
<li>直接调用父类方法</li>
</ul>
<p>这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的javascript时更加轻松方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过对象字面量创建对象</span></div><div class="line"><span class="keyword">var</span> human = &#123;</div><div class="line">  breathe()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'breathing...'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> worker = &#123;</div><div class="line">  <span class="attr">__proto__</span>: human, <span class="comment">//设置此对象的原型为human，相当于继承human</span></div><div class="line">  company: <span class="string">'freelancer'</span>,</div><div class="line">  work()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'working...'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">human.breathe(); <span class="comment">//输出‘breathing...’</span></div><div class="line"><span class="comment">//调用继承来的breathe方法</span></div><div class="line">worker.breathe(); <span class="comment">//输出‘breathing...’</span></div></pre></td></tr></table></figure></p>
<h1 id="Template-Strings-字符串模板"><a href="#Template-Strings-字符串模板" class="headerlink" title="Template Strings 字符串模板"></a>Template Strings 字符串模板</h1><p>模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">`string text`</span></div><div class="line"></div><div class="line"><span class="string">`string text line 1</span></div><div class="line"> string text line 2`</div><div class="line"></div><div class="line"> <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div><div class="line"></div><div class="line"> tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div></pre></td></tr></table></figure>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>模板字符串使用反括号(<code> </code>)来代替普通字符串中的用双引号和单引号。模板字符串可以包含特性语法(${expression})的占位符。占位符中的表达式和周围的文本会在一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数对模板字符串来进行操作处理。</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"string text line 1 \n\</span></div><div class="line">string text line 2");</div><div class="line"><span class="comment">//"string text line 1</span></div><div class="line"><span class="comment">// string text line 2"</span></div></pre></td></tr></table></figure></p>
<p>要获得同样效果的多行字符串，只需要使用代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line">string text line 2`);</div><div class="line"><span class="comment">// "string text line 1</span></div><div class="line"><span class="comment">// string text line 2"</span></div></pre></td></tr></table></figure></p>
<h3 id="表达式插补"><a href="#表达式插补" class="headerlink" title="表达式插补"></a>表达式插补</h3><p>在普通字符串中嵌入表达式，必须使用如下语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Fifteen is "</span> + (a+b) + <span class="string">" and\nnot "</span> + (<span class="number">2</span>*a+b) + <span class="string">"."</span>);</div><div class="line"><span class="comment">// "Fifteen is 15 and</span></div><div class="line"><span class="comment">// not 20."</span></div></pre></td></tr></table></figure></p>
<p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is &amp;&#123;a+b&#125; and\nnot <span class="subst">$&#123;<span class="number">2</span>*a + b&#125;</span>.`</span>);</div><div class="line"><span class="comment">// "Fifteen is 15 and</span></div><div class="line"><span class="comment">// not 20."</span></div></pre></td></tr></table></figure></p>
<h3 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h3><p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许你通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式。最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标志符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">string,...values</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">0</span>]); <span class="comment">// "Hello "</span></div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">1</span>]); <span class="comment">// " world "</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">0</span>]);  <span class="comment">// 15</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">1</span>]);  <span class="comment">// 50</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"Bazinga!"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// "Bazinga!"</span></div></pre></td></tr></table></figure></p>
<h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</div><div class="line"><span class="comment">// "string text line 1 \\n string text line 2"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</div></pre></td></tr></table></figure></p>
<p>另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n5!"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;It’s an imperfect world, but it’s the only one we’ve got.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="原创" scheme="http://gaoquan.wang/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="es6" scheme="http://gaoquan.wang/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6系列教程一</title>
    <link href="http://gaoquan.wang/2016/06/01/es6%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80/"/>
    <id>http://gaoquan.wang/2016/06/01/es6系列教程一/</id>
    <published>2016-06-01T09:03:45.000Z</published>
    <updated>2017-06-04T12:54:20.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Our lives stretched out ahead of us, like a perpetual sunrise.</p>
</blockquote>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><p>开门见山我们先来尝尝一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + i));</div><div class="line"></div><div class="line">  <span class="keyword">var</span> j = i; <span class="comment">//注意这里使用的是var</span></div><div class="line"></div><div class="line">  item.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"Item "</span> + j + <span class="string">" is clicked."</span>);</div><div class="line">   &#125;;</div><div class="line">  list.appendChild(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码的意图是创建5个li，并且点击它们的时候能够打印出当前的序号。但是由于使用了var定义j变量，所以我们发现打印出来的结果都是<code>Item 5 is clicked.</code>,这是因为这里var定义的j是函数级变量，5个内部函数都指向了同一个j，而j最后一次赋值是5.而我们流弊的前辈们变相的引入了块级作用域，并轻松解决了上面的问题，具体如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + i));</div><div class="line"></div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    item.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">"Item "</span> + j + <span class="string">" is clicked."</span>);</div><div class="line">     &#125;;</div><div class="line">  &#125;)(i)</div><div class="line"></div><div class="line">  list.appendChild(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，问题就迎刃而解。因为每循环一次都会产生新的块级作用域(也就是形如<code>(function(){})()</code>这样的写法，没进入一次就生成新的跨级作用域)，在新的块级作用域中5个内部函数指向了不同的j。</p>
<p>现在，该我们的主角出场了。为了实现块级作用域，es6引入了let声明变量的方法，这样的话上面的例子，可以直接简化成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + i));</div><div class="line"></div><div class="line">  <span class="keyword">let</span> j = i; <span class="comment">//这里直接使用let</span></div><div class="line"></div><div class="line">  item.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"Item "</span> + j + <span class="string">" is clicked."</span>);</div><div class="line">   &#125;;</div><div class="line">  list.appendChild(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可以看出let与var的区别，let允许把变量限制在块级域中，而var申明的变量要么是全局的，要么是函数级的，而无法是块级的，这是其中之一的区别。</p>
<h2 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h2><p>下面我们看看let和var在作用域上规则上的区别。用let定义的变量的作用域是定义在它们的块内，以及包含在这个块中的子块；而var定义的变量的作用域是定义在它们的函数内：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">31</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">71</span>; <span class="comment">//相同的变量</span></div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">//71</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(x); <span class="comment">//71    </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">31</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">71</span>; <span class="comment">//不同的变量</span></div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">//71</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(x); <span class="comment">//31</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序或函数的顶层，let的表现就像var一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="string">'global'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</div></pre></td></tr></table></figure>
<p>上面这段代码的运行后会显示两次”global”。</p>
<h2 id="let的暂存死区与错误"><a href="#let的暂存死区与错误" class="headerlink" title="let的暂存死区与错误"></a>let的暂存死区与错误</h2><p>在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(x)&#123;</div><div class="line">  <span class="keyword">let</span> foo;</div><div class="line">  <span class="keyword">let</span> foo; <span class="comment">//TypeError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在es6中，let将会提升这个变量到语句块的顶部。然而，在这个语句块中，在变量声明之前引用这个变量会导致一个ReferenceError的结果，因为let变量在“暂存死区”（从块的开始到声明这段）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">//ReferenceError</span></div><div class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在switch申明中你可能会遇到这样的错误，因为一个switch只有一个作用快。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(x)&#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="keyword">let</span> foo;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    <span class="keyword">let</span> foo; <span class="comment">//TypeError for redeclaration</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环定义中的let作用域"><a href="#循环定义中的let作用域" class="headerlink" title="循环定义中的let作用域"></a>循环定义中的let作用域</h2><p>循环体中是可以引用在for申明时用let定义的变量，尽管let不是出现在大括号之间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=i; i&lt; <span class="number">10</span>; i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注：以上<span class="keyword">let</span>申明的i将会变成<span class="literal">undefined</span>; chrome版本<span class="number">50.0</span><span class="number">.2661</span><span class="number">.102</span>(<span class="number">64</span>-bit); 推荐一下写法：</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> l=i;l&lt;<span class="number">10</span>;l++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>域作用规则<br><code>for (let expr1;expr2;expr3) statement</code><br>在这个例子中，expr2,expr3和statement都是包含在一个隐含域块中，其中也包含了expr1</p>
<h2 id="再看些例子"><a href="#再看些例子" class="headerlink" title="再看些例子"></a>再看些例子</h2><h3 id="let-对比-var"><a href="#let-对比-var" class="headerlink" title="let 对比 var"></a>let 对比 var</h3><p>let的作用域是块，var的作用域是函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(a===<span class="number">5</span>)&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">4</span>; <span class="comment">//The scope is inside the if-block</span></div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>; <span class="comment">//The scope is inside the function</span></div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//4</span></div><div class="line">  <span class="built_in">console</span>.log(b); <span class="comment">//1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<h3 id="let在循环中"><a href="#let在循环中" class="headerlink" title="let在循环中"></a>let在循环中</h3><p>可以用let来代替var，在for定义块中使用块级变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0,1,2,3,4,5,6,7,8,9</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">//i is not defined</span></div></pre></td></tr></table></figure>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的只能赋值一次。这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，常量需要被初始化。也就是说，在定义常量的同时必须初始化(这是有意义的，鉴于变量的值在初始化后就不能改变)。</p>
<p>常量拥有块作用域，和使用let 定义的变量十分相似。常量的值不能通过再赋值改变，也不能再次声明。</p>
<p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面的例子演示了常量的特征。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意: 常量在声明的时候可以使用大小写，但通常情况下会使用全部大写英文。</span></div><div class="line"></div><div class="line"><span class="comment">// 定义常量MY_FAV并赋值7</span></div><div class="line"><span class="keyword">const</span> MY_FAV = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功)</span></div><div class="line">MY_FAV = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 输出 7</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is: "</span> + MY_FAV);</div><div class="line"></div><div class="line"><span class="comment">// 尝试重新声明会报错</span></div><div class="line"><span class="keyword">const</span> MY_FAV = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">//  MY_FAV 保留给上面的常量，这个操作会失败</span></div><div class="line"><span class="keyword">var</span> MY_FAV = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// MY_FAV 依旧为7</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is "</span> + MY_FAV);</div><div class="line"></div><div class="line"><span class="comment">// 下面是一个语法错误</span></div><div class="line"><span class="keyword">const</span> A = <span class="number">1</span>; A = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// 常量要求一个初始值</span></div><div class="line"><span class="keyword">const</span> FOO; <span class="comment">// SyntaxError: missing = in const declaration</span></div><div class="line"></div><div class="line"><span class="comment">// 常量可以定义成对象</span></div><div class="line"><span class="keyword">const</span> MY_OBJECT = &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 重写对象和上面一样会失败</span></div><div class="line">MY_OBJECT = &#123;<span class="string">"OTHER_KEY"</span>: <span class="string">"value"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></div><div class="line">MY_OBJECT.key = <span class="string">"otherValue"</span>;</div></pre></td></tr></table></figure></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this,arguments,super和new.target等对象）。此外，箭头函数时匿名的。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(param1,param2,...,paramN) =&gt; &#123; statements &#125;</div><div class="line">(param1,param2,...,paramN) =&gt; expression</div><div class="line">        <span class="comment">// equivalent to =&gt; &#123; return expression; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">//如果只有一个参数，圆括号是可选的</span></div><div class="line">(singleParam) =&gt; &#123; statements &#125;</div><div class="line">singleParam =&gt; &#123; statements &#125;</div><div class="line"></div><div class="line"><span class="comment">//无参数的函数需要使用圆括号</span></div><div class="line">() =&gt; &#123; statements &#125;</div></pre></td></tr></table></figure>
<h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回对象字面量时应该用圆括号将其包起来：</span></div><div class="line">params =&gt; &#123;<span class="attr">foo</span>:bar&#125;</div><div class="line"></div><div class="line"><span class="comment">//支持Rest parameters 和 default parameters:</span></div><div class="line">(param1,param2,...rest) =&gt; &#123; statements &#125;</div><div class="line">(param1 = defaultValue1,param2,...,paramN = defaultValueN) =&gt; &#123; statements &#125;</div><div class="line"></div><div class="line"><span class="comment">//Destructring within the parameter list is also supported</span></div><div class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">[a,b] = [<span class="number">1</span>,<span class="number">2</span>],&#123;x:c&#125; = &#123;x:a+b&#125;</span>) =&gt;</span> a + b +c;</div><div class="line">f(); <span class="comment">//6</span></div></pre></td></tr></table></figure>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>箭头函数的引用有两个方面的影响：一是更简短的函数书写，二是对this的词法解析。</p>
<h3 id="更短的函数"><a href="#更短的函数" class="headerlink" title="更短的函数"></a>更短的函数</h3><p>在一些函数式编程模式里，更短的函数书写方式很受欢迎。试比较：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [</div><div class="line">  <span class="string">"Hydrogen"</span>,</div><div class="line">  <span class="string">"Helium"</span>,</div><div class="line">  <span class="string">"Lithium"</span>,</div><div class="line">  <span class="string">"Beryl­lium"</span></div><div class="line">];</div><div class="line"><span class="keyword">var</span> a2 = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;<span class="keyword">return</span> s.length&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> a3 = a.map(<span class="function"><span class="params">s</span> =&gt;</span> s.length);</div></pre></td></tr></table></figure></p>
<h3 id="this的词法"><a href="#this的词法" class="headerlink" title="this的词法"></a>this的词法</h3><p>在箭头函数出现之前，每个新定义的函数都有其自己的this值（例如，构造函数的this指向了一个新的对象；严格模式下的函数的this值为undefined；如果函数是作为对象的方法被调用的，则其this指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//构造函数Person()定义的`this`就是新实例对象自己</span></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//在非严格模式下，growUp()函数定义了其内部的`this`</span></div><div class="line">    <span class="comment">//在全局对象，不同于构造函数Person()的定义的`this`</span></div><div class="line">    <span class="keyword">this</span>.age ++;</div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>在ECMAScript3/5中，这个问题可以通过新增一个变量来指向期望的this对象，然后将该变量放到闭包中来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  self.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//回调里面的`self`变量就指向了期望的那个对象了</span></div><div class="line">    self.age ++;</div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，还可以使用bound function,把期望的this值传递给growUp()函数。</p>
<p>箭头函数则会捕获其所在上下文的this值，作为自己的this值，因此下面的代码将如运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.age ++; <span class="comment">//this正确地指向了person对象</span></div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="与strict-mode的关系"><a href="#与strict-mode的关系" class="headerlink" title="与strict mode的关系"></a>与strict mode的关系</h3><p>考虑到this是词法层面上的，严格模式中与this相关的规则都将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="string">`use strict`</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">f() === <span class="built_in">window</span> <span class="comment">//或全局对象</span></div></pre></td></tr></table></figure>
<h3 id="使用call或apply调用"><a href="#使用call或apply调用" class="headerlink" title="使用call或apply调用"></a>使用call或apply调用</h3><p>由于this已经在词法层面完成了bound，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> adder = &#123;</div><div class="line">  <span class="attr">base</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">return</span> f(a);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">var</span> b = &#123;</div><div class="line">      <span class="attr">base</span> : <span class="number">2</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> f.call(b,a)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>)); <span class="comment">//输出2</span></div><div class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">//仍然输出2</span></div></pre></td></tr></table></figure>
<h2 id="arguments的词法"><a href="#arguments的词法" class="headerlink" title="arguments的词法"></a>arguments的词法</h2><p>箭头函数不会在其内部暴露arguments对象：arguments.length,arguments[0],arguments[1]等等，<br>都不会指向箭头函数arguments，而是指向了箭头函数所在作用域的一个名为arguments的值（如果真的有的话，否则，就是undefined）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> arr = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>;</div><div class="line"></div><div class="line">arr(); <span class="comment">//42</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">  <span class="keyword">return</span> f(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>箭头函数没有自己的arguments对象，不过大多数情况下，rest参数可以给出一个解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">0</span>];</div><div class="line">  <span class="keyword">return</span> f(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h3 id="使用yield关键字"><a href="#使用yield关键字" class="headerlink" title="使用yield关键字"></a>使用yield关键字</h3><p>yield关键字通常不在箭头函数中使用。因此，箭头函数不能用作Generator函数</p>
<h3 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a>返回对象字面量</h3><p>请牢记，用params =&gt; {object:literal}这种简单的语法返回一个对象字面量是行不通的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="comment">//calling func() returns undefined!</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125;;</div><div class="line"><span class="comment">//SyntaxError: function statement required a name</span></div></pre></td></tr></table></figure>
<p>这是因为花括号(即{})里面的代码被解析为声明序列了(例如，foo被认为是一个label，而非对象字面量里的键)。</p>
<p>所以，记得用圆括号把对象字面量包起来：<br><code>var func = () =&gt; ({foo:1})</code></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个空箭头函数，返回undefined</span></div><div class="line"><span class="keyword">let</span> empty = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function">(<span class="params">(</span>) =&gt;</span> <span class="string">"foobar"</span>)() <span class="comment">//返回"foobar"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> simple = <span class="function"><span class="params">a</span> =&gt;</span> a &gt; <span class="number">15</span> ? <span class="number">15</span> : a;</div><div class="line">simple(<span class="number">16</span>); <span class="comment">//15</span></div><div class="line">simple(<span class="number">10</span>); <span class="comment">//10</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> max = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a &gt; b ? a : b;</div><div class="line"></div><div class="line"><span class="comment">//Easy array filtering, mapping, ...</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">18</span>,<span class="number">23</span>];</div><div class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a + b); <span class="comment">//66</span></div><div class="line"><span class="keyword">var</span> even = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">//[6,0,18]</span></div><div class="line"><span class="keyword">var</span> double = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>); <span class="comment">//[10,12,26,0,2,36,46]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Our lives stretched out ahead of us, like a perpetual sunrise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerli
    
    </summary>
    
      <category term="原创" scheme="http://gaoquan.wang/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://gaoquan.wang/tags/javascript/"/>
    
      <category term="es6" scheme="http://gaoquan.wang/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>React-Redux文档</title>
    <link href="http://gaoquan.wang/2016/05/31/React-Redux%E6%96%87%E6%A1%A3/"/>
    <id>http://gaoquan.wang/2016/05/31/React-Redux文档/</id>
    <published>2016-05-31T09:58:31.000Z</published>
    <updated>2017-06-04T12:54:20.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>It’s an imperfect world, but it’s the only one we’ve got.  </p>
</blockquote>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>在应用中，只有最顶层组件是对Redux可知（例如路由处理）。所有它们的子组件都应该是“笨拙的”，并且 通过props获取数据。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center"><strong>容器组件</strong></th>
<th style="text-align:left"><strong>展示组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>位置</strong></td>
<td style="text-align:center">最顶层，路由处理</td>
<td style="text-align:left">中间和子组件</td>
</tr>
<tr>
<td><strong>使用Redux</strong></td>
<td style="text-align:center">是</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td><strong>读取数据</strong></td>
<td style="text-align:center">从Redux获取state</td>
<td style="text-align:left">从props获取数据</td>
</tr>
<tr>
<td><strong>修改数据</strong></td>
<td style="text-align:center">向Redux发起actions</td>
<td style="text-align:left">从props调用回调函数</td>
</tr>
</tbody>
</table>
<h2 id="不使用Redux的展示组件"><a href="#不使用Redux的展示组件" class="headerlink" title="不使用Redux的展示组件"></a>不使用Redux的展示组件</h2><p>让我们看下，我们拥有一个<counter>的展示组件，它有一个通过props传过来的值，和一个函数onIncrement，当你点击”Increment”按钮时就会调用这个函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from 'react';</div><div class="line"></div><div class="line">export default class Counter extends Component &#123;</div><div class="line">  render()&#123;</div><div class="line">    return &#123;</div><div class="line">      &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;</div><div class="line">        &#123;this.props.value&#125;</div><div class="line">      &lt;/button&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></counter></p>
<h2 id="容器组件使用connect-方法连接Redux"><a href="#容器组件使用connect-方法连接Redux" class="headerlink" title="容器组件使用connect() 方法连接Redux"></a>容器组件使用connect() 方法连接Redux</h2><p>我们用react-redux提供的connect()方法将“笨拙”的Counter转化成容器组件。connect()允许你从Redux store中指定准确的state到你想要获取的组件中。这让你能获取到任何级别颗粒度的数据。</p>
<p><code>containers/CounterContainer.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Compoennt &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'../components/Counter'</span>;</div><div class="line"><span class="keyword">import</span> &#123; increment &#125; <span class="keyword">from</span> <span class="string">'../actionsCreators'</span>;</div><div class="line"></div><div class="line"><span class="comment">//哪些Redux全局的state是我们组件想要通过props获取的？</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">value</span>: state.counter</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//哪些action创建函数是我们想要通过props获取的？</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onIncrement</span>: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(increment())</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(Counter);</div><div class="line"></div><div class="line"><span class="comment">//你可以传递一个对象，而不是定义一个`mapDispatchToProps`;</span></div><div class="line"><span class="comment">//export default connect(mapStateToProps, CounterActionCreators)(Counter);</span></div><div class="line"><span class="comment">//或者如果你想省略`mapDispatchToProps`,你可以通过传递一个`dispatch`作为一个props:</span></div><div class="line"><span class="comment">//export default connect(mapStateToProps)(Counter);</span></div></pre></td></tr></table></figure>
<p>作为一个展示组件，无论是在同一个文件中调用connect()方法，还是分开调用，都取决于你。你应该考虑的是，是否重用这个组件半丁不同数据。</p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>在你的应用任何层次中，你可以拥有很多使用connect()的组件，甚至你可以把它们嵌套使用。的确如此，但是更好的做法是只在最顶层的组件中使用connect(),例如路由处理，这使得应用中的数据流是保持可预知的。</p>
<h2 id="修饰器的支持"><a href="#修饰器的支持" class="headerlink" title="修饰器的支持"></a>修饰器的支持</h2><p>你可能会注意到，我们在调用connect()方法的时候使用了两个括号。这个叫做局部调用，并且这允许开发者使用ES7提供的修饰语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是还不稳定的写法！可能在实际的应用中被修改或摒弃</span></div><div class="line">@conenct(mapStateToProps)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterContainer</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>不要忘了修饰器还在实验中！在以下的示范中，它们被提取出来，作为一个可以在任何地方调用的函数例子。</p>
<h2 id="额外的灵活性"><a href="#额外的灵活性" class="headerlink" title="额外的灵活性"></a>额外的灵活性</h2><p>这是最基础的用法，但connect()也支持很多其他的模式：通过传递一个普通的dispatch()方法，绑定多个action创建函数，把它们传递到一个action prop中，选择一部分state和绑定的action创建函数依赖到props中。</p>
<h2 id="注入Redux-store"><a href="#注入Redux-store" class="headerlink" title="注入Redux store"></a>注入Redux store</h2><p>最后，我们实际上是怎么连接到 Redux store 的呢？我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。对于服务端渲染而言，你可以在处理请求中完成这个。</p>
<p>关键是从 React Redux 将整个视图结构包装进 <provider>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> targetEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;App /&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  targetEl</div><div class="line">);</div></pre></td></tr></table></figure></provider></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id=""><a href="#" class="headerlink" title=""></a><provider store=""></provider></h2><p><provider store="">是组件层级中connect()方法都能获得Redux store。正常情况下，你的根组件应该嵌套在<provider>中才能使用connect()方法。</provider></provider></p>
<p>如果你真的不想把根组件嵌套在<provider>中，你可以把store作为props传递到每一个被connect()包装的组件，但是我们只推荐您在单元测试中对store进行伪造(stub)或者在非完全基于React的代码中才这样做。正常情况下，你应该使用<provider></provider></provider></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>store(Redux Store): 应用程序中唯一的Redux store对象</li>
<li>children(ReactElement) 组件层级的根组件</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>React</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;MyRootComponent /&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  rootEL</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p><strong>React Router 1.0</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  targetEl</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p><code>connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])</code><br>连接React组件与Redux store.</p>
<p>连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><a href="Function">mapStateToProps(state,[ownProps]): stateProps</a>: 如果定义该参数，组件将会监听Redux store的变化。任何时候，只要Redux store发生变化，mapStateToProps函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的props合并。如果你省略了这个参数，你的组件将不会监听Redux store。如果指定了该回调函数中的第二个参数ownProps，则该参数的值为传递到组件的props，而且只要组件接收到新的props，mapStateToProps也会被调用。</li>
<li><a href="Object or Function">mapDispatchToProps(dispatch,[ownProps]): dispatchProps</a>：如果传递的是一个对象，那么每个定义在该对象的函数都将被当作Redux action creator，而且这个对象会与Redux store绑定在一起，其中所定义的方法名将作为属性名，合并到组件的props中。如果传递的是一个函数，该函数将接收一个dispatch函数，然后由你来决定如何返回一个对象，这个对象通过dispatch函数与action creator以某种方式绑定在一起（提示：你也许会用到Redux的辅助函数bindActionCreators()）.如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。如果你指定了该回调函数中第二个参数ownPros，该参数的值未传递到组件的props，而且只要组件接收到新props，mapDispatchToProps也会被调用。</li>
<li><a href="Function">mergeProps(stateProps,dispatchProps,ownPros): props</a>:如果指定了这个参数，mapStateToProps()与mapDispatchToProps()的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。你也许可以用这个回调函数，根据组件的props来筛选部分的state数据，或者把props中的某个特定变量与action creator绑定在一起。如果你省略这个参数，默认情况下返回Object.assign({},ownPros,stateProps,dispatchProps)的结果。</li>
<li><a href="Object">options</a> 如果指定这个参数，可以定制connector的行为。<ul>
<li><a href="Boolean">pure = true</a>: 如果为true,connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个”纯组件”，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。</li>
<li><a href="Boolean">withRef = false</a>: 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过getWrappedInstance()方法获得。默认值为false</li>
</ul>
</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>根据配置信息，返回一个注入了state和action creator的React组件。</p>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><ul>
<li>WrappedComponent(Component): 传递到connect()函数的原始组件类。</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>组件原来的静态方法都被提升到被包装的React组件。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>getWrappedInstance(): ReactComponent<br>仅当connect()函数的第四个参数options设置了{withRef: true}才返回被包装的组件示例。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>函数将被调用两次。第一次是设置参数，第二次是组件与React store连接：connect(mapStateToProps,mapDispatchToProps,mergeProps)(MyComponent).</li>
<li>connect函数不会修改传入的React组件，返回的是一个新的已与Redux store连接的组件，而且你应该使用这个新组件。</li>
<li>mapStateToProps函数接收整个Redux store的state作为props，然后返回一个传入到组件props的对象。该函数被称之为selector。参考使用reselect高效地组合多个selector，并对收集到的数据进行处理。</li>
</ul>
<h2 id="Example例子"><a href="#Example例子" class="headerlink" title="Example例子"></a>Example例子</h2><p><strong>只注入dispatch，不监听store</strong><br><code>export default conenct(){TodoApp};</code></p>
<p><strong>注入dispatch和全局state</strong></p>
<blockquote>
<p>不要这样做！这会导致每次action都触发整个TodoApp重新渲染，你做的所有性能优化都将付之东流。最好在多个组件上使用connect()，每个组件只监听它所关联的部分state.  </p>
</blockquote>
<p><code>export default connect(state =&gt; state)(TodoApp)</code></p>
<p><strong>注入dispatch和todos</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: state.todos</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> conenct(mapStateToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>注入todos和所有action creator(addTodo,completeTodo,…)</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionsCreators <span class="keyword">from</span> <span class="string">'./actionsCreators'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: state.todos</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,actionsCreators)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>注入todos并把所有action creator作为actions属性也注入组件中</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionsCreators <span class="keyword">from</span> <span class="string">'./actionsCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">todos</span>: state.todos&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">actions</span>: bindActionCreators(actionsCreators,dispatch)&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> dfault connect(mapStateToProps,mapDispatchToProps)(TodoApp)</div></pre></td></tr></table></figure></p>
<p><strong>注入todos和指定的action creator(addTodo)</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; addTodo &#125; <span class="keyword">from</span> <span class="string">'./actionsCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todo</span>: state.todos</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bindActionCreators(&#123;addTodo&#125;,dispatch);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>注入todos并把todoActionCreators作为todoActions属性、counterActionCreators作为counterActions属性注入到组件中</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoActionCreators <span class="keyword">from</span> <span class="string">'./todoActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> counterActionCreators <span class="keyword">from</span> <span class="string">'./counterActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">todos</span>: state.todo&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todoActions</span>: bindActionCreators(todoActionCreators,dispatch),</div><div class="line">    <span class="attr">counterActions</span>: bindActionCreators(counterActionCreators,dispatch)</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>注入todos并把todoActionCreators与counterActionCreators一同作为actions属性注入到组件中</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoActionCreators <span class="keyword">from</span> <span class="string">'./todoActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> counterActionCreators <span class="keyword">from</span> <span class="string">'./counterActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">actions</span>: bindActionCreators(<span class="built_in">Object</span>.assign(&#123;&#125;,todoActionCreators,counterActionCreators),dispatch)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>注入todos并把所有的todoActionCreators和counterActionCreators作为props注入到组件中</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoActionCreators <span class="keyword">from</span> <span class="string">'./todoActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> counterActionCreators <span class="keyword">from</span> <span class="string">'./counterActionCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">todos</span>: state.todo&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bindActionCreators(<span class="built_in">Object</span>.assign(&#123;&#125;, todoActionCreators,counterActionCreators),dispatch);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>根据组件的props注入特定用户的todos</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionsCreators <span class="keyword">from</span> <span class="string">'./actionsCreators'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state,ownProps</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">todos</span>: state.todos[ownProps.userId]&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<p><strong>根据组件的props注入特定用户的todos并把props.userId传入到action中</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionsCreators <span class="keyword">from</span> <span class="string">'./actionsCreators'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">todos</span>: state.todos&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeProps</span>(<span class="params">stateProps,dispatchProps,ownProps</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,ownProps,&#123;</div><div class="line">    <span class="attr">todos</span>: stateProps.todos[ownProps.userId],</div><div class="line">    <span class="attr">addTodo</span>: <span class="function">(<span class="params">text</span>) =&gt;</span> dispatchProps.addTodo(ownProps.userId,text)</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,actionsCreators,mergeProps)(TodoApp);</div></pre></td></tr></table></figure></p>
<h1 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h1><p>这里会列出常见的问题和对应的解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;It’s an imperfect world, but it’s the only one we’ve got.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="转载笔记" scheme="http://gaoquan.wang/categories/%E8%BD%AC%E8%BD%BD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://gaoquan.wang/tags/react/"/>
    
      <category term="Redux" scheme="http://gaoquan.wang/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>用卡通图介绍Redux</title>
    <link href="http://gaoquan.wang/2016/05/30/%E7%94%A8%E5%8D%A1%E9%80%9A%E5%9B%BE%E4%BB%8B%E7%BB%8DRedux/"/>
    <id>http://gaoquan.wang/2016/05/30/用卡通图介绍Redux/</id>
    <published>2016-05-30T08:25:43.000Z</published>
    <updated>2017-06-04T12:54:20.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov" target="_blank" rel="external">A cartoon intro to Redux</a></p>
</blockquote>
<p><img src="/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png" alt="页面效果图"></p>
<p>//todo</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A c
    
    </summary>
    
      <category term="翻译" scheme="http://gaoquan.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="react" scheme="http://gaoquan.wang/tags/react/"/>
    
      <category term="Redux" scheme="http://gaoquan.wang/tags/Redux/"/>
    
  </entry>
  
</feed>
