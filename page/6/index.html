<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="GaoQ's blog" />





  <link rel="alternate" href="/atom.xml" title="GaoQ's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="There are no shortcuts to any place worth going">
<meta property="og:type" content="website">
<meta property="og:title" content="GaoQ&#39;s blog">
<meta property="og:url" content="http://gaoquan.wang/page/6/index.html">
<meta property="og:site_name" content="GaoQ&#39;s blog">
<meta property="og:description" content="There are no shortcuts to any place worth going">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GaoQ&#39;s blog">
<meta name="twitter:description" content="There are no shortcuts to any place worth going">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> GaoQ's blog - There are no shortcuts to any place worth going </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b902fa08b28044c55da6c70921955ecb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>


<a href="https://github.com/GaoQ1"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png"></a>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">GaoQ's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">There are no shortcuts to any place worth going</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/在Javascript中实现函数式编程的技术0/" itemprop="url">
                  在Javascript中实现函数式编程的技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T15:03:40+08:00" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/19/在Javascript中实现函数式编程的技术0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/19/在Javascript中实现函数式编程的技术0/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这章我们继续下面的内容：</p>
<ul>
<li>把所有的核心概念放到一个集中的范式里</li>
<li>探索函数式编程之美</li>
<li>一步步跟踪函数式模式相互交织的逻辑</li>
<li>我们将贯穿整章建立一个简单的应用做一些很酷的事情</li>
</ul>
<p>你可能已经注意到，在上一章我们介绍Javascript的函数式库的时候引入了一些概念， 而不是在第二章《函数式编程基础》里。呃，这是有原因的！组合、柯里化、不全调用…… 让我们来探索这些库为何以及如何实现这些概念。</p>
<p>函数式编程可以出现各种各样的模式，这章会覆盖很多不同风格的函数式编程：</p>
<ul>
<li>数据泛型编程</li>
<li>基本上函数式的编程</li>
<li>函数式响应式编程等</li>
</ul>
<p>然而这章将会避免偏向于任何风格。我们不会花费很大精力学完一个函数式编程风格再学另一个， 总的目标是展示写代码更好的方式，而不是被动接受唯一一个正确的选择。 如果你先人一步感觉到了什么是好的写代码的方法而什么不是，你就可以作任何想做的事情了。 当你像个孩子那样仅凭喜好放纵地写代码时，当你不关心如何去循规蹈矩的做事时，无限的可能就出现了。</p>
<h2 id="部分函数应用和珂理化"><a href="#部分函数应用和珂理化" class="headerlink" title="部分函数应用和珂理化"></a>部分函数应用和珂理化</h2><blockquote>
<p>许多语言支持可选参数，但是javascript不支持。javascript采用一种完全不同的模式，它允许任意数量的参数传给函数。这就是一些有趣且非同寻常的设计模式留下了门路。函数可以全部或部分应用。</p>
</blockquote>
<p>部分应用在javascript中的处理方式是：给函数一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。</p>
<p>这两者的差异现在看起来不是很明显，但最后会清楚的。</p>
<h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><p>在我们进一步解释如何实现部分应用和珂理化之前，我们需要进行一些回顾。如果我们想要扒掉javascript厚重的C风格语法外衣，暴露器函数是本质的话，我们需要理解原始函数、原型在javascript是如何工作的；而如果我们只是想设置一些cookie或验证一些表单的话则永远不用考虑这些。</p>
<h2 id="apply、call和this关键词"><a href="#apply、call和this关键词" class="headerlink" title="apply、call和this关键词"></a>apply、call和this关键词</h2><p>在纯函数式语言中，函数不会被唤起(invoke)，他们是被应用(apply)。javascript以同样的方式工作，甚至提供了手动调用(call)和应用(apply)函数的工具。这些都是与this关键词有关的，当然this指的是函数所属的那个对象。</p>
<p>call()函数把第一个参数作为this关键字。它是这样工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([<span class="string">'Hello'</span>,<span class="string">'world'</span>].join(<span class="string">' '</span>)); <span class="comment">//正常方式</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call([<span class="string">'Hello'</span>,<span class="string">'world'</span>],<span class="string">' '</span>)); <span class="comment">//使用call</span></div></pre></td></tr></table></figure>
<p>call()函数可以唤起匿名函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.length)&#125;).call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</div></pre></td></tr></table></figure>
<p>apply()函数和call()函数很像，但是更有用一些：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 返回3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 无法应用于数组</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 这样就可以了</span></div></pre></td></tr></table></figure>
<p>基本的区别是：call()函数接受一列参数，apply函数接受一个数组作为参数。</p>
<p>call()和apply()让你可以只写一次函数，其它对象可以继承它而无需再写一遍函数。 并且他俩都是Function对象的成员。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当你对call()自己调用call()的时候，会发生有趣的事情。</span></div><div class="line"><span class="comment">//这两行代码是等价的</span></div><div class="line">func.call(thisValue);</div><div class="line"><span class="built_in">Function</span>.prototype.call.call(func,thisValue);</div></pre></td></tr></table></figure></p>
<h2 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h2><p>bind()函数让你能够调用一个对象的函数时this指向另一个对象。这跟call()函数差不多，不过他可以让方法链式调用，返回一个新的函数。</p>
<p>这对于回调非常有用，就像下面的代码那样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Drum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.noise = <span class="string">'boom'</span>;</div><div class="line">  <span class="keyword">this</span>.duration = <span class="number">1000</span>;</div><div class="line">  <span class="keyword">this</span>.goBoom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.noise)</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> drum = <span class="keyword">new</span> Drum();</div><div class="line">setInterval(drum.goBoom.bind(drum), drum.duration);</div></pre></td></tr></table></figure>
<p>这解决了许多面向对象框架中的问题，比如Dojo，特别是对于那些有自己的handler函数的类处理状态维持的问题。 不过我们也可以用bind()来进行函数式编程。</p>
<p><code>bind()函数实际上自己实现了部分应用，尽管是通过一种很有限的方式。</code></p>
<h2 id="函数工厂"><a href="#函数工厂" class="headerlink" title="函数工厂"></a>函数工厂</h2><blockquote>
<p>还记得第二章《函数式编程基础》中关于闭包的那节吗？闭包使建立函数工厂这种Javascript编程模式成为可能。 它们使你能够手动绑定函数的参数。</p>
</blockquote>
<p>首先我们需要一个为另一个函数绑定参数的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindFirstArg</span>(<span class="params">func,a</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> func(a,b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以用它来创建更多的泛型函数(generic function)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> powersOfTwo = bindFirstArg(<span class="built_in">Math</span>.pow, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(powersOfTwo(<span class="number">3</span>)); <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(powersOfTwo(<span class="number">5</span>)); <span class="comment">// 32</span></div></pre></td></tr></table></figure>
<p>也可以针对于其它参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindSecondArg</span>(<span class="params">func, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> func(a, b);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> squareOf = bindSecondArg(<span class="built_in">Math</span>.pow, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> cubeOf = bindSecondArg(<span class="built_in">Math</span>.pow, <span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(squareOf(<span class="number">3</span>)); <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(squareOf(<span class="number">4</span>)); <span class="comment">// 16</span></div><div class="line"><span class="built_in">console</span>.log(cubeOf(<span class="number">3</span>)); <span class="comment">// 27</span></div><div class="line"><span class="built_in">console</span>.log(cubeOf(<span class="number">4</span>)); <span class="comment">// 64</span></div></pre></td></tr></table></figure>
<p>在函数式编程中，创建泛型函数的能力十分重要。然而还有更巧妙的方式可以更加一般化的完成这一过程。bindFirstArg()函数接受两个参数，第一个参数是这个函数。如果我们把bindFirstArg本身作为第一个参数的函数传给它自己，我们就可以创建绑定函数。最好用下面的例子来描述：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> makePowersOf = bindFirstArg(bindFirstArg, <span class="built_in">Math</span>.pow);</div><div class="line"><span class="keyword">var</span> powersOfThree = makePowersOf(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(powersOfThree(<span class="number">2</span>)); <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(powersOfThree(<span class="number">3</span>)); <span class="comment">// 27</span></div></pre></td></tr></table></figure>
<p>这就是为什么它被叫做函数工厂。</p>
<h2 id="部分应用"><a href="#部分应用" class="headerlink" title="部分应用"></a>部分应用</h2><p>注意我们函数工厂的例子里bindFirstArg()和bindSecondArg()函数只能有两个参数。我们可以写新的不同数量参数的函数，但是这就违背我们一般化的模型了。</p>
<p>我们需要部分应用</p>
<p>部分应用是这样一个过程：它给函数的一个或多个参数绑定上值，返回一个已经部分应用过的函数，这个函数仍然需要接收未绑定的参数。</p>
<p>与bind()函数等Function对象內建的方法不同，我们需要创建自己的函数来实现部分调用和柯里化。主要有两种方式：</p>
<ul>
<li>作为一个单独的函数，也就是，var partial = function(func){…}</li>
<li>作为补充，也就是，Function.prototype.partial = function(func){…}</li>
</ul>
<p>补充的方式视为原型增加新的函数，这会允许我们在为想要部分应用的函数调用我们的新函数的时候作为它的一个方法。就像这样：myfunction.partial(arg1,arg2,…)；</p>
<h3 id="左端部分应用"><a href="#左端部分应用" class="headerlink" title="左端部分应用"></a>左端部分应用</h3><p>这里Javascript的call()和apply()函数将对我们很有用。我们看看补充Function对象的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.partialApply = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> func = <span class="keyword">this</span>;</div><div class="line">  args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    func.apply(<span class="keyword">this</span>,args.concat(</div><div class="line">      <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div><div class="line">    ))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，它的工作方式是对arguments这个特殊的值调用slice</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">每个函数又有一个特殊的内部变量叫做arguments,它是一个类似于数组的对象，包含传入函数的全部参数。从技术层面说，她不是数组，因此他没有slice和forEach这些数组的方法。这儿就是为什么我们需要使用Array的slice.call方法。</div></pre></td></tr></table></figure>
<p>现在我们通过一个例子看看如何使用它。这次我们不做数学题，来搞点有用的东西。 我们来建立一个把数字转换为16进制的小应用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nums2hex</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">componentToHex</span>(<span class="params">component</span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> hex = component.toString(<span class="number">16</span>);</div><div class="line">      <span class="comment">//确保返回的数值是两位数字，比如0c或12</span></div><div class="line">      <span class="keyword">if</span>(hex.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span> + hex;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> hex;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.map.call(<span class="built_in">arguments</span>,componentToHex).join(<span class="string">''</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这个函数对多少个数字有效</span></div><div class="line">  <span class="built_in">console</span>.log(nums2hex()); <span class="comment">// ''</span></div><div class="line"><span class="built_in">console</span>.log(nums2hex(<span class="number">100</span>, <span class="number">200</span>)); <span class="comment">// '64c8'</span></div><div class="line"><span class="built_in">console</span>.log(nums2hex(<span class="number">100</span>, <span class="number">200</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">123</span>)); <span class="comment">// '64c8ff007b'</span></div><div class="line"><span class="comment">// 不过我们可以用部分函数来对部分参数进行应用，比如mac地址的OUI</span></div><div class="line"><span class="comment">// ( OUI，“组织唯一标识符”，即网卡制造商的唯一标识符。)</span></div><div class="line"><span class="keyword">var</span> myOUI = <span class="number">123</span>;</div><div class="line"><span class="keyword">var</span> getMacAddress = nums2hex.partialApply(myOUI);</div><div class="line"><span class="built_in">console</span>.log(getMacAddress()); <span class="comment">// '7b'</span></div><div class="line"><span class="built_in">console</span>.log(getMacAddress(<span class="number">100</span>, <span class="number">200</span>, <span class="number">2</span>, <span class="number">123</span>, <span class="number">66</span>, <span class="number">0</span>, <span class="number">1</span>));</div><div class="line"><span class="comment">// '7b64c8027b420001'</span></div><div class="line"><span class="comment">// 我们还可以转换全红基础上的颜色rgb十六进制值</span></div><div class="line"><span class="keyword">var</span> shadesOfRed = nums2hex.partialApply(<span class="number">255</span>);</div><div class="line"><span class="built_in">console</span>.log(shadesOfRed(<span class="number">123</span>, <span class="number">0</span>)); <span class="comment">// 'ff7b00'</span></div><div class="line"><span class="built_in">console</span>.log(shadesOfRed(<span class="number">100</span>, <span class="number">200</span>)); <span class="comment">// 'ff64c8'</span></div></pre></td></tr></table></figure>
<p>这个例子展示出了我们可以应用部分参数而生成一个新的函数。它是左-右的，意思是我们只能部分应用从左边开始的若干参数。</p>
<h3 id="右部分应用"><a href="#右部分应用" class="headerlink" title="右部分应用"></a>右部分应用</h3><p>为了从右边开始应用参数，我们可以再定义一个补充函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.partialApplyRight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> func = <span class="keyword">this</span>;</div><div class="line">args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> func.apply(</div><div class="line">    <span class="keyword">this</span>, [].slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)</div><div class="line">    .concat(args));</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> shadesOfBlue = nums2hex.partialApplyRight(<span class="number">255</span>);</div><div class="line"><span class="built_in">console</span>.log(shadesOfBlue(<span class="number">123</span>, <span class="number">0</span>));   <span class="comment">// '7b00ff'</span></div><div class="line"><span class="built_in">console</span>.log(shadesOfBlue(<span class="number">100</span>, <span class="number">200</span>)); <span class="comment">// '64c8ff'</span></div><div class="line"><span class="keyword">var</span> someShadesOfGreen = nums2hex.partialApplyRight(<span class="number">255</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(shadesOfGreen(<span class="number">123</span>));   <span class="comment">// '7bff00'</span></div><div class="line"><span class="built_in">console</span>.log(shadesOfGreen(<span class="number">100</span>));   <span class="comment">// '64ff00'</span></div></pre></td></tr></table></figure>
<p>部分应用使我们能够创建非常一般化的函数，并从它提取出更多特殊化的函数。 但是这个方法最大的缺点在于参数传入的方式，也就是参数有多少个，是什么样的顺序，这些不太明确。 不明确性在编程中永远不是个好事儿。还有个更好的方式：珂理化。</p>
<h2 id="柯里化-currying"><a href="#柯里化-currying" class="headerlink" title="柯里化(currying)"></a>柯里化(currying)</h2><p>柯里化是这样一个过程：他把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数剩余的参数。这是的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每个函数只有一个参数。</p>
<p>一个普遍的问题是：部分应用和柯里化的区别是什么？实际就是部分应用立刻返回一个值，而柯里化只返回另一个柯里化的函数来获取下一个参数，本质的区别是柯里化可以更好的控制参数传入的方式。</p>
<p>这里我们再为Function的原型补充一个柯里化的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.curry = <span class="function"><span class="keyword">function</span>(<span class="params">numArgs</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> func = <span class="keyword">this</span>;</div><div class="line">  numArgs = numArgs || func.length; <span class="comment">//func.length是调用此方法的函数的形参个数</span></div><div class="line">  <span class="comment">//递归地获取参数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subCurry</span>(<span class="params">prev</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(args.length &lt; numArgs)&#123;</div><div class="line">        <span class="comment">//递归情形：仍需要更多的参数</span></div><div class="line">        <span class="keyword">return</span> subCurry(args);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//基准情形：执行函数</span></div><div class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>,args);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> subCurry([]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>numArgs参数让我们可以在被珂理化的函数没有给出确切参数的时候指定参数的个数。</p>
<p>来看看用它如何处理我们的十六进制应用。我们先写个函数，它会把RGB值转化为适合HTML的16进制字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2hex</span>(<span class="params">r,g,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + nums2hex(r) + nums2hex(g) + nums2hex(b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> hexColors = rgb2hex.curry();</div><div class="line"><span class="built_in">console</span>.log(hexColors(<span class="number">11</span>)) <span class="comment">// 返回一个珂理化的函数</span></div><div class="line"><span class="built_in">console</span>.log(hexColors(<span class="number">11</span>, <span class="number">12</span>, <span class="number">123</span>)) <span class="comment">// 返回一个珂理化的函数</span></div><div class="line"><span class="built_in">console</span>.log(hexColors(<span class="number">11</span>)(<span class="number">12</span>)(<span class="number">123</span>)) <span class="comment">// 返回 #0b0c7b</span></div><div class="line"><span class="built_in">console</span>.log(hexColors(<span class="number">210</span>)(<span class="number">12</span>)(<span class="number">0</span>)) <span class="comment">// 返回 #d20c00</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，curry方法返回的函数只接受一个参数，所以上例倒数第三行传入的三个参数的后两个是没用的。</p>
</blockquote>
<p>这样使用柯里化不错。但是如果我们相对nums2hex()这个函数进行柯里化就会有点问题，因为这个函数没有指定参数，你可以传入任意数量的参数。所以我们需要定义参数的个数。我们curry函数的那个可选的参数来设置被柯里化函数的参数个数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hexs = nums2hex.curry(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(hexs(<span class="number">11</span>)(<span class="number">12</span>));     <span class="comment">// 返回 0b0c</span></div><div class="line"><span class="built_in">console</span>.log(hexs(<span class="number">11</span>));         <span class="comment">// 返回一个函数</span></div><div class="line"><span class="built_in">console</span>.log(hexs(<span class="number">110</span>)(<span class="number">12</span>)(<span class="number">0</span>)); <span class="comment">// 不正确</span></div></pre></td></tr></table></figure></p>
<p>所以柯里化不太适合可变参数的函数，对于这种情况，建议使用部分应用函数。<br>所有这些不只是利用函数工厂和代码重用，柯里化和部分应用在函数组合中扮演着更重要的角色。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/Javascript的函数式库/" itemprop="url">
                  Javascript的函数式库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T11:44:41+08:00" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/19/Javascript的函数式库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/19/Javascript的函数式库/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>A book that remains shut is but a block.</p>
</blockquote>
<h2 id="Javascript的函数式库"><a href="#Javascript的函数式库" class="headerlink" title="Javascript的函数式库"></a>Javascript的函数式库</h2><p>据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。</p>
<p>每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。</p>
<h3 id="Underscore-js"><a href="#Underscore-js" class="headerlink" title="Underscore.js"></a>Underscore.js</h3><p>Underscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。</p>
<p>与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = _.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="built_in">Math</span>.sqrt); <span class="comment">// Underscore的map函数</span></div><div class="line"><span class="built_in">console</span>.log(x.toString());</div></pre></td></tr></table></figure></p>
<p>我们已经见过Javascript数组原生的map()方法，它是这样用的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="built_in">Math</span>.sqrt);</div></pre></td></tr></table></figure></p>
<p>不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。</p>
<p>不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greetings = [&#123;</div><div class="line">  <span class="attr">origin</span>: <span class="string">'spanish'</span>,</div><div class="line">  <span class="attr">value</span>: <span class="string">'hola'</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">origin</span>: <span class="string">'english'</span>,</div><div class="line">  <span class="attr">value</span>: <span class="string">'hello'</span></div><div class="line">&#125;];</div><div class="line"><span class="built_in">console</span>.log(_.pluck(greetings, <span class="string">'value'</span>));</div><div class="line"><span class="comment">// 获取一个对象的属性.</span></div><div class="line"><span class="comment">// 返回: ['hola', 'hello']</span></div><div class="line"><span class="built_in">console</span>.log(_.find(greetings, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> s.origin ==</div><div class="line">    <span class="string">'spanish'</span>;</div><div class="line">&#125;));</div><div class="line"><span class="comment">// 查找第一个回调函数返回真的元素</span></div><div class="line"><span class="comment">// 返回: &#123;origin: 'spanish', value: 'hola'&#125;</span></div><div class="line">greetings = greetings.concat(_.object([<span class="string">'origin'</span>, <span class="string">'value'</span>], [<span class="string">'french'</span>, <span class="string">'bonjour'</span>]));</div><div class="line"><span class="built_in">console</span>.log(greetings);</div><div class="line"><span class="comment">// _.object通过合并两个数组来建立一个对象</span></div><div class="line"><span class="comment">// 返回: [&#123;origin: 'spanish', value: 'hola'&#125;,</span></div><div class="line"><span class="comment">//&#123;origin: 'english', value: 'hello'&#125;,</span></div><div class="line"><span class="comment">//&#123;origin: 'french', value: 'bonjour'&#125;]</span></div></pre></td></tr></table></figure></p>
<p>并且它还提供了链式调用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = _.chain(greetings)</div><div class="line">  .sortBy(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x.value.length</div><div class="line">  &#125;)</div><div class="line">  .pluck(<span class="string">'origin'</span>)</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x.charAt(<span class="number">0</span>).toUpperCase() + x.slice(<span class="number">1</span>)</div><div class="line">  &#125;)</div><div class="line">  .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="string">' '</span> + y</div><div class="line">  &#125;, <span class="string">''</span>)</div><div class="line">  .value(); <span class="comment">// 应用这些函数</span></div><div class="line"><span class="comment">// 返回: 'Spanish English French'</span></div><div class="line"><span class="built_in">console</span>.log(g);</div></pre></td></tr></table></figure></p>
<blockquote>
<p><em>.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。</em>.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。</p>
</blockquote>
<p>Underscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。</p>
<p>那么有没有更好的库呢？一个建立在数学之上的库？</p>
<h3 id="Lazy-js"><a href="#Lazy-js" class="headerlink" title="Lazy.js"></a>Lazy.js</h3><p>Lazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。</p>
<p>Lazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。</p>
<p>下面的例子展示了以下各种情形的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得一首歌歌词的前三行</span></div><div class="line"><span class="keyword">var</span> lyrics = <span class="string">"我徘徊在海之滨山之巅\n越此城镇越彼乡园\n ..."</span></div><div class="line"><span class="comment">//如果没有惰性，整个歌词会先根据换行来分隔</span></div><div class="line"><span class="built_in">console</span>.log(lyrics.split(<span class="string">'\n'</span>).slice(<span class="number">0</span>,<span class="number">3</span>));</div><div class="line"><span class="comment">//有了惰性，可以只文本分割出来前三行</span></div><div class="line"><span class="comment">//歌词甚至可以无限长</span></div><div class="line"><span class="built_in">console</span>.log(Lazy(lyrics).split(<span class="string">'\n'</span>).take(<span class="number">3</span>));</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前十个能被3整除的平方数</span></div><div class="line"> <span class="keyword">var</span> oneTo1000 = Lazy.range(<span class="number">1</span>,<span class="number">1000</span>).toArray();</div><div class="line"> <span class="keyword">var</span> sequence = Lazy(oneTo1000)</div><div class="line">     .map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;)</div><div class="line">     .filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x % <span class="number">3</span> === <span class="number">0</span>&#125;)</div><div class="line">     .take(<span class="number">10</span>)</div><div class="line">     .each(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对无限序列的异步循环</span></div><div class="line"><span class="keyword">var</span> asyncSequence = Lazy.generate(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x++</div><div class="line">&#125;).async(<span class="number">100</span>) <span class="comment">//每两个元素间隔0.1秒</span></div><div class="line">.take(<span class="number">20</span>) <span class="comment">//只计算前20项</span></div><div class="line">.each(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getMilliseconds() + <span class="string">": "</span> + e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。</p>
<h3 id="其他的一些库"><a href="#其他的一些库" class="headerlink" title="其他的一些库"></a>其他的一些库</h3><p>Javascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。</p>
<ul>
<li>Functional<ul>
<li>这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。</li>
</ul>
</li>
<li>wu.js<ul>
<li>因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。</li>
<li>是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”</li>
</ul>
</li>
<li>sloth.js<ul>
<li>和Lazy.js很像，但是更小</li>
</ul>
</li>
<li>stream.js<ul>
<li>支持无限流，其它没什么</li>
<li>特别小</li>
</ul>
</li>
<li>Lo-Dash.js<ul>
<li>就像名字所暗示的那样，它是受underscore.js的启发</li>
<li>高度优化</li>
</ul>
</li>
<li>Sugar<ul>
<li>Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。</li>
<li>underscore中的 _.pluck(myObjs, ‘value’)在Suger中仅仅是myObjs.map(‘value’)。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。</li>
</ul>
</li>
<li>from.js<ul>
<li>一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。</li>
<li>100%惰性求值，并支持lambda表达式</li>
<li>很年轻，但是文档很出色</li>
</ul>
</li>
<li>JSLINQ<ul>
<li>另一个Javascript的LINQ引擎</li>
<li>比from.js更老也更成熟</li>
</ul>
</li>
<li>Boiler.js<ul>
<li>另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组</li>
</ul>
</li>
<li>Folktale<ul>
<li>像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。</li>
</ul>
</li>
<li>jQuery<ul>
<li>在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。</li>
<li>jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： <code>$(&#39;#mydiv&#39;).fadeIn().css(&#39;left&#39;: 50).alert(&#39;hi!&#39;);</code> </li>
<li>它的一些函数是高阶的 <code>$(&#39;li&#39;).css(&#39;left&#39;: function(index){return index*50});</code> </li>
<li>jQuery1.8以上的deferred.then实现了函数式概念Promise</li>
<li>jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？</li>
</ul>
</li>
</ul>
<h2 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。</p>
<p>浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。</p>
<p>编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。</p>
<h3 id="服务器端Javascript"><a href="#服务器端Javascript" class="headerlink" title="服务器端Javascript"></a>服务器端Javascript</h3><p>Node.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。</p>
<p>这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。</p>
<h3 id="服务器端环境的一个函数式用例"><a href="#服务器端环境的一个函数式用例" class="headerlink" title="服务器端环境的一个函数式用例"></a>服务器端环境的一个函数式用例</h3><p>在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。</p>
<p>假设下面这个情景：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，并且保存了报告。<br> 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。<br> 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。</p>
<p>长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。</p>
<p>这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。</p>
<p>现在这个场景可以这样展开了：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。<br> 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。<br> 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。<br> 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。</p>
<p>这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。</p>
<p>这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。</p>
<h2 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h2><p>你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。</p>
<p>任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/函数式编程-月影/" itemprop="url">
                  函数式编程(月影)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T16:17:01+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/函数式编程-月影/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/函数式编程-月影/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？</p>
</blockquote>
<p><strong>纯函数</strong>指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。</p>
<p>纯函数对<em>设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。</em>在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。</p>
<p>不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。</p>
<p>纯函数和非纯函数的几个例子：</p>
<p>//纯函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x+ y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//纯函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">x, y</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> x - y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于系统时间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> data.now();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于作用域外的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inc</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">      <span class="keyword">return</span> ++idx;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于随机数生成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，操作改变 DOM<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItem</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  <span class="built_in">document</span>.body.appendChild(li);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？</p>
<h3 id="“不纯度”污染"><a href="#“不纯度”污染" class="headerlink" title="“不纯度”污染"></a>“不纯度”污染</h3><p>纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//setColor 不是纯函数，它改变外部环境(DOM)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">el,color</span>)</span>&#123;</div><div class="line">    el.style.color = color;</div><div class="line">    <span class="keyword">return</span> el;</div><div class="line">&#125;</div><div class="line"><span class="comment">//setColorEls显然也不纯，因为它依赖于setColor</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColorEls</span>(<span class="params">els,color</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> els.map(<span class="function">(<span class="params">el</span>) =&gt;</span> setColor(el,color));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。</p>
<p>设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。</p>
<p>上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。</p>
<p>有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。</p>
<h2 id="高阶函数的纯度"><a href="#高阶函数的纯度" class="headerlink" title="高阶函数的纯度"></a>高阶函数的纯度</h2><h3 id="函数可替代性与等价关系"><a href="#函数可替代性与等价关系" class="headerlink" title="函数可替代性与等价关系"></a>函数可替代性与等价关系</h3><p>对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？</p>
<p>对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两个纯函数 foo 和 bar 等价</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arr, obj</span>)</span>&#123;    </div><div class="line">  <span class="keyword">var</span> ret = arr.slice(<span class="number">0</span>);</div><div class="line">  ret.push(obj);    </div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">arr, obj</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> arr.concat([obj]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。</p>
<p>注意 JavaScript 函数纯度要考虑 this 上下文：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> point = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="comment">//这个函数其实是不纯的，因为它依赖了 this 上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointAdd</span>(<span class="params">x, y</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">&#125;</div><div class="line">point.add = pointAdd;</div><div class="line">point.add2 = pointAdd.bind(point);</div></pre></td></tr></table></figure></p>
<p>上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。</p>
<p>那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？</p>
<p>答案显然不是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="comment">//blablabla....</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...args</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。</p>
<p>到这一步，我们可以给出一个定义：</p>
<blockquote>
<p>定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。</p>
</blockquote>
<p>好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。</p>
<p>这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。</p>
<p>既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。</p>
<p>使用高阶纯函数</p>
<p>现在我们该回到前面 setColor 的例子了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicast</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">list,...rest</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(list))&#123;</div><div class="line">            <span class="keyword">return</span> list.map(<span class="function">(<span class="params">o</span>) =&gt;</span> fn.apply(<span class="keyword">this</span>,[o,...rest]));</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//setColor 不是纯函数，它改变外部环境（DOM）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">el, color</span>)</span>&#123;</div><div class="line">  el.style.color = color;    </div><div class="line">  <span class="keyword">return</span> el;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> setColorEls = multicast(setColor);</div><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">"li:nth-child(2n+1)"</span>);</div><div class="line">setColorEls(<span class="built_in">Array</span>.from(list), <span class="string">"red"</span>);</div></pre></td></tr></table></figure></p>
<p>上面的代码有几个好处：</p>
<ul>
<li>multicast 是纯函数，它简单灵活，对系统的影响很小。</li>
<li>multicast 对任意函数返回确定的函数，不影响外部环境和状态。</li>
<li>setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。</li>
<li>multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。</p>
<p>文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/函数式编程基础-转/" itemprop="url">
                  函数式编程基础(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T11:50:30+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/函数式编程基础-转/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/函数式编程基础-转/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在这章，会覆盖函数式编程的核心概念：</p>
<ul>
<li>使用函数和数组实现控制流</li>
<li>编写纯函数、匿名函数、递归函数等等</li>
<li>像对象那样传递函数</li>
<li>利用map()、filter()和reduce()函数</li>
</ul>
</blockquote>
<h2 id="char1-函数式编程语言"><a href="#char1-函数式编程语言" class="headerlink" title="char1.函数式编程语言"></a>char1.函数式编程语言</h2><p>函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。</p>
<h3 id="是什么让一个语言具有函数式特征？"><a href="#是什么让一个语言具有函数式特征？" class="headerlink" title="是什么让一个语言具有函数式特征？"></a>是什么让一个语言具有函数式特征？</h3><p>函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。</p>
<p>同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。</p>
<p>然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th style="text-align:center">命令式</th>
<th style="text-align:center">函数式</th>
</tr>
</thead>
<tbody>
<tr>
<td>编程风格</td>
<td style="text-align:center">一步一步地执行，并且要管理状态的变化</td>
<td style="text-align:center">描述问题和所需的数据变化已解决问题</td>
</tr>
<tr>
<td>状态变化</td>
<td style="text-align:center">很重要</td>
<td style="text-align:center">不存在</td>
</tr>
<tr>
<td>执行顺序</td>
<td style="text-align:center">很重要</td>
<td style="text-align:center">不太重要</td>
</tr>
<tr>
<td>主要的控制流</td>
<td style="text-align:center">循环、条件、函数调用</td>
<td style="text-align:center">函数调用和递归</td>
</tr>
<tr>
<td>主要的操作单元</td>
<td style="text-align:center">结构体和类对象</td>
<td style="text-align:center">函数作为一等公民的对象和数据集</td>
</tr>
</tbody>
</table>
<p>函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。</p>
<blockquote>
<p>注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。</p>
<p>不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。</p>
<p>总的来说，什么是使用函数式编程真正实际的优点呢？</p>
<h3 id="更加简洁的代码"><a href="#更加简洁的代码" class="headerlink" title="更加简洁的代码"></a>更加简洁的代码</h3><p>函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。</p>
<p>例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge2dArrayIntoOne</span>(<span class="params">arrays</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> count = arrays.length;</div><div class="line">    <span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Array</span>(count);</div><div class="line">    <span class="keyword">var</span> c = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>,jlen = array[i].length;j&lt;jlen;j++)&#123;</div><div class="line">            merged[c++] = arrays[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> merged;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在使用函数式技术，可以写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge2dArrayIntoOne = <span class="function"><span class="keyword">function</span>(<span class="params">arrays</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> arrays.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">p,n</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> p.concat(n);</div><div class="line"> &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。</p>
<h3 id="复用性"><a href="#复用性" class="headerlink" title="复用性"></a>复用性</h3><p>由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。</p>
<p>在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。</p>
<h3 id="减少耦合"><a href="#减少耦合" class="headerlink" title="减少耦合"></a>减少耦合</h3><p>耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。</p>
<h3 id="数学正确性"><a href="#数学正确性" class="headerlink" title="数学正确性"></a>数学正确性</h3><p>最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。</p>
<h3 id="非函数式世界中的函数式编程"><a href="#非函数式世界中的函数式编程" class="headerlink" title="非函数式世界中的函数式编程"></a>非函数式世界中的函数式编程</h3><p>函数式和非函数式编程能混合在一起吗？</p>
<p>这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。</p>
<p>例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = [];count = <span class="number">0</span>;</div><div class="line">text = myString.split(<span class="string">' '</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;count&lt;<span class="number">4</span>,i&lt;text.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!text[i].match(<span class="regexp">/[0-9]/</span>))&#123;</div><div class="line">        words = words.concat(text[i]);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数式编程会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = [];</div><div class="line"><span class="keyword">var</span> words = myString.split(<span class="string">' '</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (!x.match(<span class="regexp">/[0-9]/</span>));</div><div class="line">&#125;).slice(<span class="number">0</span>,<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(words);</div></pre></td></tr></table></figure>
<p>如果有一个函数式编程的工具库，代码可以进一步被简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = toSequence(myString).match(<span class="regexp">/[a-zA-Z]+/</span>).first(<span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的”words”和”count”变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。</p>
<h3 id="Javascript是函数式编程语言吗？"><a href="#Javascript是函数式编程语言吗？" class="headerlink" title="Javascript是函数式编程语言吗？"></a>Javascript是函数式编程语言吗？</h3><p>现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？</p>
<p>Javascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。</p>
<p>它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：</p>
<ul>
<li>Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。</li>
<li>Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。</li>
<li>Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。</li>
</ul>
<p>也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。</p>
<p>关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。</p>
<p>最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。</p>
<h2 id="char2-与函数共舞"><a href="#char2-与函数共舞" class="headerlink" title="char2.与函数共舞"></a>char2.与函数共舞</h2><blockquote>
<p>有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 –John Carmack，游戏《毁灭战士》首席程序员</p>
</blockquote>
<p>函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。</p>
<p>我们从Javascript的一个小尴尬开始。</p>
<p>假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">var</span> values = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulate</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    values.push(obj.value);</div><div class="line">&#125;</div><div class="line">accumulate(obj1);</div><div class="line">accumulate(obj2);</div><div class="line"><span class="built_in">console</span>.log(values); <span class="comment">//Output: [obj1.value,obj2.value]</span></div></pre></td></tr></table></figure>
<p>这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。</p>
<p>但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulate2</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    values.push(obj.value);</div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj1)); <span class="comment">// Returns: [obj1.value]</span></div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj2)); <span class="comment">// Returns: [obj2.value]</span></div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj3)); <span class="comment">// Returns: [obj3.value]</span></div></pre></td></tr></table></figure>
<p>只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ValueAccumulator = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    <span class="keyword">var</span> accumulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        value.push(obj.value);</div><div class="line">    &#125;;</div><div class="line">    accumulate();</div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。</p>
<p>我们需要的是一个自调用函数</p>
<h3 id="自调用函数和闭包"><a href="#自调用函数和闭包" class="headerlink" title="自调用函数和闭包"></a>自调用函数和闭包</h3><p>如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ValueAccumulator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    <span class="keyword">var</span> accumulate = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(obj)&#123;</div><div class="line">            values.push(obj.value);</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> accumulates;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//This allows us to do this</span></div><div class="line"><span class="keyword">var</span> accumulator = ValueAccumulator();</div><div class="line">accumulator(obj1);</div><div class="line">accumulator(obj2);</div><div class="line"><span class="built_in">console</span>.log(accumulator()); <span class="comment">//Output: [obj1.value,obj2.value]</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ValueAccumulator = -&gt;</div><div class="line"> values = []</div><div class="line"> (obj) -&gt;</div><div class="line"> values.push obj.value <span class="keyword">if</span> obj</div><div class="line"> values</div></pre></td></tr></table></figure>
<p>这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。</p>
<blockquote>
<p>Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。</p>
</blockquote>
<p>闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。</p>
<p>高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。</p>
<p>这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。</p>
<p>在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。</p>
<p>来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2</span></div><div class="line"><span class="keyword">var</span> accumulator2 = ValueAccumulator();</div><div class="line"><span class="keyword">var</span> objects = [obj1, obj2, obj3]; <span class="comment">// 这个数组可以很大</span></div><div class="line">objects.forEach(accumulator2);</div><div class="line"><span class="built_in">console</span>.log(accumulator2());</div></pre></td></tr></table></figure></p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。</p>
<p>用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。</p>
<p>纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。</p>
<p>举例说明来对比一下非纯函数和纯函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把信息打印到屏幕中央的函数</span></div><div class="line"><span class="keyword">var</span> printCenter = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = str;</div><div class="line">  elem.style.position = <span class="string">'absolute'</span>;</div><div class="line">  elem.style.top = <span class="built_in">window</span>.innerHeight / <span class="number">2</span> + <span class="string">"px"</span>;</div><div class="line">  elem.style.left = <span class="built_in">window</span>.innerWidth / <span class="number">2</span> + <span class="string">"px"</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(elem);</div><div class="line">&#125;;</div><div class="line">printCenter(<span class="string">'hello world'</span>);</div><div class="line"><span class="comment">// 纯函数完成相同的事情</span></div><div class="line"><span class="keyword">var</span> printSomewhere = <span class="function"><span class="keyword">function</span>(<span class="params">str, height, width</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = str;</div><div class="line">  elem.style.position = <span class="string">'absolute'</span>;</div><div class="line">  elem.style.top = height;</div><div class="line">  elem.style.left = width;</div><div class="line">  <span class="keyword">return</span> elem;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.appendChild(</div><div class="line">printSomewhere(<span class="string">'hello world'</span>,</div><div class="line"><span class="built_in">window</span>.innerHeight / <span class="number">2</span>) + <span class="number">10</span> + <span class="string">"px"</span>,</div><div class="line"><span class="built_in">window</span>.innerWidth / <span class="number">2</span>) + <span class="number">10</span> + <span class="string">"px"</span>));</div></pre></td></tr></table></figure></p>
<p>非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。</p>
<p>非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> messages = [<span class="string">'Hi'</span>, <span class="string">'Hello'</span>, <span class="string">'Sup'</span>, <span class="string">'Hey'</span>, <span class="string">'Hola'</span>];</div><div class="line">messages.map(<span class="function"><span class="keyword">function</span>(<span class="params">s,i</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> printSomewhere(s,<span class="number">100</span>*i*<span class="number">10</span>,<span class="number">100</span>*i*<span class="number">10</span>);</div><div class="line">&#125;).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。</p>
</blockquote>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>把函数作为头等对象的另一个好处就是匿名函数</p>
<p>就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。</p>
<p>下面是一些匿名函数的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写匿名函数的标准方式</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//匿名函数可以赋值给变量</span></div><div class="line"><span class="keyword">var</span> anon = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处</span></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</div><div class="line">&#125;,<span class="number">1000</span>);</div><div class="line"><span class="comment">//Output:  1413249010672, 1413249010673, 1413249010674, ...</span></div><div class="line"><span class="comment">//如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数</span></div><div class="line">setInterval(<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()),<span class="number">1000</span>)</div><div class="line"><span class="comment">//Output:  1413249010671</span></div></pre></td></tr></table></figure></p>
<p>下面是匿名函数和高阶函数配合使用的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">powersOf</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</div><div class="line">        <span class="comment">//this is an anonymous function!</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,y);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">powerOfTwo = powersOf(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">1</span>)); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">2</span>)); <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">3</span>)); <span class="comment">// 8</span></div><div class="line">powerOfThree = powersOf(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(powerOfThree(<span class="number">3</span>)); <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(powerOfThree(<span class="number">10</span>)); <span class="comment">// 59049</span></div></pre></td></tr></table></figure></p>
<p>这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。</p>
<p>还记得累加器的那个函数吗？它可以用匿名函数重写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">var</span> values = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="comment">//匿名函数</span></div><div class="line"> <span class="keyword">var</span> values = [];</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">     <span class="comment">//有一个匿名函数！</span></div><div class="line">     <span class="keyword">if</span>(obj)&#123;</div><div class="line">         values.push(obj.value);</div><div class="line">         <span class="keyword">return</span> values;</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="keyword">return</span> values;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">&#125;)(); <span class="comment">//让它自执行</span></div><div class="line"><span class="built_in">console</span>.log(values(obj1)); <span class="comment">// Returns: [obj.value]</span></div><div class="line"><span class="built_in">console</span>.log(values(obj2)); <span class="comment">// Returns: [obj.value, obj2.value]</span></div></pre></td></tr></table></figure></p>
<p>真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){…})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。</p>
<blockquote>
<p>匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。</p>
</blockquote>
<p>匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。</p>
<h3 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h3><p>在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。</p>
<p>这种技术用于简化多个函数一次应用于一个对象的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每个函数占用一行来调用，不如……</span></div><div class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">arr1 = arr.reverse();</div><div class="line">arr2 = arr1.concat([<span class="number">5</span>, <span class="number">6</span>]);</div><div class="line">arr3 = arr2.map(<span class="built_in">Math</span>.sqrt);</div><div class="line"><span class="comment">// ……把它们串到一起放在一行里面</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reverse().concat([<span class="number">5</span>, <span class="number">6</span>]).map(<span class="built_in">Math</span>.sqrt));</div><div class="line"><span class="comment">// 括号也许可以说明是怎么回事</span></div><div class="line"><span class="built_in">console</span>.log(((([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).reverse()).concat([<span class="number">5</span>, <span class="number">6</span>])).map(<span class="built_in">Math</span>.sqrt));</div></pre></td></tr></table></figure></p>
<p>这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.zip = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们就可以写成下面的样子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> n*<span class="number">2</span>;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归应该是最著名的函数式编程技术。就是一个函数调用它自己。</p>
<p>当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。</p>
<p>使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。</p>
<p>下面有个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> foo(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">5</span>));</div></pre></td></tr></table></figure></p>
<p>递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。</p>
<p>一个明显的例子就是遍历树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getLeafs = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="comment">//base case</span></div><div class="line">    <span class="keyword">return</span> node.innerText;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//recursive case</span></div><div class="line">    <span class="keyword">return</span> node.childNodes.map(getLeafs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。</p>
<p>历史上有个欧几里得算法用于找出两个数的最大公分母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(b === <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//基准情形</span></div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> gcd(b,a%b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(gcd(<span class="number">12</span>,<span class="number">8</span>));</div></pre></td></tr></table></figure></p>
<p>理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。</p>
<p>全部的实现代码大概要40行，这里只是展示伪代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>)&#123;</div><div class="line">        <span class="comment">//基准情形：只有0或1个元素的数组是不用排序的</span></div><div class="line">        <span class="keyword">return</span> items;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//递归情形：把数组拆分、排序、合并</span></div><div class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">        <span class="comment">// 分</span></div><div class="line">        <span class="keyword">var</span> left = mergeSort(arr.slice(<span class="number">0</span>, middle));</div><div class="line">        <span class="keyword">var</span> right = mergeSort(arr.slice(middle));</div><div class="line">        <span class="comment">// 治</span></div><div class="line">        <span class="comment">// merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起</span></div><div class="line">        <span class="keyword">return</span> merge(left, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。</p>
<p>这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理想化的JavaScript伪代码:</span></div><div class="line"><span class="keyword">var</span> infinateNums = range(<span class="number">1</span> to infinity);</div><div class="line"><span class="keyword">var</span> tenPrimes = infinateNums.getPrimeNumbers().first(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。</p>
<p>然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。</p>
<h2 id="char3-函数式程序员的工具集"><a href="#char3-函数式程序员的工具集" class="headerlink" title="char3.函数式程序员的工具集"></a>char3.函数式程序员的工具集</h2><p>如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。</p>
<p>map()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。</p>
<p>然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">newArray = myArray.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x*<span class="number">2</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(myArray);  <span class="comment">// Output: [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// Output: [2,4,6,8]</span></div></pre></td></tr></table></figure>
<p>还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。</p>
<p>回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x + <span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(myArray.map(myCallback));</div></pre></td></tr></table></figure></p>
<p>对于比较简单的任务可以用匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myArray.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>&#125;))</div></pre></td></tr></table></figure></p>
<p>回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">xhr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(xht.status);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">$.ajax(myUrl).done(myCallback);</div></pre></td></tr></table></figure></p>
<p>注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.ajax(myURI).fail(myCallback(xhr)); </div><div class="line"><span class="comment">// 或者</span></div><div class="line">$.ajax(myURI).fail(myCallback());</div></pre></td></tr></table></figure></p>
<p>如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个”true”，然后就报错了。</p>
<p>也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(status);</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">$.ajax(myURI).done(<span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</div><div class="line">  myCallback(xhr.status)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><p>map()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.map(callback[,thisArg]);</div></pre></td></tr></table></figure></p>
<ul>
<li>callback():这个函数为新数组产生一个元素，它接受的参数：<ul>
<li>currentValue: 数组当前遍历到的元素</li>
<li>index: 数组中当前元素序数</li>
<li>array: 当前正在处理的数组</li>
</ul>
</li>
<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">  integers = [<span class="number">1</span>, <span class="number">-0</span>, <span class="number">9</span>, <span class="number">-8</span>, <span class="number">3</span>],</div><div class="line">  numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</div><div class="line">  str = <span class="string">'hello world how ya doing?'</span>;</div><div class="line"> <span class="comment">//将整数映射为他们自己知道的绝对值</span></div><div class="line"> <span class="built_in">console</span>.log(integers.map(<span class="built_in">Math</span>.abs));</div><div class="line"> <span class="comment">//将数组中的元素与自己的位置序数相乘</span></div><div class="line"> <span class="built_in">console</span>.log(numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x,i</span>)</span>&#123;<span class="keyword">return</span> x*i&#125;));</div><div class="line"> <span class="comment">//单词隔一个变一个大写</span></div><div class="line"> <span class="built_in">console</span>.log(str.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">s,i</span>)</span>&#123;</div><div class="line">     <span class="keyword">if</span>(i%<span class="number">2</span> === <span class="number">0</span>)&#123;</div><div class="line">         <span class="keyword">return</span> s.toUpperCase();</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="keyword">return</span> s;</div><div class="line">     &#125;</div><div class="line"> &#125;))</div></pre></td></tr></table></figure></p>
<blockquote>
<p>尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。<br>MyObject.prototype.map = function(f) {<br> return new MyObject(f(this.value));<br>};</p>
</blockquote>
<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><p>filter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.filter(callback[,thisArg]);</div></pre></td></tr></table></figure></p>
<ul>
<li>callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：<ul>
<li>currentValue: 数组当前遍历到的元素</li>
<li>index: 数组中当前元素的序数</li>
<li>array: 当前正在处理的数组</li>
</ul>
</li>
<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myarray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">words = <span class="string">'hello 123 world how 345 ya doing'</span>.split(<span class="string">' '</span>);</div><div class="line">re = <span class="string">'[a-zA-Z]'</span>;</div><div class="line"><span class="comment">// 筛选整数</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">// 筛选所有含字母的单词</span></div><div class="line"><span class="built_in">console</span>.log(words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> s.match(re);</div><div class="line">&#125;));</div><div class="line"><span class="comment">// 随机移除数组中的元素</span></div><div class="line"><span class="built_in">console</span>.log(myarray.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">2</span>)</div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h3><p>reduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.reduce(callback[,initialValue]);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：<ul>
<li>previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）</li>
<li>currentValue：数组当前正在处理的元素</li>
<li>index：数组中当前元素的序数</li>
<li>array：当前正在处理的数组</li>
</ul>
</li>
<li>initialValue：可选。第一次回调所传入参数的初始值</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// 把数组中所有的值加起来</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;, <span class="number">0</span>));</div><div class="line"><span class="comment">// 查找数组中最大的值</span></div><div class="line"><span class="built_in">console</span>.log(numbers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(a, b) <span class="comment">// max()函数只能有两个参数</span></div><div class="line">  &#125;) </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><p>forEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.forEach(callback[,initialValue]);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>callback()：对数组中每一个元素所应用的。参数有：<ul>
<li>currentValue：数组当前正在处理的元素</li>
<li>index：数组中当前元素的序数</li>
<li>array：当前正在处理的数组</li>
</ul>
</li>
<li>thisArg：可选。回调函数中作为this的值</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> nodes = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = x;</div><div class="line">  <span class="keyword">return</span> elem;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 对每一个元素的值输出日志</span></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 把节点追加到DOM上</span></div><div class="line">nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(x)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><p>如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]) <span class="comment">// 拼接两个数组</span></div><div class="line"><span class="comment">// Output: [1, 2, 3, 'a','b','c']</span></div></pre></td></tr></table></figure></p>
<p>它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</div><div class="line"><span class="keyword">var</span> x = arr1.concat(arr2, arr3);</div><div class="line"><span class="keyword">var</span> y = arr1.concat(arr2).concat(arr3));</div><div class="line"><span class="keyword">var</span> z = arr1.concat(arr2.concat(arr3)));</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="built_in">console</span>.log(y);</div><div class="line"><span class="built_in">console</span>.log(z);</div></pre></td></tr></table></figure>
<h3 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse()"></a>Array.prototype.reverse()</h3><p>这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。</p>
<p>然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invert = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x, i, a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length - (i + <span class="number">1</span>)];</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> q = invert([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</div><div class="line"><span class="built_in">console</span>.log(q);</div></pre></td></tr></table></figure>
<h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h3><p>与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = [<span class="number">200</span>, <span class="number">12</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">344</span>];</div><div class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a–b&#125;) );</div><div class="line"><span class="comment">// arr现在是: [7, 12, 56, 200, 344];</span></div></pre></td></tr></table></figure>
<p>我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等</p>
<h3 id="Array-prototype-every-amp-amp-Array-prototype-some"><a href="#Array-prototype-every-amp-amp-Array-prototype-some" class="headerlink" title="Array.prototype.every() &amp;&amp; Array.prototype.some()"></a>Array.prototype.every() &amp;&amp; Array.prototype.some()</h3><p>Array.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].every(isNumber)); <span class="comment">// Return: true</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>].every(isNumber)); <span class="comment">// Return: false</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>].some(isNumber)); <span class="comment">// Return: true</span></div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/JS函数式编程的力量-转/" itemprop="url">
                  JS函数式编程的力量(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T09:29:02+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/JS函数式编程的力量-转/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/JS函数式编程的力量-转/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。</p>
</blockquote>
<h2 id="Javascript函数式编程的力量"><a href="#Javascript函数式编程的力量" class="headerlink" title="Javascript函数式编程的力量"></a>Javascript函数式编程的力量</h2><p>几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。</p>
<p>你是说Javascript？这个WEB脚本语言？没错！</p>
<p>Javascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。</p>
<p>为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。</p>
<p>在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。</p>
<p>不过在我们开始前，先来做个实验。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。</p>
<h3 id="应用–一个电子商务网站"><a href="#应用–一个电子商务网站" class="headerlink" title="应用–一个电子商务网站"></a>应用–一个电子商务网站</h3><p>为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。</p>
<h3 id="命令式方法"><a href="#命令式方法" class="headerlink" title="命令式方法"></a>命令式方法</h3><p>首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//create some objects to store the data</span></div><div class="line"><span class="keyword">var</span> columbian = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'columbian'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> frenchRoast = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'french Roast'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">8</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> decaf = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'decaf'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">6</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//我们将使用辅助函数计算价格</span></div><div class="line"><span class="comment">//根据size打印到一个HTML的列表中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPrice</span>(<span class="params">coffee,size</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(size == <span class="string">'small'</span>)&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">2</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="string">'medium'</span>)&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">4</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//create the new html list item</span></div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">var</span> label = coffee.name + <span class="string">' '</span> + size;</div><div class="line">    <span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(label+ <span class="string">'price: $'</span>+ price);</div><div class="line">    node.appendChild(textnode);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'products'</span>).appendChild(node);</div><div class="line">&#125;</div><div class="line"><span class="comment">//现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数</span></div><div class="line">printPrice(columbian, <span class="string">'small'</span>);</div><div class="line">printPrice(columbian, <span class="string">'medium'</span>);</div><div class="line">printPrice(columbian, <span class="string">'large'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'small'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'medium'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'large'</span>);</div><div class="line">printPrice(decaf, <span class="string">'small'</span>);</div><div class="line">printPrice(decaf, <span class="string">'medium'</span>);</div><div class="line">printPrice(decaf, <span class="string">'large'</span>);</div></pre></td></tr></table></figure></p>
<p>如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！</p>
<p>采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。<br>通过更函数式一些的方法，同样的应用可以这样来写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从接口中分解数据和逻辑</span></div><div class="line"><span class="keyword">var</span> printPrice = <span class="function"><span class="keyword">function</span>(<span class="params">price,label</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(label+ <span class="string">' price: $'</span>+ price);</div><div class="line">    node.appendChild(textnode);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'products2'</span>).appendChild(node);</div><div class="line">&#125;</div><div class="line"><span class="comment">//为每种咖啡创建函数对象</span></div><div class="line"><span class="keyword">var</span> columbian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'colimbian'</span>;</div><div class="line">    <span class="keyword">this</span>.basePrice = <span class="number">5</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> frenchRoast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.name = <span class="string">'french roast'</span>;</div><div class="line"> <span class="keyword">this</span>.basePrice = <span class="number">8</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> decaf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.name = <span class="string">'decaf'</span>;</div><div class="line"> <span class="keyword">this</span>.basePrice = <span class="number">6</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//为每种size通过字面量创建对象</span></div><div class="line"><span class="keyword">var</span> small = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">2</span>&#125;,</div><div class="line">    <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' small'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> medium = &#123;</div><div class="line">  <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">4</span>&#125;,</div><div class="line">  <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' medium'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> large = &#123;</div><div class="line">  <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">6</span>&#125;,</div><div class="line">  <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' large'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//将所有咖啡的种类和size放到数组里</span></div><div class="line"><span class="keyword">var</span> coffeeTypes = [columbian, frenchRoast, decaf];</div><div class="line"><span class="keyword">var</span> coffeeSizes = [small, medium, large];</div><div class="line"><span class="comment">//创建由上面内容组成的新对象，并把它们放到一个新数组里</span></div><div class="line"><span class="keyword">var</span> coffee = coffeeTypes.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous,current</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newCoffee = coffeeSizes.map(<span class="function"><span class="keyword">function</span>(<span class="params">mixin</span>)</span>&#123;</div><div class="line">        <span class="comment">//`plusmix`是函数时的mixin</span></div><div class="line">        <span class="keyword">var</span> newCoffeeObj = plusMixin(current,mixin);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> newCoffeeObj();</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> previous.concat(newCoffee);</div><div class="line">&#125;,[]);</div><div class="line"><span class="comment">//现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了</span></div><div class="line">coffee.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">coffee</span>)</span>&#123;</div><div class="line">    printPrice(coffee.getPrice(),coffee.getLabel());</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peruvian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'peruvian'</span>;</div><div class="line">    <span class="keyword">this</span>.basePrice = <span class="number">11</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> extraLarge = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">10</span>&#125;,</div><div class="line">    <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' extra large'</span>&#125;</div><div class="line">&#125;;</div><div class="line">coffeeTypes.push(peruvian);</div><div class="line">coffeeSizes.push(extraLarge);</div></pre></td></tr></table></figure></p>
<p>咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块–通过一个叫”plusMixin”的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。</p>
<p>实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">coffeeTypes.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous,current</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newCoffee = coffeeSizes.map(<span class="function"><span class="keyword">function</span>(<span class="params">mixin</span>)</span>&#123;</div><div class="line">        <span class="comment">//`plusMixin`</span></div><div class="line">        <span class="keyword">var</span> newCoffeeObj = plusMixin(current,mixin);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> newCoffeeObj();</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> previous.concat(newCoffee);</div><div class="line">&#125;.[]).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">coffee</span>)</span>&#123;</div><div class="line">    printPrice(coffee.getPrice(),coffee.getLabel());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="GaoQ" />
          <p class="site-author-name" itemprop="name">GaoQ</p>
          <p class="site-description motion-element" itemprop="description">There are no shortcuts to any place worth going</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GaoQ</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gaoquan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
