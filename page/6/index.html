<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="GaoQ's blog" />





  <link rel="alternate" href="/atom.xml" title="GaoQ's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="There are no shortcuts to any place worth going">
<meta property="og:type" content="website">
<meta property="og:title" content="GaoQ&#39;s blog">
<meta property="og:url" content="http://gaoquan.wang/page/6/index.html">
<meta property="og:site_name" content="GaoQ&#39;s blog">
<meta property="og:description" content="There are no shortcuts to any place worth going">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GaoQ&#39;s blog">
<meta name="twitter:description" content="There are no shortcuts to any place worth going">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> GaoQ's blog - There are no shortcuts to any place worth going </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b902fa08b28044c55da6c70921955ecb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>


<a href="https://github.com/GaoQ1"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png"></a>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">GaoQ's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">There are no shortcuts to any place worth going</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/Javascript的函数式库/" itemprop="url">
                  Javascript的函数式库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T11:44:41+08:00" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/19/Javascript的函数式库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/19/Javascript的函数式库/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>A book that remains shut is but a block.</p>
</blockquote>
<h2 id="Javascript的函数式库"><a href="#Javascript的函数式库" class="headerlink" title="Javascript的函数式库"></a>Javascript的函数式库</h2><p>据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。</p>
<p>每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。</p>
<h3 id="Underscore-js"><a href="#Underscore-js" class="headerlink" title="Underscore.js"></a>Underscore.js</h3><p>Underscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。</p>
<p>与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = _.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="built_in">Math</span>.sqrt); <span class="comment">// Underscore的map函数</span></div><div class="line"><span class="built_in">console</span>.log(x.toString());</div></pre></td></tr></table></figure></p>
<p>我们已经见过Javascript数组原生的map()方法，它是这样用的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="built_in">Math</span>.sqrt);</div></pre></td></tr></table></figure></p>
<p>不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。</p>
<p>不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greetings = [&#123;</div><div class="line">  <span class="attr">origin</span>: <span class="string">'spanish'</span>,</div><div class="line">  <span class="attr">value</span>: <span class="string">'hola'</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">origin</span>: <span class="string">'english'</span>,</div><div class="line">  <span class="attr">value</span>: <span class="string">'hello'</span></div><div class="line">&#125;];</div><div class="line"><span class="built_in">console</span>.log(_.pluck(greetings, <span class="string">'value'</span>));</div><div class="line"><span class="comment">// 获取一个对象的属性.</span></div><div class="line"><span class="comment">// 返回: ['hola', 'hello']</span></div><div class="line"><span class="built_in">console</span>.log(_.find(greetings, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> s.origin ==</div><div class="line">    <span class="string">'spanish'</span>;</div><div class="line">&#125;));</div><div class="line"><span class="comment">// 查找第一个回调函数返回真的元素</span></div><div class="line"><span class="comment">// 返回: &#123;origin: 'spanish', value: 'hola'&#125;</span></div><div class="line">greetings = greetings.concat(_.object([<span class="string">'origin'</span>, <span class="string">'value'</span>], [<span class="string">'french'</span>, <span class="string">'bonjour'</span>]));</div><div class="line"><span class="built_in">console</span>.log(greetings);</div><div class="line"><span class="comment">// _.object通过合并两个数组来建立一个对象</span></div><div class="line"><span class="comment">// 返回: [&#123;origin: 'spanish', value: 'hola'&#125;,</span></div><div class="line"><span class="comment">//&#123;origin: 'english', value: 'hello'&#125;,</span></div><div class="line"><span class="comment">//&#123;origin: 'french', value: 'bonjour'&#125;]</span></div></pre></td></tr></table></figure></p>
<p>并且它还提供了链式调用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = _.chain(greetings)</div><div class="line">  .sortBy(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x.value.length</div><div class="line">  &#125;)</div><div class="line">  .pluck(<span class="string">'origin'</span>)</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x.charAt(<span class="number">0</span>).toUpperCase() + x.slice(<span class="number">1</span>)</div><div class="line">  &#125;)</div><div class="line">  .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="string">' '</span> + y</div><div class="line">  &#125;, <span class="string">''</span>)</div><div class="line">  .value(); <span class="comment">// 应用这些函数</span></div><div class="line"><span class="comment">// 返回: 'Spanish English French'</span></div><div class="line"><span class="built_in">console</span>.log(g);</div></pre></td></tr></table></figure></p>
<blockquote>
<p><em>.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。</em>.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。</p>
</blockquote>
<p>Underscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。</p>
<p>那么有没有更好的库呢？一个建立在数学之上的库？</p>
<h3 id="Lazy-js"><a href="#Lazy-js" class="headerlink" title="Lazy.js"></a>Lazy.js</h3><p>Lazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。</p>
<p>Lazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。</p>
<p>下面的例子展示了以下各种情形的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得一首歌歌词的前三行</span></div><div class="line"><span class="keyword">var</span> lyrics = <span class="string">"我徘徊在海之滨山之巅\n越此城镇越彼乡园\n ..."</span></div><div class="line"><span class="comment">//如果没有惰性，整个歌词会先根据换行来分隔</span></div><div class="line"><span class="built_in">console</span>.log(lyrics.split(<span class="string">'\n'</span>).slice(<span class="number">0</span>,<span class="number">3</span>));</div><div class="line"><span class="comment">//有了惰性，可以只文本分割出来前三行</span></div><div class="line"><span class="comment">//歌词甚至可以无限长</span></div><div class="line"><span class="built_in">console</span>.log(Lazy(lyrics).split(<span class="string">'\n'</span>).take(<span class="number">3</span>));</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前十个能被3整除的平方数</span></div><div class="line"> <span class="keyword">var</span> oneTo1000 = Lazy.range(<span class="number">1</span>,<span class="number">1000</span>).toArray();</div><div class="line"> <span class="keyword">var</span> sequence = Lazy(oneTo1000)</div><div class="line">     .map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;)</div><div class="line">     .filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x % <span class="number">3</span> === <span class="number">0</span>&#125;)</div><div class="line">     .take(<span class="number">10</span>)</div><div class="line">     .each(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对无限序列的异步循环</span></div><div class="line"><span class="keyword">var</span> asyncSequence = Lazy.generate(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x++</div><div class="line">&#125;).async(<span class="number">100</span>) <span class="comment">//每两个元素间隔0.1秒</span></div><div class="line">.take(<span class="number">20</span>) <span class="comment">//只计算前20项</span></div><div class="line">.each(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getMilliseconds() + <span class="string">": "</span> + e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。</p>
<h3 id="其他的一些库"><a href="#其他的一些库" class="headerlink" title="其他的一些库"></a>其他的一些库</h3><p>Javascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。</p>
<ul>
<li>Functional<ul>
<li>这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。</li>
</ul>
</li>
<li>wu.js<ul>
<li>因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。</li>
<li>是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”</li>
</ul>
</li>
<li>sloth.js<ul>
<li>和Lazy.js很像，但是更小</li>
</ul>
</li>
<li>stream.js<ul>
<li>支持无限流，其它没什么</li>
<li>特别小</li>
</ul>
</li>
<li>Lo-Dash.js<ul>
<li>就像名字所暗示的那样，它是受underscore.js的启发</li>
<li>高度优化</li>
</ul>
</li>
<li>Sugar<ul>
<li>Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。</li>
<li>underscore中的 _.pluck(myObjs, ‘value’)在Suger中仅仅是myObjs.map(‘value’)。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。</li>
</ul>
</li>
<li>from.js<ul>
<li>一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。</li>
<li>100%惰性求值，并支持lambda表达式</li>
<li>很年轻，但是文档很出色</li>
</ul>
</li>
<li>JSLINQ<ul>
<li>另一个Javascript的LINQ引擎</li>
<li>比from.js更老也更成熟</li>
</ul>
</li>
<li>Boiler.js<ul>
<li>另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组</li>
</ul>
</li>
<li>Folktale<ul>
<li>像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。</li>
</ul>
</li>
<li>jQuery<ul>
<li>在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。</li>
<li>jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： <code>$(&#39;#mydiv&#39;).fadeIn().css(&#39;left&#39;: 50).alert(&#39;hi!&#39;);</code> </li>
<li>它的一些函数是高阶的 <code>$(&#39;li&#39;).css(&#39;left&#39;: function(index){return index*50});</code> </li>
<li>jQuery1.8以上的deferred.then实现了函数式概念Promise</li>
<li>jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？</li>
</ul>
</li>
</ul>
<h2 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。</p>
<p>浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。</p>
<p>编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。</p>
<h3 id="服务器端Javascript"><a href="#服务器端Javascript" class="headerlink" title="服务器端Javascript"></a>服务器端Javascript</h3><p>Node.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。</p>
<p>这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。</p>
<h3 id="服务器端环境的一个函数式用例"><a href="#服务器端环境的一个函数式用例" class="headerlink" title="服务器端环境的一个函数式用例"></a>服务器端环境的一个函数式用例</h3><p>在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。</p>
<p>假设下面这个情景：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，并且保存了报告。<br> 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。<br> 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。</p>
<p>长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。</p>
<p>这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。</p>
<p>现在这个场景可以这样展开了：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。<br> 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。<br> 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。<br> 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。</p>
<p>这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。</p>
<p>这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。</p>
<h2 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h2><p>你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。</p>
<p>任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/函数式编程-月影/" itemprop="url">
                  函数式编程(月影)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T16:17:01+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/函数式编程-月影/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/函数式编程-月影/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？</p>
</blockquote>
<p><strong>纯函数</strong>指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。</p>
<p>纯函数对<em>设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。</em>在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。</p>
<p>不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。</p>
<p>纯函数和非纯函数的几个例子：</p>
<p>//纯函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x+ y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//纯函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">x, y</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> x - y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于系统时间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> data.now();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于作用域外的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inc</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">      <span class="keyword">return</span> ++idx;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，依赖于随机数生成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//非纯函数，操作改变 DOM<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItem</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  <span class="built_in">document</span>.body.appendChild(li);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？</p>
<h3 id="“不纯度”污染"><a href="#“不纯度”污染" class="headerlink" title="“不纯度”污染"></a>“不纯度”污染</h3><p>纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//setColor 不是纯函数，它改变外部环境(DOM)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">el,color</span>)</span>&#123;</div><div class="line">    el.style.color = color;</div><div class="line">    <span class="keyword">return</span> el;</div><div class="line">&#125;</div><div class="line"><span class="comment">//setColorEls显然也不纯，因为它依赖于setColor</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColorEls</span>(<span class="params">els,color</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> els.map(<span class="function">(<span class="params">el</span>) =&gt;</span> setColor(el,color));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。</p>
<p>设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。</p>
<p>上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。</p>
<p>有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。</p>
<h2 id="高阶函数的纯度"><a href="#高阶函数的纯度" class="headerlink" title="高阶函数的纯度"></a>高阶函数的纯度</h2><h3 id="函数可替代性与等价关系"><a href="#函数可替代性与等价关系" class="headerlink" title="函数可替代性与等价关系"></a>函数可替代性与等价关系</h3><p>对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？</p>
<p>对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两个纯函数 foo 和 bar 等价</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arr, obj</span>)</span>&#123;    </div><div class="line">  <span class="keyword">var</span> ret = arr.slice(<span class="number">0</span>);</div><div class="line">  ret.push(obj);    </div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">arr, obj</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> arr.concat([obj]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。</p>
<p>注意 JavaScript 函数纯度要考虑 this 上下文：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> point = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="comment">//这个函数其实是不纯的，因为它依赖了 this 上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointAdd</span>(<span class="params">x, y</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">&#125;</div><div class="line">point.add = pointAdd;</div><div class="line">point.add2 = pointAdd.bind(point);</div></pre></td></tr></table></figure></p>
<p>上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。</p>
<p>那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？</p>
<p>答案显然不是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">  <span class="comment">//blablabla....</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...args</span>)</span>&#123;    </div><div class="line">  <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。</p>
<p>到这一步，我们可以给出一个定义：</p>
<blockquote>
<p>定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。</p>
</blockquote>
<p>好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。</p>
<p>这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。</p>
<p>既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。</p>
<p>使用高阶纯函数</p>
<p>现在我们该回到前面 setColor 的例子了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicast</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">list,...rest</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(list))&#123;</div><div class="line">            <span class="keyword">return</span> list.map(<span class="function">(<span class="params">o</span>) =&gt;</span> fn.apply(<span class="keyword">this</span>,[o,...rest]));</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//setColor 不是纯函数，它改变外部环境（DOM）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">el, color</span>)</span>&#123;</div><div class="line">  el.style.color = color;    </div><div class="line">  <span class="keyword">return</span> el;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> setColorEls = multicast(setColor);</div><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">"li:nth-child(2n+1)"</span>);</div><div class="line">setColorEls(<span class="built_in">Array</span>.from(list), <span class="string">"red"</span>);</div></pre></td></tr></table></figure></p>
<p>上面的代码有几个好处：</p>
<ul>
<li>multicast 是纯函数，它简单灵活，对系统的影响很小。</li>
<li>multicast 对任意函数返回确定的函数，不影响外部环境和状态。</li>
<li>setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。</li>
<li>multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。</p>
<p>文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/函数式编程基础-转/" itemprop="url">
                  函数式编程基础(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T11:50:30+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/函数式编程基础-转/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/函数式编程基础-转/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在这章，会覆盖函数式编程的核心概念：</p>
<ul>
<li>使用函数和数组实现控制流</li>
<li>编写纯函数、匿名函数、递归函数等等</li>
<li>像对象那样传递函数</li>
<li>利用map()、filter()和reduce()函数</li>
</ul>
</blockquote>
<h2 id="char1-函数式编程语言"><a href="#char1-函数式编程语言" class="headerlink" title="char1.函数式编程语言"></a>char1.函数式编程语言</h2><p>函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。</p>
<h3 id="是什么让一个语言具有函数式特征？"><a href="#是什么让一个语言具有函数式特征？" class="headerlink" title="是什么让一个语言具有函数式特征？"></a>是什么让一个语言具有函数式特征？</h3><p>函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。</p>
<p>同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。</p>
<p>然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th style="text-align:center">命令式</th>
<th style="text-align:center">函数式</th>
</tr>
</thead>
<tbody>
<tr>
<td>编程风格</td>
<td style="text-align:center">一步一步地执行，并且要管理状态的变化</td>
<td style="text-align:center">描述问题和所需的数据变化已解决问题</td>
</tr>
<tr>
<td>状态变化</td>
<td style="text-align:center">很重要</td>
<td style="text-align:center">不存在</td>
</tr>
<tr>
<td>执行顺序</td>
<td style="text-align:center">很重要</td>
<td style="text-align:center">不太重要</td>
</tr>
<tr>
<td>主要的控制流</td>
<td style="text-align:center">循环、条件、函数调用</td>
<td style="text-align:center">函数调用和递归</td>
</tr>
<tr>
<td>主要的操作单元</td>
<td style="text-align:center">结构体和类对象</td>
<td style="text-align:center">函数作为一等公民的对象和数据集</td>
</tr>
</tbody>
</table>
<p>函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。</p>
<blockquote>
<p>注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。</p>
<p>不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。</p>
<p>总的来说，什么是使用函数式编程真正实际的优点呢？</p>
<h3 id="更加简洁的代码"><a href="#更加简洁的代码" class="headerlink" title="更加简洁的代码"></a>更加简洁的代码</h3><p>函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。</p>
<p>例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge2dArrayIntoOne</span>(<span class="params">arrays</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> count = arrays.length;</div><div class="line">    <span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Array</span>(count);</div><div class="line">    <span class="keyword">var</span> c = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>,jlen = array[i].length;j&lt;jlen;j++)&#123;</div><div class="line">            merged[c++] = arrays[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> merged;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在使用函数式技术，可以写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge2dArrayIntoOne = <span class="function"><span class="keyword">function</span>(<span class="params">arrays</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> arrays.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">p,n</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> p.concat(n);</div><div class="line"> &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。</p>
<h3 id="复用性"><a href="#复用性" class="headerlink" title="复用性"></a>复用性</h3><p>由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。</p>
<p>在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。</p>
<h3 id="减少耦合"><a href="#减少耦合" class="headerlink" title="减少耦合"></a>减少耦合</h3><p>耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。</p>
<h3 id="数学正确性"><a href="#数学正确性" class="headerlink" title="数学正确性"></a>数学正确性</h3><p>最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。</p>
<h3 id="非函数式世界中的函数式编程"><a href="#非函数式世界中的函数式编程" class="headerlink" title="非函数式世界中的函数式编程"></a>非函数式世界中的函数式编程</h3><p>函数式和非函数式编程能混合在一起吗？</p>
<p>这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。</p>
<p>例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = [];count = <span class="number">0</span>;</div><div class="line">text = myString.split(<span class="string">' '</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;count&lt;<span class="number">4</span>,i&lt;text.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!text[i].match(<span class="regexp">/[0-9]/</span>))&#123;</div><div class="line">        words = words.concat(text[i]);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数式编程会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = [];</div><div class="line"><span class="keyword">var</span> words = myString.split(<span class="string">' '</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (!x.match(<span class="regexp">/[0-9]/</span>));</div><div class="line">&#125;).slice(<span class="number">0</span>,<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(words);</div></pre></td></tr></table></figure>
<p>如果有一个函数式编程的工具库，代码可以进一步被简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> words = toSequence(myString).match(<span class="regexp">/[a-zA-Z]+/</span>).first(<span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的”words”和”count”变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。</p>
<h3 id="Javascript是函数式编程语言吗？"><a href="#Javascript是函数式编程语言吗？" class="headerlink" title="Javascript是函数式编程语言吗？"></a>Javascript是函数式编程语言吗？</h3><p>现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？</p>
<p>Javascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。</p>
<p>它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：</p>
<ul>
<li>Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。</li>
<li>Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。</li>
<li>Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。</li>
</ul>
<p>也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。</p>
<p>关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。</p>
<p>最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。</p>
<h2 id="char2-与函数共舞"><a href="#char2-与函数共舞" class="headerlink" title="char2.与函数共舞"></a>char2.与函数共舞</h2><blockquote>
<p>有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 –John Carmack，游戏《毁灭战士》首席程序员</p>
</blockquote>
<p>函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。</p>
<p>我们从Javascript的一个小尴尬开始。</p>
<p>假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">var</span> values = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulate</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    values.push(obj.value);</div><div class="line">&#125;</div><div class="line">accumulate(obj1);</div><div class="line">accumulate(obj2);</div><div class="line"><span class="built_in">console</span>.log(values); <span class="comment">//Output: [obj1.value,obj2.value]</span></div></pre></td></tr></table></figure>
<p>这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。</p>
<p>但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulate2</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    values.push(obj.value);</div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj1)); <span class="comment">// Returns: [obj1.value]</span></div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj2)); <span class="comment">// Returns: [obj2.value]</span></div><div class="line"><span class="built_in">console</span>.log(accumulate2(obj3)); <span class="comment">// Returns: [obj3.value]</span></div></pre></td></tr></table></figure>
<p>只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ValueAccumulator = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    <span class="keyword">var</span> accumulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        value.push(obj.value);</div><div class="line">    &#125;;</div><div class="line">    accumulate();</div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。</p>
<p>我们需要的是一个自调用函数</p>
<h3 id="自调用函数和闭包"><a href="#自调用函数和闭包" class="headerlink" title="自调用函数和闭包"></a>自调用函数和闭包</h3><p>如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ValueAccumulator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    <span class="keyword">var</span> accumulate = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(obj)&#123;</div><div class="line">            values.push(obj.value);</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> accumulates;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//This allows us to do this</span></div><div class="line"><span class="keyword">var</span> accumulator = ValueAccumulator();</div><div class="line">accumulator(obj1);</div><div class="line">accumulator(obj2);</div><div class="line"><span class="built_in">console</span>.log(accumulator()); <span class="comment">//Output: [obj1.value,obj2.value]</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ValueAccumulator = -&gt;</div><div class="line"> values = []</div><div class="line"> (obj) -&gt;</div><div class="line"> values.push obj.value <span class="keyword">if</span> obj</div><div class="line"> values</div></pre></td></tr></table></figure>
<p>这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。</p>
<blockquote>
<p>Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。</p>
</blockquote>
<p>闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。</p>
<p>高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。</p>
<p>这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。</p>
<p>在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。</p>
<p>来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2</span></div><div class="line"><span class="keyword">var</span> accumulator2 = ValueAccumulator();</div><div class="line"><span class="keyword">var</span> objects = [obj1, obj2, obj3]; <span class="comment">// 这个数组可以很大</span></div><div class="line">objects.forEach(accumulator2);</div><div class="line"><span class="built_in">console</span>.log(accumulator2());</div></pre></td></tr></table></figure></p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。</p>
<p>用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。</p>
<p>纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。</p>
<p>举例说明来对比一下非纯函数和纯函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把信息打印到屏幕中央的函数</span></div><div class="line"><span class="keyword">var</span> printCenter = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = str;</div><div class="line">  elem.style.position = <span class="string">'absolute'</span>;</div><div class="line">  elem.style.top = <span class="built_in">window</span>.innerHeight / <span class="number">2</span> + <span class="string">"px"</span>;</div><div class="line">  elem.style.left = <span class="built_in">window</span>.innerWidth / <span class="number">2</span> + <span class="string">"px"</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(elem);</div><div class="line">&#125;;</div><div class="line">printCenter(<span class="string">'hello world'</span>);</div><div class="line"><span class="comment">// 纯函数完成相同的事情</span></div><div class="line"><span class="keyword">var</span> printSomewhere = <span class="function"><span class="keyword">function</span>(<span class="params">str, height, width</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = str;</div><div class="line">  elem.style.position = <span class="string">'absolute'</span>;</div><div class="line">  elem.style.top = height;</div><div class="line">  elem.style.left = width;</div><div class="line">  <span class="keyword">return</span> elem;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.appendChild(</div><div class="line">printSomewhere(<span class="string">'hello world'</span>,</div><div class="line"><span class="built_in">window</span>.innerHeight / <span class="number">2</span>) + <span class="number">10</span> + <span class="string">"px"</span>,</div><div class="line"><span class="built_in">window</span>.innerWidth / <span class="number">2</span>) + <span class="number">10</span> + <span class="string">"px"</span>));</div></pre></td></tr></table></figure></p>
<p>非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。</p>
<p>非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> messages = [<span class="string">'Hi'</span>, <span class="string">'Hello'</span>, <span class="string">'Sup'</span>, <span class="string">'Hey'</span>, <span class="string">'Hola'</span>];</div><div class="line">messages.map(<span class="function"><span class="keyword">function</span>(<span class="params">s,i</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> printSomewhere(s,<span class="number">100</span>*i*<span class="number">10</span>,<span class="number">100</span>*i*<span class="number">10</span>);</div><div class="line">&#125;).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。</p>
</blockquote>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>把函数作为头等对象的另一个好处就是匿名函数</p>
<p>就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。</p>
<p>下面是一些匿名函数的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写匿名函数的标准方式</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//匿名函数可以赋值给变量</span></div><div class="line"><span class="keyword">var</span> anon = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处</span></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</div><div class="line">&#125;,<span class="number">1000</span>);</div><div class="line"><span class="comment">//Output:  1413249010672, 1413249010673, 1413249010674, ...</span></div><div class="line"><span class="comment">//如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数</span></div><div class="line">setInterval(<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()),<span class="number">1000</span>)</div><div class="line"><span class="comment">//Output:  1413249010671</span></div></pre></td></tr></table></figure></p>
<p>下面是匿名函数和高阶函数配合使用的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">powersOf</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</div><div class="line">        <span class="comment">//this is an anonymous function!</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,y);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">powerOfTwo = powersOf(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">1</span>)); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">2</span>)); <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(powerOfTwo(<span class="number">3</span>)); <span class="comment">// 8</span></div><div class="line">powerOfThree = powersOf(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(powerOfThree(<span class="number">3</span>)); <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(powerOfThree(<span class="number">10</span>)); <span class="comment">// 59049</span></div></pre></td></tr></table></figure></p>
<p>这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。</p>
<p>还记得累加器的那个函数吗？它可以用匿名函数重写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</div><div class="line">    obj2 = &#123;<span class="attr">value</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">var</span> values = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="comment">//匿名函数</span></div><div class="line"> <span class="keyword">var</span> values = [];</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">     <span class="comment">//有一个匿名函数！</span></div><div class="line">     <span class="keyword">if</span>(obj)&#123;</div><div class="line">         values.push(obj.value);</div><div class="line">         <span class="keyword">return</span> values;</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="keyword">return</span> values;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">&#125;)(); <span class="comment">//让它自执行</span></div><div class="line"><span class="built_in">console</span>.log(values(obj1)); <span class="comment">// Returns: [obj.value]</span></div><div class="line"><span class="built_in">console</span>.log(values(obj2)); <span class="comment">// Returns: [obj.value, obj2.value]</span></div></pre></td></tr></table></figure></p>
<p>真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){…})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。</p>
<blockquote>
<p>匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。</p>
</blockquote>
<p>匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。</p>
<h3 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h3><p>在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。</p>
<p>这种技术用于简化多个函数一次应用于一个对象的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每个函数占用一行来调用，不如……</span></div><div class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">arr1 = arr.reverse();</div><div class="line">arr2 = arr1.concat([<span class="number">5</span>, <span class="number">6</span>]);</div><div class="line">arr3 = arr2.map(<span class="built_in">Math</span>.sqrt);</div><div class="line"><span class="comment">// ……把它们串到一起放在一行里面</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reverse().concat([<span class="number">5</span>, <span class="number">6</span>]).map(<span class="built_in">Math</span>.sqrt));</div><div class="line"><span class="comment">// 括号也许可以说明是怎么回事</span></div><div class="line"><span class="built_in">console</span>.log(((([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).reverse()).concat([<span class="number">5</span>, <span class="number">6</span>])).map(<span class="built_in">Math</span>.sqrt));</div></pre></td></tr></table></figure></p>
<p>这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.zip = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们就可以写成下面的样子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line"> <span class="keyword">return</span> n*<span class="number">2</span>;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归应该是最著名的函数式编程技术。就是一个函数调用它自己。</p>
<p>当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。</p>
<p>使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。</p>
<p>下面有个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> foo(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">5</span>));</div></pre></td></tr></table></figure></p>
<p>递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。</p>
<p>一个明显的例子就是遍历树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getLeafs = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="comment">//base case</span></div><div class="line">    <span class="keyword">return</span> node.innerText;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//recursive case</span></div><div class="line">    <span class="keyword">return</span> node.childNodes.map(getLeafs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。</p>
<p>历史上有个欧几里得算法用于找出两个数的最大公分母<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(b === <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//基准情形</span></div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> gcd(b,a%b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(gcd(<span class="number">12</span>,<span class="number">8</span>));</div></pre></td></tr></table></figure></p>
<p>理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。</p>
<p>全部的实现代码大概要40行，这里只是展示伪代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>)&#123;</div><div class="line">        <span class="comment">//基准情形：只有0或1个元素的数组是不用排序的</span></div><div class="line">        <span class="keyword">return</span> items;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//递归情形：把数组拆分、排序、合并</span></div><div class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">        <span class="comment">// 分</span></div><div class="line">        <span class="keyword">var</span> left = mergeSort(arr.slice(<span class="number">0</span>, middle));</div><div class="line">        <span class="keyword">var</span> right = mergeSort(arr.slice(middle));</div><div class="line">        <span class="comment">// 治</span></div><div class="line">        <span class="comment">// merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起</span></div><div class="line">        <span class="keyword">return</span> merge(left, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。</p>
<p>这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理想化的JavaScript伪代码:</span></div><div class="line"><span class="keyword">var</span> infinateNums = range(<span class="number">1</span> to infinity);</div><div class="line"><span class="keyword">var</span> tenPrimes = infinateNums.getPrimeNumbers().first(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。</p>
<p>然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。</p>
<h2 id="char3-函数式程序员的工具集"><a href="#char3-函数式程序员的工具集" class="headerlink" title="char3.函数式程序员的工具集"></a>char3.函数式程序员的工具集</h2><p>如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。</p>
<p>map()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。</p>
<p>然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">newArray = myArray.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x*<span class="number">2</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(myArray);  <span class="comment">// Output: [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// Output: [2,4,6,8]</span></div></pre></td></tr></table></figure>
<p>还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。</p>
<p>回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x + <span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(myArray.map(myCallback));</div></pre></td></tr></table></figure></p>
<p>对于比较简单的任务可以用匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myArray.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>&#125;))</div></pre></td></tr></table></figure></p>
<p>回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">xhr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(xht.status);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">$.ajax(myUrl).done(myCallback);</div></pre></td></tr></table></figure></p>
<p>注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.ajax(myURI).fail(myCallback(xhr)); </div><div class="line"><span class="comment">// 或者</span></div><div class="line">$.ajax(myURI).fail(myCallback());</div></pre></td></tr></table></figure></p>
<p>如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个”true”，然后就报错了。</p>
<p>也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(status);</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">$.ajax(myURI).done(<span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</div><div class="line">  myCallback(xhr.status)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><p>map()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.map(callback[,thisArg]);</div></pre></td></tr></table></figure></p>
<ul>
<li>callback():这个函数为新数组产生一个元素，它接受的参数：<ul>
<li>currentValue: 数组当前遍历到的元素</li>
<li>index: 数组中当前元素序数</li>
<li>array: 当前正在处理的数组</li>
</ul>
</li>
<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">  integers = [<span class="number">1</span>, <span class="number">-0</span>, <span class="number">9</span>, <span class="number">-8</span>, <span class="number">3</span>],</div><div class="line">  numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</div><div class="line">  str = <span class="string">'hello world how ya doing?'</span>;</div><div class="line"> <span class="comment">//将整数映射为他们自己知道的绝对值</span></div><div class="line"> <span class="built_in">console</span>.log(integers.map(<span class="built_in">Math</span>.abs));</div><div class="line"> <span class="comment">//将数组中的元素与自己的位置序数相乘</span></div><div class="line"> <span class="built_in">console</span>.log(numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x,i</span>)</span>&#123;<span class="keyword">return</span> x*i&#125;));</div><div class="line"> <span class="comment">//单词隔一个变一个大写</span></div><div class="line"> <span class="built_in">console</span>.log(str.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">s,i</span>)</span>&#123;</div><div class="line">     <span class="keyword">if</span>(i%<span class="number">2</span> === <span class="number">0</span>)&#123;</div><div class="line">         <span class="keyword">return</span> s.toUpperCase();</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="keyword">return</span> s;</div><div class="line">     &#125;</div><div class="line"> &#125;))</div></pre></td></tr></table></figure></p>
<blockquote>
<p>尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。<br>MyObject.prototype.map = function(f) {<br> return new MyObject(f(this.value));<br>};</p>
</blockquote>
<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><p>filter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.filter(callback[,thisArg]);</div></pre></td></tr></table></figure></p>
<ul>
<li>callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：<ul>
<li>currentValue: 数组当前遍历到的元素</li>
<li>index: 数组中当前元素的序数</li>
<li>array: 当前正在处理的数组</li>
</ul>
</li>
<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myarray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">words = <span class="string">'hello 123 world how 345 ya doing'</span>.split(<span class="string">' '</span>);</div><div class="line">re = <span class="string">'[a-zA-Z]'</span>;</div><div class="line"><span class="comment">// 筛选整数</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">// 筛选所有含字母的单词</span></div><div class="line"><span class="built_in">console</span>.log(words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> s.match(re);</div><div class="line">&#125;));</div><div class="line"><span class="comment">// 随机移除数组中的元素</span></div><div class="line"><span class="built_in">console</span>.log(myarray.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">2</span>)</div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h3><p>reduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.reduce(callback[,initialValue]);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：<ul>
<li>previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）</li>
<li>currentValue：数组当前正在处理的元素</li>
<li>index：数组中当前元素的序数</li>
<li>array：当前正在处理的数组</li>
</ul>
</li>
<li>initialValue：可选。第一次回调所传入参数的初始值</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// 把数组中所有的值加起来</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;, <span class="number">0</span>));</div><div class="line"><span class="comment">// 查找数组中最大的值</span></div><div class="line"><span class="built_in">console</span>.log(numbers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(a, b) <span class="comment">// max()函数只能有两个参数</span></div><div class="line">  &#125;) </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><p>forEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：arr.forEach(callback[,initialValue]);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>callback()：对数组中每一个元素所应用的。参数有：<ul>
<li>currentValue：数组当前正在处理的元素</li>
<li>index：数组中当前元素的序数</li>
<li>array：当前正在处理的数组</li>
</ul>
</li>
<li>thisArg：可选。回调函数中作为this的值</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> nodes = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  elem.textContent = x;</div><div class="line">  <span class="keyword">return</span> elem;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 对每一个元素的值输出日志</span></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 把节点追加到DOM上</span></div><div class="line">nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(x)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><p>如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]) <span class="comment">// 拼接两个数组</span></div><div class="line"><span class="comment">// Output: [1, 2, 3, 'a','b','c']</span></div></pre></td></tr></table></figure></p>
<p>它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</div><div class="line"><span class="keyword">var</span> x = arr1.concat(arr2, arr3);</div><div class="line"><span class="keyword">var</span> y = arr1.concat(arr2).concat(arr3));</div><div class="line"><span class="keyword">var</span> z = arr1.concat(arr2.concat(arr3)));</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="built_in">console</span>.log(y);</div><div class="line"><span class="built_in">console</span>.log(z);</div></pre></td></tr></table></figure>
<h3 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse()"></a>Array.prototype.reverse()</h3><p>这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。</p>
<p>然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> invert = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x, i, a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length - (i + <span class="number">1</span>)];</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> q = invert([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</div><div class="line"><span class="built_in">console</span>.log(q);</div></pre></td></tr></table></figure>
<h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h3><p>与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = [<span class="number">200</span>, <span class="number">12</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">344</span>];</div><div class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a–b&#125;) );</div><div class="line"><span class="comment">// arr现在是: [7, 12, 56, 200, 344];</span></div></pre></td></tr></table></figure>
<p>我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等</p>
<h3 id="Array-prototype-every-amp-amp-Array-prototype-some"><a href="#Array-prototype-every-amp-amp-Array-prototype-some" class="headerlink" title="Array.prototype.every() &amp;&amp; Array.prototype.some()"></a>Array.prototype.every() &amp;&amp; Array.prototype.some()</h3><p>Array.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].every(isNumber)); <span class="comment">// Return: true</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>].every(isNumber)); <span class="comment">// Return: false</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>].some(isNumber)); <span class="comment">// Return: true</span></div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/JS函数式编程的力量-转/" itemprop="url">
                  JS函数式编程的力量(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T09:29:02+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/转载笔记/" itemprop="url" rel="index">
                    <span itemprop="name">转载笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/JS函数式编程的力量-转/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/JS函数式编程的力量-转/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。</p>
</blockquote>
<h2 id="Javascript函数式编程的力量"><a href="#Javascript函数式编程的力量" class="headerlink" title="Javascript函数式编程的力量"></a>Javascript函数式编程的力量</h2><p>几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。</p>
<p>你是说Javascript？这个WEB脚本语言？没错！</p>
<p>Javascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。</p>
<p>为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。</p>
<p>在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。</p>
<p>不过在我们开始前，先来做个实验。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。</p>
<h3 id="应用–一个电子商务网站"><a href="#应用–一个电子商务网站" class="headerlink" title="应用–一个电子商务网站"></a>应用–一个电子商务网站</h3><p>为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。</p>
<h3 id="命令式方法"><a href="#命令式方法" class="headerlink" title="命令式方法"></a>命令式方法</h3><p>首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//create some objects to store the data</span></div><div class="line"><span class="keyword">var</span> columbian = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'columbian'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> frenchRoast = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'french Roast'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">8</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> decaf = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'decaf'</span>,</div><div class="line">    <span class="attr">basePrice</span>: <span class="number">6</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//我们将使用辅助函数计算价格</span></div><div class="line"><span class="comment">//根据size打印到一个HTML的列表中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPrice</span>(<span class="params">coffee,size</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(size == <span class="string">'small'</span>)&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">2</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="string">'medium'</span>)&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">4</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> price = coffee.basePrice + <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//create the new html list item</span></div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">var</span> label = coffee.name + <span class="string">' '</span> + size;</div><div class="line">    <span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(label+ <span class="string">'price: $'</span>+ price);</div><div class="line">    node.appendChild(textnode);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'products'</span>).appendChild(node);</div><div class="line">&#125;</div><div class="line"><span class="comment">//现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数</span></div><div class="line">printPrice(columbian, <span class="string">'small'</span>);</div><div class="line">printPrice(columbian, <span class="string">'medium'</span>);</div><div class="line">printPrice(columbian, <span class="string">'large'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'small'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'medium'</span>);</div><div class="line">printPrice(frenchRoast, <span class="string">'large'</span>);</div><div class="line">printPrice(decaf, <span class="string">'small'</span>);</div><div class="line">printPrice(decaf, <span class="string">'medium'</span>);</div><div class="line">printPrice(decaf, <span class="string">'large'</span>);</div></pre></td></tr></table></figure></p>
<p>如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！</p>
<p>采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。<br>通过更函数式一些的方法，同样的应用可以这样来写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从接口中分解数据和逻辑</span></div><div class="line"><span class="keyword">var</span> printPrice = <span class="function"><span class="keyword">function</span>(<span class="params">price,label</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    <span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(label+ <span class="string">' price: $'</span>+ price);</div><div class="line">    node.appendChild(textnode);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'products2'</span>).appendChild(node);</div><div class="line">&#125;</div><div class="line"><span class="comment">//为每种咖啡创建函数对象</span></div><div class="line"><span class="keyword">var</span> columbian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'colimbian'</span>;</div><div class="line">    <span class="keyword">this</span>.basePrice = <span class="number">5</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> frenchRoast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.name = <span class="string">'french roast'</span>;</div><div class="line"> <span class="keyword">this</span>.basePrice = <span class="number">8</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> decaf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.name = <span class="string">'decaf'</span>;</div><div class="line"> <span class="keyword">this</span>.basePrice = <span class="number">6</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//为每种size通过字面量创建对象</span></div><div class="line"><span class="keyword">var</span> small = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">2</span>&#125;,</div><div class="line">    <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' small'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> medium = &#123;</div><div class="line">  <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">4</span>&#125;,</div><div class="line">  <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' medium'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> large = &#123;</div><div class="line">  <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">6</span>&#125;,</div><div class="line">  <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' large'</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//将所有咖啡的种类和size放到数组里</span></div><div class="line"><span class="keyword">var</span> coffeeTypes = [columbian, frenchRoast, decaf];</div><div class="line"><span class="keyword">var</span> coffeeSizes = [small, medium, large];</div><div class="line"><span class="comment">//创建由上面内容组成的新对象，并把它们放到一个新数组里</span></div><div class="line"><span class="keyword">var</span> coffee = coffeeTypes.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous,current</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newCoffee = coffeeSizes.map(<span class="function"><span class="keyword">function</span>(<span class="params">mixin</span>)</span>&#123;</div><div class="line">        <span class="comment">//`plusmix`是函数时的mixin</span></div><div class="line">        <span class="keyword">var</span> newCoffeeObj = plusMixin(current,mixin);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> newCoffeeObj();</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> previous.concat(newCoffee);</div><div class="line">&#125;,[]);</div><div class="line"><span class="comment">//现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了</span></div><div class="line">coffee.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">coffee</span>)</span>&#123;</div><div class="line">    printPrice(coffee.getPrice(),coffee.getLabel());</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peruvian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'peruvian'</span>;</div><div class="line">    <span class="keyword">this</span>.basePrice = <span class="number">11</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> extraLarge = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.basePrice + <span class="number">10</span>&#125;,</div><div class="line">    <span class="attr">getLabel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' extra large'</span>&#125;</div><div class="line">&#125;;</div><div class="line">coffeeTypes.push(peruvian);</div><div class="line">coffeeSizes.push(extraLarge);</div></pre></td></tr></table></figure></p>
<p>咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块–通过一个叫”plusMixin”的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。</p>
<p>实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">coffeeTypes.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous,current</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newCoffee = coffeeSizes.map(<span class="function"><span class="keyword">function</span>(<span class="params">mixin</span>)</span>&#123;</div><div class="line">        <span class="comment">//`plusMixin`</span></div><div class="line">        <span class="keyword">var</span> newCoffeeObj = plusMixin(current,mixin);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> newCoffeeObj();</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> previous.concat(newCoffee);</div><div class="line">&#125;.[]).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">coffee</span>)</span>&#123;</div><div class="line">    printPrice(coffee.getPrice(),coffee.getLabel());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/17/流程控制与错误处理/" itemprop="url">
                  流程控制与错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-17T18:36:49+08:00" content="2016-05-17">
              2016-05-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/17/流程控制与错误处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/17/流程控制与错误处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Energy and persistence conquer all things.</p>
</blockquote>
<p>在JavaScript中，任何表达式(expression)都可以看作一条语句(statement)，每条语句可以使用分号( ; )来分隔。你可以在每行书写一条语句；也可以在一行书写多条语句。但是我们推荐在书写代码的时候采用第一种方式，以便于后期的代码维护。</p>
<h2 id="语句块-Block-Statement"><a href="#语句块-Block-Statement" class="headerlink" title="语句块(Block Statement)"></a>语句块(Block Statement)</h2><p>大多数程序都使用语句块来给语句分组，这样可以使语句的结构清晰明了。我们使用一对花括号（ {} ）来分组语句块，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   statement_1;   statement_2;</div><div class="line">   statement_3;</div><div class="line">   ...</div><div class="line">   statement_n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例<br>语句块通常大多数用于流程控制，如 if, for, while等等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>)&#123;</div><div class="line">  x++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里{ x++; } 就是语句块。</p>
<h2 id="条件判断语句-Conditional-Statements"><a href="#条件判断语句-Conditional-Statements" class="headerlink" title="条件判断语句(Conditional Statements)"></a>条件判断语句(Conditional Statements)</h2><p>条件判断语句指的是根据指定的条件所返回的结果（真或假或其它预定义的），来执行特定的语句。JavaScript提供了两种条件判断语句：if…else 和 switch。</p>
<h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><p>当一个逻辑条件为真，用if语句执行一个语句。当这个条件为假，使用可选择的else从句来执行这个语句。</p>
<p>在条件表达式中最好不要使用“=”来判断条件是否相等，因为这会产生非预期结果。不要使用下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x = y) &#123;</div><div class="line">  <span class="comment">/* do the right thing */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你需要在条件表达式中使用赋值，一个共同的习惯是在赋值语句前后额外的添加一对括号。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((x = y)) &#123;</div><div class="line">  <span class="comment">/* do the right thing */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这些值将被计算出 false:</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>NaN</li>
<li>空字符串(“”)<br>当传递给条件语句时，所有其他值，包括所有对象会被计算为 true。</li>
</ul>
<p><strong>请不要混淆原始的布尔值true和false与布尔对象的值true和false。</strong>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">if</span>(b) <span class="comment">//this condition evaluates to true</span></div><div class="line"><span class="keyword">if</span>(b == <span class="literal">true</span>) <span class="comment">//this condition evaluates to false</span></div></pre></td></tr></table></figure></p>
<p>例如<br>在下面的例子中，如果一个文本对象中的字符串长度是3，函数checkData返回true；否则，函数显示一个alert的弹出框消息并返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.form1.threeChar.value.length == <span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">"Enter exactly three characters. "</span> +</div><div class="line">      <span class="built_in">document</span>.form1.threeChar.value + <span class="string">" is not valid."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="switch语句-Switch-Statement"><a href="#switch语句-Switch-Statement" class="headerlink" title="switch语句(Switch Statement)"></a>switch语句(Switch Statement)</h3><p>开关语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个case label。如果匹配成功，这个程序执行相关的语句。开关语句如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (expression) &#123;</div><div class="line">   <span class="keyword">case</span> label_1:</div><div class="line">      statements_1</div><div class="line">      [<span class="keyword">break</span>;]</div><div class="line">   <span class="keyword">case</span> label_2:</div><div class="line">      statements_2</div><div class="line">      [<span class="keyword">break</span>;]</div><div class="line">   ...</div><div class="line">   default:</div><div class="line">      statements_def</div><div class="line">      [<span class="keyword">break</span>;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环语句-Loop-Statement"><a href="#循环语句-Loop-Statement" class="headerlink" title="循环语句(Loop Statement)"></a>循环语句(Loop Statement)</h2><p>循环语句是一系列反复执行直到符合特定条件的命令。JavaScript 支持 for, do while, while这些循环语句，还有Label (label 本身不是一个循环语句，但是经常和这些语句一起使用)。另外，你可以在循环语句中使用break和continue 语句。另一个语句：for…in也反复执行语句，但它是用来操作对象的。</p>
<h3 id="标签语句-label-Statement"><a href="#标签语句-label-Statement" class="headerlink" title="标签语句(label Statement)"></a>标签语句(label Statement)</h3><p>标签语句提供一种使你同一程序的另一处找到它的标识。例如，你可以用一个标签来识别一个循环，并用break或continue语句来说明一个程序是否要中断这个循环或是继续执行。如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">label:</div><div class="line">    statement</div></pre></td></tr></table></figure></p>
<p>label的值可以是js的任何非保留字符标识符。用label标识的语句可以是任何语句。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">markLoop:</div><div class="line"><span class="keyword">while</span>(theMark == <span class="literal">true</span>)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中断语句-break-Statement"><a href="#中断语句-break-Statement" class="headerlink" title="中断语句(break Statement)"></a>中断语句(break Statement)</h2><p>使用中断语句终止循环、开关或与标签语句连接。</p>
<ul>
<li>当你使用没有带标签语句的中断语句（break）时，while,do-while,for或switch封闭的内部语句将立即终止，并转移到后面的语句执行。</li>
<li><p>当你使用带有标签语句的中断语句(break)时，将终止在特定的标签语句。</p>
<p>中断语句的语法如下：<br>1.break;<br>2.break label;</p>
<p>第一种语法形式用于终止在循环体或者switch的封闭内部；第二种语法形式用于在特定的封闭标签语句。</p>
<p>示例1：<br>下面的例子中，对一个数组里的元素进行循环处理，直到数组元素下标等于theValue的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(a[i] == theValue)&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>示例2：中断跳到标签语句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> z = <span class="number">0</span>;</div><div class="line">labelCancelLoops: <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Outer loops:"</span> + x);</div><div class="line">    x += <span class="number">1</span>;</div><div class="line">    z = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Inner loops: "</span>+z);</div><div class="line">        z+=<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(z === <span class="number">10</span> &amp;&amp; x === <span class="number">10</span>)&#123;</div><div class="line">            <span class="keyword">break</span> labelCancelLoops;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z === <span class="number">10</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="连续语句-continue-Statement"><a href="#连续语句-continue-Statement" class="headerlink" title="连续语句(continue Statement)"></a>连续语句(continue Statement)</h2><p>连续语句用于重新开始while,do-while,for语句，或者标签语句(label statement).</p>
<ul>
<li>当你使用没有带标签语句的连续语句(continue Statement)时，将在当前的while,do-while或者for循环体封闭的内部语句中止执行，然后进入下一次循环继续执行。与中断语句(break Statement)相比，连续语句不会把整个循环终止。在while循环里，将跳回条件判断(continue)；<br>在for循环里，则调回累计表达式(increment-expression).</li>
<li><p>当你使用带有标签语句的连续语句时，用于识别循环体中的标签语句。</p>
<p>连续语句的语法如下：</p>
<p>1.continue<br>2.continue label</p>
</li>
</ul>
<p>示例1<br>下面的例子实现了一个带有连续语句的while循环，当i的值为3时，该连续语句执行。因此，n的值分别为1、3、7和12。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line">n = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</div><div class="line">   i++;</div><div class="line">   <span class="keyword">if</span> (i == <span class="number">3</span>)</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">   n += i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例2<br>一个标签语句checkiandj包含了一个标签语句checkj。如果连续语句被触发，程序会中止在当前循环中的checkj然后开始下一轮循环。每次连续语句被触发，checkj会重复直到该条件判断返回false值。当返回false值时，会完成剩下的checkiandj语句，然后checkiandj会重复直到其条件判断返回false值。当返回false值时，程序会继续执行在checkiandj后面的语句。</p>
<p>如果连续语句包含的是checkiandj标签，那么程序会在checkiandj语句的顶层继续执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">checkiandj :</div><div class="line">   <span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</div><div class="line">      <span class="built_in">document</span>.write(i + <span class="string">"&lt;br/&gt;"</span>);</div><div class="line">      i += <span class="number">1</span>;</div><div class="line">      checkj :</div><div class="line">         <span class="keyword">while</span> (j &gt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="built_in">document</span>.write(j + <span class="string">"&lt;br/&gt;"</span>);</div><div class="line">            j -= <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> ((j % <span class="number">2</span>) == <span class="number">0</span>)</div><div class="line">               <span class="keyword">continue</span> checkj;</div><div class="line">            <span class="built_in">document</span>.write(j + <span class="string">" is odd.&lt;br/&gt;"</span>);</div><div class="line">         &#125;</div><div class="line">      <span class="built_in">document</span>.write(<span class="string">"i = "</span> + i + <span class="string">"&lt;br/&gt;"</span>);</div><div class="line">      <span class="built_in">document</span>.write(<span class="string">"j = "</span> + j + <span class="string">"&lt;br/&gt;"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象操作语句-Object-Manipulation-Statements"><a href="#对象操作语句-Object-Manipulation-Statements" class="headerlink" title="对象操作语句(Object Manipulation Statements)"></a>对象操作语句(Object Manipulation Statements)</h2><p>JavaScript用for…in,for each…in和with语句来操作对象。</p>
<h2 id="异常处理语句-Exception-Handling-Statements"><a href="#异常处理语句-Exception-Handling-Statements" class="headerlink" title="异常处理语句(Exception Handling Statements)"></a>异常处理语句(Exception Handling Statements)</h2><p>你可以用throw语句抛出一个异常并且用try…catch语句捕获处理它。</p>
<h3 id="异常类型-Exception-Types"><a href="#异常类型-Exception-Types" class="headerlink" title="异常类型(Exception Types)"></a>异常类型(Exception Types)</h3><p>JavaScript可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：</p>
<ul>
<li>ECMAScript exceptions</li>
<li>DOMException</li>
<li>nsIXPCException</li>
</ul>
<h3 id="抛出错误-throw-Statement"><a href="#抛出错误-throw-Statement" class="headerlink" title="抛出错误(throw Statement)"></a>抛出错误(throw Statement)</h3><p>使用throw语句抛出一个异常。当你抛出异常，你规定一个含有值的表达式要被抛出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> expression</div></pre></td></tr></table></figure></p>
<p>你可以抛出任意表达式而不是特定一种类型的表达式。下面的代码抛出了几个不同类型的表达式：</p>
<ul>
<li>throw “Error”; //string type</li>
<li>throw 42;</li>
<li>throw true;</li>
<li>throw {toString:function(){return “I’m an object!”}};</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//create an object type UserException</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserException</span> (<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.message = message;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"UserException"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Make the exception convert to a pretty string when used as a string (e.g. by the error console)</span></div><div class="line">UserException.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">': "'</span> + <span class="keyword">this</span>.message+ <span class="string">'"'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//create an instance of the object type and throw it</span></div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"Value too high"</span>);</div></pre></td></tr></table></figure>
<h3 id="try…catch语句"><a href="#try…catch语句" class="headerlink" title="try…catch语句"></a>try…catch语句</h3><p>try…catch语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常抛出。如果我们抛出一个异常，try…catch语句就捕获它。</p>
<p>try…catch语句有一个包含一条或者多条语句的try代码块，0个或多个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 换句话说，如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。</p>
<p>下面的例子使用了try…catch语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有”InvalidMonthNo”值的异常，然后在捕捉块语句中设monthName变量为unknown。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthName</span>(<span class="params">mo</span>) </span>&#123;</div><div class="line">  mo = mo - <span class="number">1</span>; <span class="comment">// Adjust month number for array index (1 = Jan, 12 = Dec)</span></div><div class="line">  <span class="keyword">var</span> months = [<span class="string">"Jan"</span>,<span class="string">"Feb"</span>,<span class="string">"Mar"</span>,<span class="string">"Apr"</span>,<span class="string">"May"</span>,<span class="string">"Jun"</span>,<span class="string">"Jul"</span>,<span class="string">"Aug"</span>,<span class="string">"Sep"</span>,<span class="string">"Oct"</span>,<span class="string">"Nov"</span>,<span class="string">"Dec"</span>];</div><div class="line">  <span class="keyword">if</span> (months[mo]) &#123;</div><div class="line">    <span class="keyword">return</span> months[mo];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">"InvalidMonthNo"</span>; <span class="comment">//throw keyword is used here</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span> &#123; <span class="comment">// statements to try</span></div><div class="line">  monthName = getMonthName(myMonth); <span class="comment">// function could throw exception</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">  monthName = <span class="string">"unknown"</span>;</div><div class="line">  logMyErrors(e); <span class="comment">// pass exception object to error handler -&gt; your own function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="捕捉块-The-catch-block"><a href="#捕捉块-The-catch-block" class="headerlink" title="捕捉块(The catch block)"></a>捕捉块(The catch block)</h3><p>你可以使用捕捉块来处理所有可能在try代码块中产生的异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">catch</span>(catchID)&#123;</div><div class="line">        statements</div><div class="line">    &#125;</div><div class="line"></div><div class="line">捕捉块指定了一个标识符 (上述语句中的catchID）来存放抛出语句指定的值；你可以用这个标识符来获取抛出的异常信息。在插入捕捉块时JavaScript创建这个标识符；标识符只存在于捕捉块的存续期间里；当捕捉块执行完成时，标识符不再可用。</div><div class="line"></div><div class="line">举个例子，下面代码抛出了一个异常。当异常出现时跳到捕捉块（the <span class="keyword">catch</span> block）。</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">`javascript</span></div><div class="line">   try &#123;</div><div class="line">      throw "myException" // generates an exception</div><div class="line">   &#125;</div><div class="line">   catch (e) &#123;</div><div class="line">   // statements to handle any exceptions</div><div class="line">      logMyErrors(e) // pass exception object to error handler</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="终结块-The-finally-Block"><a href="#终结块-The-finally-Block" class="headerlink" title="终结块(The finally Block)"></a>终结块(The finally Block)</h3><p>终结块包含了在try和catch块完成后、下面接着的try…catch语句之前执行的语句。终结块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，终结块里的语句也会执行。</p>
<p>你可以用终结块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的JavaScript允许你进入文件）。如果在文件打开时一个异常抛出，终结块会在脚本错误之前关闭文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">openMyFile();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    writeMyFile(theData); <span class="comment">//This may throw a error</span></div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    handleError(e); <span class="comment">// If we got a error we handle it</span></div><div class="line">&#125;<span class="keyword">finally</span> &#123;</div><div class="line">    closeMyFile(); <span class="comment">// always close the resource</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果终结块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</div><div class="line">    <span class="keyword">throw</span> <span class="string">"bogus"</span>;</div><div class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// this return statement is suspended</span></div><div class="line">                 <span class="comment">// until finally block has completed</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// not reachable</span></div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// overwrites the previous "return"</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// not reachable</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// "return false" is executed now  </span></div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>); <span class="comment">// not reachable</span></div><div class="line">&#125;</div><div class="line">f(); <span class="comment">// console 0, 1, 3; returns false</span></div></pre></td></tr></table></figure>
<p>嵌套try…catch语句</p>
<p>你可以嵌套一个或多个try…catch语句。如果一个内部的try…catch语句没有捕捉块（catch block），将会启动匹配外部的try…catch语句的捕捉块（catch block）。</p>
<h2 id="错误匹配对象-Utilizing-Error-objects"><a href="#错误匹配对象-Utilizing-Error-objects" class="headerlink" title="错误匹配对象(Utilizing Error objects)"></a>错误匹配对象(Utilizing Error objects)</h2><p>根据错误类型，你也许可以用’name’和’message’获取更精炼的信息。’name’提供了常规的错误类(e.g., ‘DOMException’ or ‘Error’)，而’message’通常提供了一条从错误对象转换成字符串的简明信息。</p>
<p>在抛出你个人所为的异常时，为了充分利用那些属性（比如你的catch块不能分辨是你个人所为的异常还是系统的异常时），你可以使用错误构造函数（the Error constructor）。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingErrorProne</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ourCodeMakesAMistake()) &#123;</div><div class="line">    <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The message'</span>));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    doSomethingToGetAJavascriptError();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">....</div><div class="line">try &#123;</div><div class="line">  doSomethingErrorProne();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(e.name); <span class="comment">// logs 'Error'</span></div><div class="line">  <span class="built_in">console</span>.log(e.message); <span class="comment">// logs 'The message' or a JavaScript error message)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="GaoQ" />
          <p class="site-author-name" itemprop="name">GaoQ</p>
          <p class="site-description motion-element" itemprop="description">There are no shortcuts to any place worth going</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GaoQ</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gaoquan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
