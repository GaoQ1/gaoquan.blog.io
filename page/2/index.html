<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="GaoQ's blog" />





  <link rel="alternate" href="/atom.xml" title="GaoQ's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="There are no shortcuts to any place worth going">
<meta property="og:type" content="website">
<meta property="og:title" content="GaoQ&#39;s blog">
<meta property="og:url" content="http://gaoquan.wang/page/2/index.html">
<meta property="og:site_name" content="GaoQ&#39;s blog">
<meta property="og:description" content="There are no shortcuts to any place worth going">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GaoQ&#39;s blog">
<meta name="twitter:description" content="There are no shortcuts to any place worth going">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> GaoQ's blog - There are no shortcuts to any place worth going </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b902fa08b28044c55da6c70921955ecb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>


<a href="https://github.com/GaoQ1"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png"></a>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">GaoQ's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">There are no shortcuts to any place worth going</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/17/JavaScript设计模式一/" itemprop="url">
                  JavaScript设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-17T10:13:37+08:00" content="2016-08-17">
              2016-08-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/17/JavaScript设计模式一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/17/JavaScript设计模式一/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>A particular fine spring came around.</p>
</blockquote>
<h2 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h2><p>在面向对象编程中，构造器是一个当新建对象的内存被分配后，用来初始化该对象的一个特殊函数。在JavaScript中几乎所有的东西都是对象，我们经常会对对象的构造器十分感兴趣。<br>对象构造器是被用来创建特殊类型的对象的，首先它要准备使用的对象，其次在对象初次被创建时，通过接收参数，构造器要用来对成员的属性和方法进行赋值。</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>下面是我们创建对象的三种基本方式：<br>下面的每一种都会创建一个新的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObject = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">var</span> newObject = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">var</span> newObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure></p>
<p>最后一个例子中”Object”构造器创建了一个针对特殊值的对象包装，只不过这里没有传值给它，所以它将会返回一个空对象。<br>有四种方式可以将一个键值对赋给一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 3 兼容形式</span></div><div class="line"><span class="comment">//1.“点号”法</span></div><div class="line">newObject.someKey = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line"><span class="comment">//获取属性</span></div><div class="line"><span class="keyword">var</span> key = newObject.someKey;</div><div class="line"></div><div class="line"><span class="comment">// 2. “方括号”法</span></div><div class="line"></div><div class="line"><span class="comment">// 设置属性</span></div><div class="line">newObject[<span class="string">"someKey"</span>] = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取属性</span></div><div class="line"><span class="keyword">var</span> key = newObject[<span class="string">"someKey"</span>];</div><div class="line"></div><div class="line"><span class="comment">//ECMAScript 5 仅兼容性形式</span></div><div class="line"><span class="comment">//3.Object.defineProperty方式</span></div><div class="line"></div><div class="line"><span class="comment">//设置属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(newObject, <span class="string">"someKey"</span>, &#123;</div><div class="line">  <span class="attr">value</span>: <span class="string">"hello world"</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//如果上面的方式你感到难以阅读，可以简短的写成下面这样：</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> defineProp = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key, value</span>)</span>&#123;</div><div class="line">  config.value = value;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, config);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为了使用它，我么需要创建一个"person"对象</span></div><div class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//用属性构造对象</span></div><div class="line">defineProp(person, <span class="string">"car"</span>, <span class="string">"Delorean"</span>);</div><div class="line">defineProp(person, <span class="string">"dateOfBirth"</span>, <span class="string">"1981"</span>);</div><div class="line">defineProp(person, <span class="string">"hasBeard"</span>, <span class="string">"false"</span>);</div><div class="line"></div><div class="line"><span class="comment">//4.Object.defineProperties方式</span></div><div class="line"><span class="built_in">Object</span>.defineProperties(newObject, &#123;</div><div class="line">  <span class="string">"someKey"</span>: &#123;</div><div class="line">     <span class="attr">value</span>: <span class="string">"Hello World"</span>,</div><div class="line">     <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">   &#125;,</div><div class="line"></div><div class="line">   <span class="string">"anotherKey"</span>: &#123;</div><div class="line">     <span class="attr">value</span>: <span class="string">"Foo bar"</span>,</div><div class="line">     <span class="attr">writable</span>: <span class="literal">false</span></div><div class="line">   &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 3和4中的读取属行可用1和2中的任意一种</span></div></pre></td></tr></table></figure></p>
<p>在这本书的后面，这些方法会被用于继承，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个继承与person的赛车司机</span></div><div class="line"><span class="keyword">var</span> driver = <span class="built_in">Object</span>.create(person);</div><div class="line"></div><div class="line"><span class="comment">//设置司机的属性</span></div><div class="line">defineProp(driver, <span class="string">"topSpeed"</span>, <span class="string">"100mph"</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取继承的属性</span></div><div class="line"><span class="built_in">console</span>.log(driver.dateOfBirth);</div><div class="line"></div><div class="line"><span class="comment">//获取我们设置的属性</span></div><div class="line"><span class="built_in">console</span>.log(driver.topSpeed);</div></pre></td></tr></table></figure></p>
<h3 id="基础构造器"><a href="#基础构造器" class="headerlink" title="基础构造器"></a>基础构造器</h3><p>正如我们先前所看到的，javascript不支持类的概念，但它有一种与对象一起工作的构造器函数。使用new关键字来调用该函数，我们可以告诉JavaScript把这个函数当做一个构造器来用，它可以用自己所定义的成员来初始化一个对象。</p>
<p>在这个构造器内部，关键字this引用到刚被创建的对象。回到对象创建，一个基本的构造函数看起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">model, year, miles</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.model = model;</div><div class="line">  <span class="keyword">this</span>.year = year;</div><div class="line">  <span class="keyword">this</span>.miles = miles;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="keyword">this</span>.miles;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用，我们可以实例化一个Car</span></div><div class="line"><span class="keyword">var</span> civic = <span class="keyword">new</span> Car(<span class="string">"Honda Civic"</span>, <span class="number">2009</span>, <span class="number">20000</span>);</div><div class="line"><span class="keyword">var</span> mondeo = <span class="keyword">new</span> Car(<span class="string">"Ford Mondeo"</span>, <span class="number">2010</span>, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="comment">//output of the toString() method being called on these objects</span></div><div class="line"><span class="built_in">console</span>.log(civic.toString());</div><div class="line"><span class="built_in">console</span>.log(mondeo.toString());</div></pre></td></tr></table></figure></p>
<p>上面这是个简单版本的构造器模式，但它还是有些问题。一个是难以继承，另一个是每个Car构造函数创建的对象中，toString()之类的函数都被重新定义。这不是非常好，理想的情况是所有Car类型的对象都应该应用同一个函数。ECMAScript3和ECMAScript5-兼容版，对于构造对象他们提供了另外一些选择，解决限制小菜一碟。</p>
<h3 id="使用“原型”的构造器"><a href="#使用“原型”的构造器" class="headerlink" title="使用“原型”的构造器"></a>使用“原型”的构造器</h3><p>在JavaScript中函数有一个prototype的属性。当我们调用JavaScript的构造器创建一个对象时，构造函数prototype上的属性对于所创建的对象来说都可见。照这样，就可以创建多个访问相同prototype的Car对象了。下面，我们来扩展一下原来的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">model, year, miles</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.model = model;</div><div class="line">  <span class="keyword">this</span>.year = year;</div><div class="line">  <span class="keyword">this</span>.miles = miles;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Car.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="string">" has done "</span> + <span class="keyword">this</span>.miles + <span class="string">" miles"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> civic = <span class="keyword">new</span> Car( <span class="string">"Honda Civic"</span>, <span class="number">2009</span>, <span class="number">20000</span> );</div><div class="line"><span class="keyword">var</span> mondeo = <span class="keyword">new</span> Car( <span class="string">"Ford Mondeo"</span>, <span class="number">2010</span>, <span class="number">5000</span> );</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( civic.toString() );</div><div class="line"><span class="built_in">console</span>.log( mondeo.toString() );</div></pre></td></tr></table></figure></p>
<p>通过上面的代码，单个toString()实例被所有的Car对象所共享。</p>
<h2 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h2><p><strong>模块</strong><br>模块是任何健壮的应用程序体系结构不可或缺的一部分，特点是有助于保持应用项目的代码单元技能清晰地分离又有组织。<br>在JavaScript中，实现模块有几个选项，他们包括：</p>
<ul>
<li>模块化模式</li>
<li>对象表示法</li>
<li>AMD模块</li>
<li>CommonJS模块</li>
<li>ECMAScript Harmony模块<br>模块化模式是基于对象的文字部分。</li>
</ul>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>在对象字面值的标记里，一个对象被描述为一组以逗号分隔的名称/值对括在大括号({})的集合。对象内部的名称可以是字符串或是标记符后跟着一个冒号”:”。在对象里最后一个名称/值对不应该以”,”为结束符，因为这样会导致错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObjectLiteral = &#123;</div><div class="line">  <span class="attr">variableKey</span>: variableValue,</div><div class="line">  <span class="attr">functionKey</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象字面量不要求使用新的操作实例，但是不能够在结构体开始使用，因为打开”{“可能被解释为一个块的开始。在对象外新的成员会被加载，使用分配如下：smyModule.prototype = “someValue”;下面我们可以看到一个更完整的使用对象字面值定义一个模块的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = &#123;</div><div class="line">  <span class="attr">myProperty</span>: <span class="string">"someValue"</span>,</div><div class="line">  <span class="attr">myConfig</span>: &#123;</div><div class="line">    <span class="attr">useCaching</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">language</span>: <span class="string">"en"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Where in the world is Paul Irish today?"</span> );</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Caching is:"</span> + ( <span class="keyword">this</span>.myConfig.useCaching ) ? <span class="string">"enabled"</span> : <span class="string">"disabled"</span> );</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">myMethod3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> newConfig </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> newConfig === <span class="string">"object"</span> ) &#123;</div><div class="line">      <span class="keyword">this</span>.myConfig = newConfig;</div><div class="line">      <span class="built_in">console</span>.log( <span class="keyword">this</span>.myConfig.language );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 输出: Where in the world is Paul Irish today?</span></div><div class="line">myModule.myMethod();</div><div class="line"></div><div class="line"><span class="comment">// 输出: enabled</span></div><div class="line">myModule.myMethod2();</div><div class="line"></div><div class="line"><span class="comment">// 输出: fr</span></div><div class="line">myModule.myMethod3(&#123;</div><div class="line">  <span class="attr">language</span>: <span class="string">"fr"</span>,</div><div class="line">  <span class="attr">useCaching</span>: <span class="literal">false</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用对象字面值可以协助封装和组织你的代码。也就是说，如果我们选择了这种技术，我们可能对模块模式有同样的兴趣。即使使用对象字面值，但也只有一个函数的返回值。</p>
<h3 id="模块化模式-1"><a href="#模块化模式-1" class="headerlink" title="模块化模式"></a>模块化模式</h3><p>模块化模式最初被定义为一种对传统软件工程的类提供私有和公共封装的方法。<br>在JavaScript中，模块化模式用来进一步模拟类的概念，通过这样一种方式：我们可以在一个单一的对象中包含公共/私有的方法和变量，从而从全局范围中屏蔽特定的部分。这个结果是可以减少我们的函数名称与在页面中其他脚本区域定义的函数名称冲突的可能性。</p>
<h3 id="私有信息"><a href="#私有信息" class="headerlink" title="私有信息"></a>私有信息</h3><p>模块模式使用闭包的方式来将“私有信息”，状态和组织结构封装起来。提供了一种将公有和私有方法，变量封装混合在一起的方式，这种方式防止内部信息泄露到全局中，从而避免了和其他开发者发生冲突的可能性。在这种模式下只有公有的API会返回，其它将全部保留在闭包的私有空间中。</p>
<p>这种方法提供了一个比较清晰的解决方案，在只暴露一个接口供其它部分使用的情况下，将执行繁重任务的逻辑保护起来。这个模式非常类似于立即调用函数表达式，但是这种模式返回的是对象，而立即调用函数表达式返回的是一个函数。</p>
<p>需要注意的是，在javaScript事实上没有一个显式的真正意义上的”私有化”概念，因为与传统语言不同，javaScript没有访问修饰符。从技术上将，变量不能被声明为公有的或私有的，因此我们使用函数域的方式去模拟这个概念。在模块模式中，因为闭包的缘故，声明的变量或者方法只在模块内部有效。在返回对象中定义的变量或者方法可以供任何人使用。</p>
<p><strong>例子</strong><br>下面这个例子通过创建一个自包含的模块实现了模块模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">incrementCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> counter++;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">resetCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"counter: "</span>,counter);</div><div class="line">      counter = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">//Increment our counter</span></div><div class="line">testModule.incrementCounter();</div><div class="line"></div><div class="line"><span class="comment">//Check the counter value and reset</span></div><div class="line"><span class="comment">//Outputs: 1</span></div><div class="line">testModule.resetCounter();</div></pre></td></tr></table></figure></p>
<p>在这里我们看到，其它部分的代码不能访问我们的incrementCounter()或者resetCounter()的值。counter变量被完全从全局域中隔离起来了，因此其表现的就像一个私有变量一样，它的存在只局限于模块的闭包内部，因此只有两个函数可以访问counter。我们的方法是有名字空间限制的，因此在我们代码的测试部分，我们需要给所有函数调用前面加上模块的名字(例如:”testModule”)。</p>
<p>当使用模块模式时，我们会发现通过使用简单的模板，对于开始使用模式非常有用。下面是一个模板包好了命名空间，公共变量和私有变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myNamespace = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> myPrivateVar, myPrivateMethod;</div><div class="line"></div><div class="line">  <span class="comment">//A private counter variable</span></div><div class="line">  myPrivateVar = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">//A private function which logs any arguments</span></div><div class="line">  myPrivateMethod = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(foo);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//A public valiable</span></div><div class="line">    myPublicVar: <span class="string">"foo"</span>,</div><div class="line"></div><div class="line">    <span class="comment">//A public function utilizing privates</span></div><div class="line">    myPublicFunction: <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</div><div class="line">      <span class="comment">// Increment our private counter</span></div><div class="line">      myPrivateVar++;</div><div class="line"></div><div class="line">      <span class="comment">// Call our private method using bar</span></div><div class="line">      myPrivateMethod( bar );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>看一下另外一个例子，下面我们看到一个使用这种模式实现的购物车。这个模块完全自包含在一个叫做basketModule全局变量中。模块中的购物车数组是私有的，应用的其他部分不能直接读取。只存在与模块的闭包中，因此只有可以访问其域的方法可以访问这个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> basketModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// privates</span></div><div class="line">  <span class="keyword">var</span> basket = [];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingPrivate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElsePrivate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return an object exposed to the public</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">// Add items to our basket</span></div><div class="line">    addItem: <span class="function"><span class="keyword">function</span>(<span class="params"> values </span>) </span>&#123;</div><div class="line">      basket.push(values);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// Get the count of items in the basket</span></div><div class="line">    getItemCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> basket.length;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// Public alias to a  private function</span></div><div class="line">    doSomething: doSomethingPrivate,</div><div class="line"></div><div class="line">    <span class="comment">// Get the total value of items in the basket</span></div><div class="line">    getTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> q = <span class="keyword">this</span>.getItemCount(),</div><div class="line">          p = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">while</span> (q--) &#123;</div><div class="line">        p += basket[q].price;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>在模块内部，你可能注意到我们返回了另外一个对象。这个自动赋值给了basketModule因此我们可以这样和这个对象交互。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// basketModule returns an object with a public API we can use</span></div><div class="line"></div><div class="line">basketModule.addItem(&#123;</div><div class="line">  <span class="attr">item</span>: <span class="string">"bread"</span>,</div><div class="line">  <span class="attr">price</span>: <span class="number">0.5</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">basketModule.addItem(&#123;</div><div class="line">  <span class="attr">item</span>: <span class="string">"butter"</span>,</div><div class="line">  <span class="attr">price</span>: <span class="number">0.3</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="comment">// Outputs: 2</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.getItemCount() );</div><div class="line"></div><div class="line"><span class="comment">// Outputs: 0.8</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.getTotal() );</div><div class="line"></div><div class="line"><span class="comment">// However, the following will not work:</span></div><div class="line"></div><div class="line"><span class="comment">// Outputs: undefined</span></div><div class="line"><span class="comment">// This is because the basket itself is not exposed as a part of our</span></div><div class="line"><span class="comment">// the public API</span></div><div class="line"><span class="built_in">console</span>.log( basketModule.basket );</div><div class="line"></div><div class="line"><span class="comment">// This also won't work as it only exists within the scope of our</span></div><div class="line"><span class="comment">// basketModule closure, but not the returned public object</span></div><div class="line"><span class="built_in">console</span>.log( basket );</div></pre></td></tr></table></figure></p>
<p>上面的方法都处于basketModule的名字空间中。<br>请注意在上面的basket模块中，域函数是如何在我们所有的函数中被封装起来的，以及我们如何立即调用这个域函数，并且将返回值保存下来。这种方式有以下的优势：</p>
<ul>
<li>可以创建只能被我们模块访问的私有函数。这些函数没有暴露出来(只有一些API是暴露出来的)，它们被认为是完全私有的。</li>
<li>当我们在一个调试器中，需要发现哪个函数抛出异常的时候，可以很容易的看到调用栈，因为这些函数是正常声明的并且是命名的函数。</li>
<li>这种模式同样可以让我们在不同的情况下返回不同的函数。我见过有开发者使用这种技巧用于执行UA测试，目的是为了在它们的模块里面针对IE专门提供一条代码路径，但是现在我们也可以简单的使用特征检测达到相同的目的。</li>
</ul>
<h3 id="Import-mixins-导入混合"><a href="#Import-mixins-导入混合" class="headerlink" title="Import mixins(导入混合)"></a>Import mixins(导入混合)</h3><p>这个变体展示了如何将全局(例如jQuery, Underscore)作为一个参数传入模块的匿名函数。这种方式允许我们导入全局，并且按照我们的想法在本地为这些全局起一个别名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Global module</span></div><div class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params">jQ, _ </span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    jQ(<span class="string">".container"</span>).html(<span class="string">"test"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(_.min([<span class="number">10</span>,<span class="number">5</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">1000</span>]));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">publicMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      privateMethod1();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)(jQuery, _);</div><div class="line"></div><div class="line">myModule.publicMethod();</div></pre></td></tr></table></figure></p>
<h3 id="Exports-导出"><a href="#Exports-导出" class="headerlink" title="Exports(导出)"></a>Exports(导出)</h3><p>这个变体允许我们声明全局对象而不是使用它们，同样也支持在下一个例子中我们将会看到的全局导入的概念。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Global module</span></div><div class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//Module object</span></div><div class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;, privateVariable = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.publicProperty = <span class="string">"Foobar"</span>;</div><div class="line">  <span class="built_in">module</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(privateVariable);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>工具箱和框架特定的模块模式实现。</p>
<p><strong>jQuery</strong><br>因为jQuery编码规范没有规定插件如何实现模块模式，因此有很多方式可以实现模块模式。在下面的例子中，定义了一个library函数，这个函数声明了一个新的库，并且在新的库(例如模块)创建的时候，自动将初始化函数绑定到document的ready上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">library</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">module</span>.init)&#123;</div><div class="line">      <span class="built_in">module</span>.init();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myLibrary = library(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//module implementation</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p><strong>优势</strong><br>既然我们已经看到单例模式很有用，为什么还是使用模块模式呢？首先，对于有面向对象背景的开发者来讲，至少从javascript语言上来讲，模块模式相对于真正的封装概念更清晰。</p>
<p>其次，模块模式支持私有数据，因此在模块模式中，公共部分代码可以访问私有化数据，但是在模块外部，不能访问类的私有部分。</p>
<p><strong>缺点</strong><br>模块模式的缺点是因为我们采用不同的方式访问公有和私有成员，因此当我们想要改变这些成员的可见性的时候，我们不得不在所有使用这些成员的地方修改代码。</p>
<p>我们也不能在对象之后添加的方法里面访问这些私有变量。也就是说，很多情况下，模块模式很有用，并且当使用正确的时候，潜在地可以改善我们代码的结构。</p>
<p>其它缺点包括不能为私有成员创建自动化的单元测试，以及在紧急修复bug时所带来的额外的复杂性。根本没有可能可以对私有成员打补丁。相反地，我们必须覆盖所有的使用存在bug私有成员的公共方法。开发者不能简单的扩展私有成员，因此我们需要记得，私有成员并非它们表面上看上去那么具有扩展性。</p>
<h2 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h2><p>既然我们对模块模式已经有一些了解，让我们看一下改进版本 - Christian Heilmann的启发模块模式。启发模块模式来自于，当Heilmann对这样一个现状的不满，即当我们想要在一个公有方法中调用链另一个公有方法，或者访问公有变量的时候，我们不得不重复主对象的名称。他也不喜欢模块模式中，当想要将某个成员变成公共成员时，修改文字标记的做法。</p>
<p>因此他工作的结果就是一个更新的模式，在这个模式中，我们可以简单地在私有域中定义我们所有的函数和变量，并且返回一个匿名对象，这个对象包含有一些指针，这些指针指向我们想要暴露出来的私有成员，使这些私有成员公有化。</p>
<p>下面给出了一个如何使用暴露式模块模式的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVar = <span class="string">"Ben Cherry"</span>,</div><div class="line">      publicVar = <span class="string">"Hey there!"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Name: "</span> + privateVar);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicSetName</span>(<span class="params"> strName </span>) </span>&#123;</div><div class="line">      privateVar = strName;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicGetName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      privateFunction();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Reveal public pointers to</span></div><div class="line">  <span class="comment">// private functions and properties</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">setName</span>: publicSetName,</div><div class="line">      <span class="attr">greeting</span>: publicVar,</div><div class="line">      <span class="attr">getName</span>: publicGetName</div><div class="line">  &#125;;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">myRevealingModule.setName(<span class="string">"Paul Kinlan"</span>);</div></pre></td></tr></table></figure></p>
<p>这个模式可以用于将私有函数和属性以更加规范的命名方式展现出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateCounter++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        publicIncrement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicIncrement</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateFunction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicGetCount</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> privateCounter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Reveal public pointers to</span></div><div class="line">    <span class="comment">// private functions and properties       </span></div><div class="line"></div><div class="line">   <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">start</span>: publicFunction,</div><div class="line">        <span class="attr">increment</span>: publicIncrement,</div><div class="line">        <span class="attr">count</span>: publicGetCount</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;();</div><div class="line"></div><div class="line">myRevealingModule.start();</div></pre></td></tr></table></figure></p>
<p> <strong>优势</strong><br>这个模式是我们脚本的语法更加一致。同样在模块的最后关于那些函数和变量可以被公共访问也变得更加清晰，增强了可读性。</p>
<p> <strong>缺点</strong><br>这个模式的一个缺点是如果私有函数需要使用公有函数，那么这个公有函数在需要打补丁的时候就不能被重载。因为私有函数仍然使用的是私有的实现，并且这个迷失不能用于公有成员，只用于函数。<br>公有成员使用私有成员也遵循上面不能打补丁的规则。<br>因为上面的原因，使用暴露式模块模式创建的模块相对于原始的模块模式更容易出问题，因此在使用的时候需要小心。</p>
<h2 id="单例模块"><a href="#单例模块" class="headerlink" title="单例模块"></a>单例模块</h2><p>单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。经典的实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。</p>
<p>单例和静态类不同，因为我们可以退出单例的初始化时间。通常这样做是因为，在初始化的时候需要一些额外的信息，而这些信息在声明的时候无法得知。对于并不知晓对单例模式引用的代码来讲，单例模式没有为它们提供一种方式可以简单的获取单例模式。这是因为，单例模式既不返回对象也不返回类，它只返回一种结构。可以类比闭包中的变量不是闭包，提供闭包的函数域是闭包。</p>
<p>在JavaScript语言中，单例服务作为一个从全局空间的代码实现中隔离出来共享的资源空间是为了提供一个单独的函数访问指针。</p>
<p>我们能像这样实现一个单例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//Instance stores a reference to the Singleton</span></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//单例</span></div><div class="line">    <span class="comment">//私有方法和变量</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"I am private"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="string">"I am also private"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">// 共有方法和变量</span></div><div class="line">      publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"The public can see me!"</span> );</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      <span class="attr">publicProperty</span>: <span class="string">"I am also public"</span>,</div><div class="line"></div><div class="line">      <span class="attr">getRandomNumber</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> privateRandomNumber;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//如果存在获取此单例实例，如果不存在创建一个单例实例</span></div><div class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(!instance)&#123;</div><div class="line">        instance = init();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> myBadSingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//存储单例实例的引用</span></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//单例</span></div><div class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">getRandomNumber</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> privateRandomNumber;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//总是创建一个新的实例</span></div><div class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      instance = init();</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="keyword">var</span> singleA = mySingleton.getInstance();</div><div class="line"><span class="keyword">var</span> singleB = mySingleton.getInstance();</div><div class="line"><span class="built_in">console</span>.log( singleA.getRandomNumber() === singleB.getRandomNumber() ); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> badSingleA = myBadSingleton.getInstance();</div><div class="line"><span class="keyword">var</span> badSingleB = myBadSingleton.getInstance();</div><div class="line"><span class="built_in">console</span>.log( badSingleA.getRandomNumber() !== badSingleB.getRandomNumber() ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>创建一个全局访问的单例实例(通常通过MySingleton.getInstance())因为我们不能(至少在静态语言中)直接调用new MySingleton()创建实例。这在javascript语言中是不可能的。<br>单例模式的描述如下：</p>
<ul>
<li>每个类只有一个实例，这个实例必须通过一个广为人知的接口，来被客户访问。</li>
<li>子类如果要扩展这个唯一的实例，客户可以不用修改代码就能使用这个扩展后的实例。<br>关于第二点，可以参考如下的实例，我们需要这样编码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mySingleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>._instance == <span class="literal">null</span>)&#123;</div><div class="line">    <span class="keyword">this</span>._instance = <span class="keyword">new</span> FooSingleton();</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">this</span>._instance = <span class="keyword">new</span> BasicSingleton();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里，getInstance 有点类似于工厂方法，我们不需要去更新每个访问单例的代码。FooSingleton可以是BasicSinglton的子类，并且实现了相同的接口。<br>为什么对于单例模式来讲，延迟执行这么重要？</p>
<p><strong>在C++代码中，单例模式将不可预知的动态初始化顺序问题隔离掉，将控制权返回给程序员。</strong><br>区分类的静态实例和单例模式很重要：尽管单例模式可以被实现成一个静态实例，但是单例可以懒构造，在真正用到之前，单例模式不需要分配资源或者内存。<br>如果我们有个静态对象可以被直接初始化，我们需要保证代码总是以同样的顺序执行当你有很多源文件的时候，这种方式没有可扩展性。<br>单例模式和静态对象都很有用，但是不能滥用-同样的我们也不能滥用其他模式。<br>在实践中，当一个对象需要和另外的对象进行跨系统协作的时候，单例模式很有用。下面是一个单例模式在这种情况下使用的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SingletonTester = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// options: an object containing configuration options for the singleton</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    options = options || &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"SingletonTesterer"</span>;</div><div class="line">    <span class="keyword">this</span>.pointX = options.pointX || <span class="number">6</span>;</div><div class="line">    <span class="keyword">this</span>.pointY = options.pointX || <span class="number">10</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line">  <span class="keyword">var</span> _static = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"SingletonTesterer"</span>,</div><div class="line">    <span class="attr">getInstance</span>: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(instance === <span class="literal">undefined</span>)&#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton(options);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> _static;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> singletonTest = SingletonTesterer.getInstance(&#123;</div><div class="line">  <span class="attr">pointX</span>: <span class="number">5</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(singletonTest.pointX);</div></pre></td></tr></table></figure></p>
<p>尽管单例模式有着合理的使用需求，但是通常当我们发现自己需要在javascript使用它的时候，这是一种信号，表明我们可能需要去重新评估自己的设计。<br>这通常表明系统中的模块要么紧耦合要么逻辑过于分散在代码库的多个部分。单例模式更难测试，因为可能有多种多样的问题出现，例如隐藏的依赖关系，很难去创建多个实例，很难理清依赖关系，等等。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是这样一种设计模式。一个被称作被观察者的对象，维护一组被称为观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给它们。</p>
<p>当一个被观察者需要将一些变化通知给观察者的时候，它将采用广播的方式，这条广播可能包含特定于这条通知的一些数据。</p>
<p>当特定的观察者不再需要接受来自于它所注册的被观察者通知的时候，被观察者可以将其从所维护的组中删除。在这里提及一下设计模式现有的定义很有必要。这个定义是与所使用的语言无关的。通过这个定义，最终我们可以更深层次地了解设计模式如何使用以及其优势。在四人帮的《设计模式：可重用的面向对象软件的元素》这本书中，是这样定义观察者模式的：</p>
<p>一个或者更多的观察者对一个被观察者的状态感兴趣，将自身的这种感兴趣通过附着自身的方式注册在被观察者身上。防备观察者发生变化，而这种便可也是观察者所关心的，就会产生一个通知，这个通知将会被送出去，最后将会调用每个观察者的更新方法。当观察者不在对被观察者的状态感兴趣的时候，它们只需要简单的将自身剥离即可。</p>
<p>我们现在可以通过实现一个观察者模式来进一步扩展我们刚才所学的东西。这个实现包含以下组件：</p>
<ul>
<li>被观察者：维护一组观察者，提供用于增加和移除观察者的方法。</li>
<li>观察者：提供一个更新接口，用于当被观察者状态变化时，得到通知。</li>
<li>具体的被观察者：状态变化时广播通知给观察者，保持具体的观察者的信息。</li>
<li>具体的观察者：保持一个纸箱具体被观察者的引用，实现一个更新接口，用于观察，以便保证自身状态总是和被观察者状态一致的。</li>
</ul>
<p>首先，让我们对被观察者可能有的一组依赖其的观察者进行建模：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Add = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.push(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observerList = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Get = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(index &gt; <span class="number">-1</span> &amp;&amp; index &lt; <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList[index]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.Insert = <span class="function"><span class="keyword">function</span>(<span class="params">obj,index</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> pointer = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.unshift(obj);</div><div class="line">    pointer = index;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.push(obj);</div><div class="line">    pointer = index;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> pointer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObserverList.prototype.IndexOf = <span class="function"><span class="keyword">function</span>(<span class="params">obj,startIndex</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i = startIndex, pointer = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span>(i&lt; <span class="keyword">this</span>.observerList.length)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.observerList[i] === obj)&#123;</div><div class="line">      pointer = i;</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> pointer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ObserverList.prototype.RemoveAt = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.shift();</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="keyword">this</span>.observerList.length <span class="number">-1</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.observerList.pop();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//Extend an object with an extension</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">extension, obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> extension)&#123;</div><div class="line">    obj[key] = extension[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着，我们对被观察者以及其增加、删除，通知在观察者列表中的观察者的能力进行建模：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Subject.prototype.AddObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.Add(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Subject.prototype.RemoveObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.observers.RemoveAt(<span class="keyword">this</span>.observers.IndexOf(observer,<span class="number">0</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Subject.prototype.Notify = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> observerCount = <span class="keyword">this</span>.observers.Count();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; observerCount; i++)&#123;</div><div class="line">    <span class="keyword">this</span>.observers.Get(i).Update(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们接着定义建立新的观察者的一个框架。这里的update函数之后会被具体的行为覆盖。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//The Observer</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们的样例应用里面，我们使用上面的观察者组件，现在我们定义：</p>
<ul>
<li>一个按钮，这个按钮用于增加新的充当观察者的选择框到页面上</li>
<li>一个控制用的额选择框，充当一个被观察者，通知其它选择框是否用该被选中</li>
<li>一个容器，用于放置新的选择框</li>
</ul>
<p>我们接着定义具体被观察者和具体观察者，用于给页面增加新的观察者，以及实现更新接口。通过查看下面的内联的注释，搞清楚在我们的样例中的这些组件是如何工作的。</p>
<p><strong>HTML</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button id="addNewObserver"&gt;Add New Observer checkbox&lt;/button&gt;</div><div class="line">&lt;input id="mainCheckbox" type="checkbox"/&gt;</div><div class="line">&lt;div id="observersContainer"&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Sample script</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们DOM 元素的引用</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> controlCheckbox = <span class="built_in">document</span>.getElementById( <span class="string">"mainCheckbox"</span> ),</div><div class="line">addBtn = <span class="built_in">document</span>.getElementById( <span class="string">"addNewObserver"</span> ),</div><div class="line">container = <span class="built_in">document</span>.getElementById( <span class="string">"observersContainer"</span> );</div><div class="line"></div><div class="line"><span class="comment">// 具体的被观察者</span></div><div class="line"></div><div class="line"><span class="comment">//Subject 类扩展controlCheckbox 类</span></div><div class="line">extend( <span class="keyword">new</span> Subject(), controlCheckbox );</div><div class="line"></div><div class="line"><span class="comment">//点击checkbox 将会触发对观察者的通知</span></div><div class="line">controlCheckbox[<span class="string">"onclick"</span>] = <span class="keyword">new</span> <span class="built_in">Function</span>( <span class="string">"controlCheckbox.Notify(controlCheckbox.checked)"</span> );</div><div class="line"></div><div class="line">addBtn[<span class="string">"onclick"</span>] = AddNewObserver;</div><div class="line"></div><div class="line"><span class="comment">// 具体的观察者</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddNewObserver</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">//建立一个新的用于增加的checkbox</span></div><div class="line">  <span class="keyword">var</span> check  = <span class="built_in">document</span>.createElement( <span class="string">"input"</span> );</div><div class="line">  check.type = <span class="string">"checkbox"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 使用Observer 类扩展checkbox</span></div><div class="line">  extend( <span class="keyword">new</span> Observer(), check );</div><div class="line"></div><div class="line">  <span class="comment">// 使用定制的Update函数重载</span></div><div class="line">  check.Update = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.checked = value;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 增加新的观察者到我们主要的被观察者的观察者列表中</span></div><div class="line">  controlCheckbox.AddObserver( check );</div><div class="line"></div><div class="line">  <span class="comment">// 将元素添加到容器的最后</span></div><div class="line">  container.appendChild( check );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子里面，我们看到了如何实现和配置观察者模式，了解了被观察者，观察者，具体被观察者，具体观察者的概念。</p>
<p><strong>观察者模式和发布/订阅模式的不同</strong><br>观察者模式确实有用，但是在javaScript世界里面，通常我们使用一种叫做发布/订阅模式的变体来实现观察者模式。这两种模式很相似，但是也有一些值得注意的不同。</p>
<p>观察者模式要求想要接收相关通知的观察者必须到发起这个事件的被观察者上注册这个事件。</p>
<p>发布/订阅模式使用一个主题/事件频道，这个频道处于想要获取通知的订阅者和发起事件的发布者之间。这个事件系统允许代码定义应用相关的事件，这个事件可以传递特殊的参数，参数中包含有订阅者所需要的值。这种想法是为了避免订阅者和发布者之间的依赖性。</p>
<p>这种和观察者模式之间的不同，使订阅者可以实现一个合适的事件处理函数，用于注册和接受由发布者广播的相关通知。</p>
<p>这里给出一个关于如何使用发布者/订阅者模式的例子，这个例子中完整地实现了功能强大的publish(), subscribe() 和 unsubscribe()。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个非常简单的邮件处理器</span></div><div class="line"><span class="comment">//接受的消息的计数器</span></div><div class="line"><span class="keyword">var</span> mailCounter = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//初始化一个订阅者，这个订阅者监听名叫"indox/newMessage"的频道</span></div><div class="line"></div><div class="line"><span class="comment">//渲染新消息的粗略信息</span></div><div class="line"><span class="keyword">var</span> subscribe1 = subscribe(<span class="string">"inbox/newMessage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic,data</span>)</span>&#123;</div><div class="line">  <span class="comment">//日志记录主题，用于调试</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"A new message was received: "</span>, topic);</div><div class="line"></div><div class="line">  <span class="comment">//使用来自于被观察者的数据，用于给用户展示一个消息的粗略信息</span></div><div class="line">  $(<span class="string">".messageSender"</span>).html(data.sender);</div><div class="line">  $(<span class="string">".messagePriview"</span>).html(data.body);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//这是另外一个订阅者，使用相同的数据执行不同的任务</span></div><div class="line"><span class="comment">//更新计数器，显示当前来自于发布者的新信息的数量</span></div><div class="line"><span class="keyword">var</span> subscribe2 = subscribe(<span class="string">"inbox/newMessage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic,data</span>)</span>&#123;</div><div class="line">  $(<span class="string">".newMessageCounter"</span>).html(mailCounter++);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">publish(<span class="string">"inbox/newMessage"</span>,[&#123;</div><div class="line">  <span class="attr">sender</span>: <span class="string">"hello@ceair.com"</span>,</div><div class="line">  <span class="attr">body</span>: <span class="string">"Hello world!"</span></div><div class="line">&#125;]);</div><div class="line"></div><div class="line"><span class="comment">//在之后，我们可以让我们的订阅者通过下面的方式取消订阅来自于新主题的通知</span></div><div class="line"><span class="comment">//unsubscribe(subscribe1);</span></div><div class="line"><span class="comment">//unsubscribe(subscribe2);</span></div></pre></td></tr></table></figure></p>
<p>这个例子的更广的意义是对松耦合的原则的一种推崇。不是一个对象直接调用另外一个对象的方法，而是通过订阅另外一个对象的一个特定的任务或者活动，从而在这个任务或者活动出现的时候得到通知。</p>
<p><strong>优势</strong><br>观察者和发布/订阅模式鼓励人们认真考虑应用不同部分之间的关系，同时帮助我们找出这样的层，该层中包含有直接的关系，这些关系可以通过一系列的观察者和被观察者来替换掉。这种方式可以有效地将一个应用程序切割成小块，这些小块耦合度低，从而改善代码的管理，以及用于潜在的代码复用。</p>
<p>使用观察者模式更深层次的动机是，当我们需要维护相关对象的一致性的时候，我们可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。</p>
<p>两种模式下，观察者和被观察者之间都可以存在动态关系。这提供很好的灵活性，而当我们的应用中不同的部分之间紧密耦合的时候，是很难实现这种灵活性的。</p>
<p>尽管这些模式并不是万能的灵丹妙药，这些模式仍然是作为最好的设计松耦合系统的工具之一，因此在任何的JavaScript开发者的工具箱里面，都应该有这样一个重要的工具。</p>
<p><strong>缺点</strong><br>事实上，这些模式的一些问题实际上正是来自于它们所带来的一些好处。在发布/订阅模式中，将发布者共订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。</p>
<p>例如，发布者可以假设有一个或者多个订阅者正在监听他们。比如我们基于这样的假设，在某些应用处理过程中来记录或者输出错误日志。如果订阅者执行日志功能崩溃了，因为系统本身的解耦本质，发布者没有办法感知到这些事情。</p>
<p>另外一个这种模式的缺点是，订阅者对彼此之间存在没有感知，对切换发布者的代价无从得知。因为订阅者和发布者之间的动态关系，更新依赖也很难去追踪。</p>
<p><strong>发布/订阅实现</strong><br>发布/订阅在JavaScript的生态系统中非常合适，主要是因为作为核心的ECMAScript实现是事件驱动的。尤其是在浏览器环境下更是如此，因为DOM使用事件作为其主要的用于脚本的交互API。</p>
<p>也就是说，无论是ECMAScript还是DOM都没有在实现代码中提供核心对象或者方法用于创建定制的事件系统。</p>
<p>幸运的是，流行的JavaScript库例如dojo, jQuery(定制事件)以及YUI已经有相关的工具，可以帮助我们方便的实现一个发布/订阅者系统。下面我们看一些例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发布</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).trigger("channel", [arg1, arg2, arg3]);</span></div><div class="line">$( el ).trigger( <span class="string">"/login"</span>, [&#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125;] );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.publish("channel", [arg1, arg2, arg3] );</span></div><div class="line">dojo.publish( <span class="string">"/login"</span>, [&#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125;] );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.publish("channel", [arg1, arg2, arg3]);</span></div><div class="line">el.publish( <span class="string">"/login"</span>, &#123;<span class="attr">username</span>:<span class="string">"test"</span>, <span class="attr">userData</span>:<span class="string">"test"</span>&#125; );</div><div class="line"></div><div class="line"><span class="comment">// 订阅</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).on( "channel", [data], fn );</span></div><div class="line">$( el ).on( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>)</span>&#123;...&#125; );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.subscribe( "channel", fn);</span></div><div class="line"><span class="keyword">var</span> handle = dojo.subscribe( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;..&#125; );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.on("channel", handler);</span></div><div class="line">el.on( <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;...&#125; );</div><div class="line"></div><div class="line"><span class="comment">// 取消订阅</span></div><div class="line"></div><div class="line"><span class="comment">// jQuery: $(obj).off( "channel" );</span></div><div class="line">$( el ).off( <span class="string">"/login"</span> );</div><div class="line"></div><div class="line"><span class="comment">// Dojo: dojo.unsubscribe( handle );</span></div><div class="line">dojo.unsubscribe( handle );</div><div class="line"></div><div class="line"><span class="comment">// YUI: el.detach("channel");</span></div><div class="line">el.detach( <span class="string">"/login"</span> );</div></pre></td></tr></table></figure></p>
<p>尤其对于jQuery 开发者来讲，他们拥有很多其它的选择，可以选择大量的良好实现的代码，从Peter Higgins 的jQuery插件到Ben Alman 在GitHub 上的（优化的）发布/订阅 jQuery gist。下面给出了这些代码的链接。</p>
<ul>
<li><a href="https://gist.github.com/661855" target="_blank" rel="external">Ben Alman的发布/订阅 gist(推荐)</a></li>
<li><a href="https://gist.github.com/705311" target="_blank" rel="external">Rick Waldron 在上面基础上修改的 jQuery-core 风格的实现</a></li>
<li><a href="http://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js" target="_blank" rel="external">Peter Higgins 的插件</a></li>
<li><a href="http://amplifyjs.com/" target="_blank" rel="external">AppendTo 在AmplifyJS中的 发布/订阅实现</a></li>
<li><a href="https://gist.github.com/826794" target="_blank" rel="external">Ben Truyman的 gist</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/JavaScript秘密花园/" itemprop="url">
                  JavaScript秘密花园
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T16:22:23+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/JavaScript秘密花园/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/JavaScript秘密花园/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Laughing is the most touching mask.</p>
</blockquote>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象使用和属性"><a href="#对象使用和属性" class="headerlink" title="对象使用和属性"></a>对象使用和属性</h3><p>JavaScript中所有变量都可以当作对象使用，除了两个例外<code>null</code>和<code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="literal">false</span>.toString(); <span class="comment">//'false'</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString(); <span class="comment">//'1,2,3'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.bar = <span class="number">1</span>;</div><div class="line">Foo.bar; <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.</span>toString(); <span class="comment">//SyntaxError</span></div></pre></td></tr></table></figure></p>
<p>有很多变通方法可以让数字的字面值看起来像对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.</span>.toString(); <span class="comment">//第二个点号可以正常解析</span></div><div class="line"><span class="number">2</span> .toString(); <span class="comment">//注意点号前面的空格</span></div><div class="line">(<span class="number">2</span>).toString(); <span class="comment">//2先被计算</span></div></pre></td></tr></table></figure></p>
<h3 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h3><p>JavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。<br>使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从<code>Object.prototye</code>继承下来，没有任何自定义属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;; <span class="comment">//一个空对象</span></div><div class="line"><span class="comment">//一个新对象，拥有一个值为12的自定义属性'test'</span></div><div class="line"><span class="keyword">var</span> bar = &#123;<span class="attr">test</span>: <span class="number">12</span>&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>: <span class="string">'kitten'</span>&#125;;</div><div class="line">foo.name; <span class="comment">// kitten</span></div><div class="line">foo[<span class="string">'name'</span>]; <span class="comment">// kitten</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> get = <span class="string">'name'</span>;</div><div class="line">foo[get]; <span class="comment">// kitten</span></div><div class="line"></div><div class="line">foo<span class="number">.1234</span>; <span class="comment">// SyntaxError</span></div><div class="line">foo[<span class="string">'1234'</span>]; <span class="comment">// works</span></div></pre></td></tr></table></figure></p>
<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>
<ul>
<li>动态设置属性</li>
<li>属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)</li>
</ul>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>删除属性的唯一方法是使用<code>delete</code>操作符;设置属性为<code>undefined</code>或者<code>null</code>并不能真正的删除属性，而仅仅是移除了属性和值的关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">bar</span>: <span class="number">1</span>, <span class="attr">foo</span>:<span class="number">2</span>, <span class="attr">baz</span>:<span class="number">3</span>&#125;;</div><div class="line">obj.bar = <span class="literal">undefined</span>;</div><div class="line">obj.foo = <span class="literal">null</span>;</div><div class="line"><span class="keyword">delete</span> obj.baz;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</div><div class="line">  <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">    <span class="built_in">console</span>.log(i, <span class="string">''</span>+obj[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的输出的结果有<code>bar undefined</code>和<code>foo null</code>只有<code>baz</code>被真正的删除了，所以从输出结果中消失。</p>
<h3 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = &#123;</div><div class="line">  <span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span>,</div><div class="line">  <span class="attr">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出<code>SyntaxError</code>的错误。<br>这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript不包含传统的类继承模型，而是使用prototype原型模型。<br>虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>
<p>第一个不同之处在于JavaScript使用原型链的继承方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line">Foo.prototype = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置Bar的prototype属性为Foo的实例对象</span></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo();</div><div class="line">Bar.prototype.foo = <span class="string">'Hello World'</span>;</div><div class="line"></div><div class="line"><span class="comment">//修正Bar.prototype.constructor为Bar本身</span></div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Bar() <span class="comment">// 创建Bar的一个新实例</span></div><div class="line"></div><div class="line"><span class="comment">//原型链</span></div><div class="line">test [Bar的实例]</div><div class="line">  Bar.prototype [Foo的实例]</div><div class="line">    &#123;<span class="attr">foo</span>: <span class="string">'Hello World'</span>&#125;</div><div class="line">    Foo.prototype</div><div class="line">      &#123;<span class="attr">method</span>: ...&#125;;</div><div class="line">      <span class="built_in">Object</span>.prototype</div><div class="line">        &#123;<span class="attr">toString</span>: ...&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 简单的使用<code>Bar.prototype = Foo.prototype</code>将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用<code>Bar.prototype = Foo</code>，因为这不会执行<code>Foo</code>的原型，而是指向函数<code>Foo</code>。因此原型链将会回溯到<code>Function.prototype</code>而不是<code>Foo.prototype</code>，因此<code>method</code>将不会在<code>Bar</code>的原型链上。</p>
<p>上面的例子中，<code>test</code>对象从<code>Bar.prototype</code>和<code>Foo.prototype</code>继承下来;因此，它能访问<code>Foo</code>的原型方法<code>method</code>。同时，它也能够访问那个定义在原型上的<code>Foo</code>实例属性<code>value</code>。需要注意的是<code>new Bar()</code>不会创造出一个新的<code>Foo</code>实例，而是重复使用它原型上的那个实例；因此，所有的<code>Bar</code>实例都会共享相同的<code>value</code>属性。</p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。<br>到查找到达原型链的顶部-也就是<code>Object.prototype</code>-但是仍然没有找到指定的属性，就会返回<code>undefined</code>。</p>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype = <span class="number">1</span>; <span class="comment">//无效</span></div></pre></td></tr></table></figure></p>
<p>而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。<br>并且，当使用<code>for in</code>循环遍历对象属性时，原型链上的所有的属性都将被访问。</p>
<h3 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是拓展<code>Object.prototype</code>或者其他内置类型的原型对象。<br>这种技术被称之为<code>mobkey patching</code>并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如<code>Prototype</code>，但是为内置类型添加一些非标准的函数仍然不是一个好主意。<br>扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如<code>Array.forEach</code>.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。</p>
<h3 id="hasOwnProperty函数"><a href="#hasOwnProperty函数" class="headerlink" title="hasOwnProperty函数"></a>hasOwnProperty函数</h3><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自<code>Object.prototype</code>的<code>hasOwnProperty</code>方法。<br><code>hasOwnProperty</code>是JavaScript中唯一一个处理属性但是不查找原型链的函数。<br><strong>注意：</strong> 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改Object.prototype</span></div><div class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">goo</span>: <span class="literal">undefined</span>&#125;;</div><div class="line"></div><div class="line">foo.bar; <span class="comment">//1</span></div><div class="line"><span class="string">'bar'</span> <span class="keyword">in</span> foo; <span class="comment">//true</span></div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">//false</span></div><div class="line">foo.hasOwnProperty(<span class="string">'goo'</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>只有<code>hasOwnProperty</code>可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>
<p><strong>hasOwnProperty</strong> 作为属性<br><code>Javascript</code>不会保护<code>hasOwnProperty</code>被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的<code>hasOwnProperty</code>函数来获取正确的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">hasOwnProperty</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">bar</span>: <span class="string">'Here be dragons'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(<span class="string">'bar'</span>) <span class="comment">// 总是返回false</span></div><div class="line"></div><div class="line"><span class="comment">//使用其他对象的hasOwnProperty，并将其上下文设置为foo</span></div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo,<span class="string">'bar'</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code>是唯一可用的方法。同时在使用<code>for in</code>loop遍历对象时，推荐总是使用<code>hasOwnProperty</code>方法，这将会避免原型对象扩展带来的干扰。</p>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h3><p>和<code>in</code>操作符一样，<code>for in</code>循环同样在查找对象属性时遍历原型链上的所有的属性。<br><strong>注意：</strong> <code>for in</code>循环不会遍历那些<code>enumerable</code>设置为<code>false</code>的属性；比如数组的<code>length</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改Object.prototype</span></div><div class="line">Obkect.prototype.bar = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">moo</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出两个属性： bar和moo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于不可能改变<code>for in</code>自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过<code>Object.prototype</code>原型上的额<code>hasOwnProperty</code>函数来完成。</p>
<h3 id="使用hasOwnProperty过滤"><a href="#使用hasOwnProperty过滤" class="headerlink" title="使用hasOwnProperty过滤"></a>使用hasOwnProperty过滤</h3><p><strong>注意：</strong> 由于<code>for in</code>总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//foo 变量是上例中的</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo)&#123;</div><div class="line">  <span class="keyword">if</span>(foo.hasOwnProperty(i))&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个版本的代码是唯一正确的写法。由于我们使用<code>hasOwnProperty</code>，所以这次只输出<code>moo</code>。如果不使用<code>hasOwnProperty</code>，则这段代码在原生对象原型(比如<code>Object.prototype</code>)被扩展时可能会出错。<br>推荐总是使用<code>hasOwnProperty</code>。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明与表达式"><a href="#函数声明与表达式" class="headerlink" title="函数声明与表达式"></a>函数声明与表达式</h3><p>函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p>
<p><strong>函数声明</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">//正常运行，因为foo在代码前已经被创建</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>函数赋值表达式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子把一个匿名函数赋值给变量<code>foo</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; <span class="comment">//'undefined'</span></div><div class="line">foo(); <span class="comment">//Error: TypeError</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>var</code>定义了一个声明语句，对变量<code>foo</code>的解析是在代码运行之前，因此<code>foo</code>变量在代码运行时已经被定义过了。<br>但是由于赋值语句只在运行时执行，因此在相应代码执行之前，<code>foo</code>的值缺省为<code>undefined</code>。</p>
<p><strong>命名函数的赋值表达式</strong><br>另一个特殊的情况是将命名函数赋值给一个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  bar(); <span class="comment">//正常运行</span></div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">//Error: ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>bar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。<br><strong>注意：</strong> 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数<code>foo</code>和<code>bar</code></p>
<h3 id="this的工作原理"><a href="#this的工作原理" class="headerlink" title="this的工作原理"></a>this的工作原理</h3><p>JavaScript有一套完全不同于其他语言的对<code>this</code>的处理机制。在五种不同的情况下，this指向的各不相同。</p>
<p><strong>全局范围内</strong></p>
<blockquote>
<p>this  </p>
</blockquote>
<p>当在全局范围内使用this，它将会指向全局对象。</p>
<p><strong>函数调用</strong></p>
<blockquote>
<p>foo();</p>
</blockquote>
<p>这里的this也会指向全局对象。</p>
<p><strong>方法调用</strong></p>
<blockquote>
<p>test.foo();</p>
</blockquote>
<p>这个例子中，this指向test对象。<em>ES5注意：</em> 在严格模式下，不存在全局变量，这种情况下this将会是undefined。</p>
<p><strong>调用构造函数</strong></p>
<blockquote>
<p>new foo();</p>
</blockquote>
<p>如果函数倾向于和<code>new</code>关键词一块使用，则我们称这个函数是 <em>构造函数</em> 。在函数内部，<code>this</code>指向新创建的对象。</p>
<p><strong>显示的设置this</strong></p>
<blockquote>
<p>function foo(a,b,c){}<br>  var bar = {};<br>  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示<br>  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3</p>
</blockquote>
<p>当使用<code>Function.prototype</code>上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。<br>因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。</p>
<p><strong>常见误解</strong><br>尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// this将会被设置为全局对象(浏览器环境中也就是window对象)</span></div><div class="line">  &#125;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 在对象的字面声明语法中，this不能用来指向对象本身。因此<code>var obj = {me: this}</code>中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。</p>
<p>一个常见的误解是<code>test</code>中的<code>this</code>将会指向<code>Foo</code>对象，实际上不是这样子的。<br>为了在<code>test</code>中获取对<code>Foo</code>对象的引用，我们需要在<code>method</code>函数内部创建一个局部变量指向<code>Foo</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//使用that来指向Foo对象</span></div><div class="line">  &#125;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>that只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。</p>
<h3 id="方法的赋值表达式"><a href="#方法的赋值表达式" class="headerlink" title="方法的赋值表达式"></a>方法的赋值表达式</h3><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = someObject.methodTest;</div><div class="line">test();</div></pre></td></tr></table></figure></p>
<p>上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到<code>someObject</code>对象。<br>虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Bar.prototype = Foo.prototype;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar().method();</div></pre></td></tr></table></figure></p>
<p>让method被调用时，this将会指向Bar的实例对象。</p>
<h3 id="闭包和引用"><a href="#闭包和引用" class="headerlink" title="闭包和引用"></a>闭包和引用</h3><p>闭包是JavaScript一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。因为 <strong>函数</strong> 是JavaScript中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。<br><strong>模拟私有变量</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">start</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> count = start;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      count++;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = Counter(<span class="number">4</span>);</div><div class="line">foo.increment();</div><div class="line">foo.get(); <span class="comment">//5</span></div></pre></td></tr></table></figure></p>
<p>这里,<code>COunter</code>函数返回两个闭包，函数<code>increment</code>和函数<code>get</code>。这两个函数都维持着对外部作用域<code>Counter</code>的引用，因此总可以访问此作用域内定义的变量<code>count</code>。</p>
<p><strong>为什么不可以在外部访问私有变量</strong><br>因为JavaScript中不可以对作用域进行引用或赋值，因此没有办法在外部访问count变量。唯一的途径就是通过那两个闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Counter(<span class="number">4</span>);</div><div class="line">foo.hack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  count = <span class="number">1337</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码不会改变定义在Counter作用域中的count变量的值，因为foo.hack没有定义在那个作用域内。它将会创建或者覆盖全局变量count。</p>
<p><strong>循环中的闭包</strong><br>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>-;i++)&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i)</div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码不会输出数字0到9，而是会输出数字10十次。<br>当console.log被调用的时候，匿名函数保持对外部变量i的引用，此时for循环已经结束，i的值被修改成了10.<br>为了得到想要的结果，需要在每次循环中创建变量i的拷贝。</p>
<p><strong>避免引用错误</strong><br>为了正确的获得循环序号，最好使用 <em>匿名包装器</em> (就是我们通常说的自执行匿名函数)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">  &#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>外部匿名函数会立即执行，并把i作为它的参数，此时函数内e变量就拥有了i的一个拷贝。<br>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p>
<p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">  setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;</div><div class="line">  &#125;)(i),<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>Javascript中每个函数内都能访问一个特别变量<code>arguments</code>。这个变量维持着所有传递到这个函数中的参数列表。<br>arguments变量不是一个数组(Array)。尽管在语法上它有数组相关的属性length，但它不从Array.prototype继承，实际上它是一个对象(Object)。<br><strong>注意：</strong> 由于<code>arguments</code>已经被定义为函数内的一个变量。因此通过<code>var</code>关键字定义<code>arguments</code>或者将<code>arguments</code>声明为一个形式参数，都将导致原生的<code>arguments</code>不会被创建。</p>
<p>因此，无法对<code>arguments</code>变量使用标准的数组方法，比如push、pop或者slice。虽然使用for循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>
<p><strong>转化为数组</strong><br>下面的代码将会创建一个新的数组，包含所有arguments对象中的元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>这个转化比较慢，在性能不好的代码中不推荐这种做法。</p>
<p><strong>传递参数</strong><br>下面是将参数从一个函数传递到另一个函数的推荐做法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  bar.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个技巧是同时使用call和apply，创建一个快速的解绑定包装器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,a,b,c);</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个解绑定的'method'</span></div><div class="line"><span class="comment">//输入参数为:this, arg1, arg2, ...argN</span></div><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//结果： Foo.prototype.method.call(this,arg1,arg2...argN)</span></div><div class="line">  <span class="built_in">Function</span>.call.apply(Foo.prototype.method,<span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的Foo.method函数和下面代码的效果是一样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  Foo.prototype.method.apply(args[<span class="number">0</span>],args.slice(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>自动更新</strong><br><code>arguments</code>对象为其内部属性以及函数形式参数创建getter和setter方法。<br>因此，改变形参的值会影响到<code>arguments</code>对象的值，反之亦然。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">  a; <span class="comment">//2</span></div><div class="line"></div><div class="line">  b = <span class="number">4</span>;</div><div class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>]; <span class="comment">//4</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> d = c;</div><div class="line">  d = <span class="number">9</span>;</div><div class="line">  c; <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)；</div></pre></td></tr></table></figure></p>
<p><strong>性能真相</strong><br>不管它是否有被使用，arguments对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。<br>arguments的getters和setters方法总会被创建；因此使用arguments对性能不会有什么影响。除非是需要对<code>arguments</code>对象的属性进行多次访问。</p>
<p>在严格模式下，arguments的描述有助于我们的理解，请看下面的代码：<br><strong>注意：</strong> ES5提示，这些getters和setters在严格模式下不会被创建。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阐述在ES5的严格模式下`arguments`的特性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span></div><div class="line">  a= <span class="number">42</span>;</div><div class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> pair = f(<span class="number">17</span>);</div><div class="line"><span class="built_in">console</span>.assert(pair[<span class="number">0</span>] === <span class="number">42</span>);</div><div class="line"><span class="built_in">console</span>.assert(pair[<span class="number">1</span>] === <span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>然而，的确有一种情况会显著的影响现在JavaScript引擎的性能。这就是使用arguments.callee。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">arguments</span>.callee; <span class="comment">//do something with this function object</span></div><div class="line">  <span class="built_in">arguments</span>.callee.caller; <span class="comment">//and the calling function object</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigLoop</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</div><div class="line">    foo();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，foo不再是一个单纯的内联函数inlining(指的是解析器可以做内联处理)，因为它需要知道它自己和它的调用者。这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>
<p>因此强烈建议不要使用<code>arguments.callee</code>和它的属性。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JavaScript中的构造函数和其它语言中的构造函数是不同的。通过new关键字方式调用的函数都被认为是构造函数。</p>
<p>在构造函数内部 - 也就是被调用的函数内 - this指向新创建的对象Object。这个新创建的对象的prototye被指向到构造函数的prototye。</p>
<p>如果被调用的函数没有显式的return表达式，则隐式的会返回this对象 - 也就是新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.bar = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.bla);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p>上面代码把Foo作为构造函数调用，并设置新创建对象的prototype为Foo.prototype.</p>
<p>显式的return表达式将会影响返回结果，但仅限于返回的是一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Bar(); <span class="comment">//返回新创建的对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Test(); <span class="comment">//返回的对象</span></div></pre></td></tr></table></figure></p>
<p>new Bar()返回的是新创建的对象，而不是数字的字面值2.因此<code>new Bar().constructor === Bar</code>，但是如果返回的是数字对象，结果就不同了，如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span></div></pre></td></tr></table></figure></p>
<p>这里得到的<code>new Test()</code>是函数返回的对象，而不是通过new关键字新创建的对象，因此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> Test()).value === <span class="literal">undefined</span></div><div class="line">(<span class="keyword">new</span> Test()).foo === <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>如果<code>new</code>被遗漏了，则函数不会返回新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.bla = <span class="number">1</span>; <span class="comment">//获取设置全局参数</span></div><div class="line">&#125;</div><div class="line">Foo(); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>虽然上例在有些情况下也能正常运行，但是由于JavaScript中this的工作原理，这里的this指向全局对象。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>为了不使用new关键字，构造函数必须显示的返回一个值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> value = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Bar.prototype = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar();</div><div class="line">Bar();</div></pre></td></tr></table></figure></p>
<p>上面两种对Bar函数的调用返回的值 完全相同，一个新创建的拥有method属性的对象被返回，其实这里创建了一个闭包。<br>还需要注意，<code>new Bar()</code>并不会改变返回对象的原型(也就是返回对象的原型不会指向Bar.prototype)。因为构造函数的原型会被指向到刚刚创建的新对象，而这里的Bar没有把这个新对象返回，而是返回了一个包含method属性的自定义对象。<br>上面两种方式创建的对象不能访问Bar原型链上的属性，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar1 = <span class="keyword">new</span> Bar()</div><div class="line"><span class="keyword">typeof</span>(bar1.method); <span class="comment">//'function'</span></div><div class="line"><span class="keyword">typeof</span>(bar1.foo); <span class="comment">//'undefined'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar2 = Bar();</div><div class="line"><span class="keyword">typeof</span>(bar2.method); <span class="comment">//'function'</span></div><div class="line"><span class="keyword">typeof</span>(bar2.foo); <span class="comment">//'undefined'</span></div></pre></td></tr></table></figure></p>
<h3 id="通过工厂模式创建新对象"><a href="#通过工厂模式创建新对象" class="headerlink" title="通过工厂模式创建新对象"></a>通过工厂模式创建新对象</h3><p>我们常听到的一条忠告是不要使用new关键字来调用函数，因为如果忘记使用它就会导致错误。<br>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;</div><div class="line">  obj.value = <span class="string">'blub'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> private = <span class="number">2</span>;</div><div class="line">  obj.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> private;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然上面的方式比起new的调用不容易出错，并且可以充分利用私有变量带来的便利，但是随之而来的是一些不好的地方。</p>
<ol>
<li>会占用更多的内容，因为新创建的对象不能共享原型上的方法。</li>
<li>为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li>放弃原型链仅仅是因为防止遗漏new带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<p>虽然遗漏new关键字可能会导致问题，但这并不是放弃使用原型链的借口。最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并坚持下去才是最重要的。</p>
<h3 id="作用域与命名空间"><a href="#作用域与命名空间" class="headerlink" title="作用域与命名空间"></a>作用域与命名空间</h3><p>尽管JavaScript支持一对花括号创建的代码段，但是并不支持块级作用域；而仅仅支持函数作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123; <span class="comment">//一个作用域</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123; <span class="comment">//不是一个作用域</span></div><div class="line">    <span class="comment">//count</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 如果return对象左括号和return不在一行上就会出错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span></div><div class="line">    a + b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</div><div class="line"><span class="comment">//输出undefined</span></div></pre></td></tr></table></figure></p>
<p>如果不是在赋值语句中，而是在return表达式或者函数参数中，{…}将会作为代码段解析，而不是作为对象的字面语法解析。如果考虑到自动分号插入，这可能会导致一些不易察觉的错误。<br>JavaScript中没有显示的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。<br>每次引用一个变量，JavaScript会向上遍历整个作用域知道找到这个变量为止。如果到达全局作用域但是这个变量仍未找到，则会抛出<code>ReferenceError</code>异常。</p>
<p><strong>名称解析顺序</strong><br>JavaScript中的所有作用域，包括全局作用域，都有一个特别的名称this指向当前对象。<br>函数作用域内也有默认的变量arguments，其中包含了传递到函数中的参数。<br>比如，当访问函数内的foo变量时，JavaScript会按照下面顺序查找：</p>
<ol>
<li>当前作用域内是否有<code>var foo</code>的定义。</li>
<li>函数形式参数是否有使用foo名称的。</li>
<li>函数自身是否叫做foo。</li>
<li>回溯到上一级作用域，然后从#1重新开始。</li>
</ol>
<p><strong>命名空间</strong><br>只有一个全局作用域导致的常见错误是命名冲突。在JavaScript中，这可以通过匿名包装器轻松解决。 <em>注意：</em> 自定义arguments参数会阻止原生的arguments对象的创建。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//函数创建一个命名空间</span></div><div class="line"></div><div class="line">  <span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//对外公开的函数，创建了闭包</span></div><div class="line">  &#125;</div><div class="line">&#125;)(); <span class="comment">//立即执行此匿名函数</span></div></pre></td></tr></table></figure></p>
<p>匿名函数被认为是表达式；因此为了可调用新，它们首先会被执行。</p>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//另外两种方式</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</div></pre></td></tr></table></figure></p>
<p>推荐使用匿名包装器，也就是自执行的匿名函数，来创建命名空间。这样不仅可以防止命名冲突，而且有利于程序的模块化。<br>另外，使用全局变量被认为是不好的习惯。这样的代码容易出错并且维护成本较高。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组遍历与属性"><a href="#数组遍历与属性" class="headerlink" title="数组遍历与属性"></a>数组遍历与属性</h3><p>虽然在JavaScript中数组是对象，但是没有好的理由去使用<code>for in循环</code>遍历数组。相反，有一些好的理由不去使用for in遍历数组。<br>由于for in循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用hasOwnProperty函数，因此会比普通的for循环慢上好多倍。</p>
<p><strong>遍历</strong><br>为了达到遍历数组的最佳性能，推荐使用经典的for循环。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,..<span class="number">.1000</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,l=list.length;i&lt;l;i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(list[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码有一个处理，就是通过<code>l = list.length</code>来缓存数组的长度。<br>虽然length是数组的一个属性，但是在每次循环中访问它还是有性能开销。可能最新的JavaScript引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。<br>实际上，不使用缓存数组长度的方式比缓存版本要慢很多。</p>
<p><strong>length属性</strong><br>length属性的getter方式会简单的返回数组的长度，而setter方式会截断数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">foo.length = <span class="number">3</span>;</div><div class="line">foo; <span class="comment">//[1,2,3]</span></div><div class="line"></div><div class="line">foo.length = <span class="number">6</span>;</div><div class="line">foo; <span class="comment">//[1,2,3]</span></div></pre></td></tr></table></figure></p>
<p>在Firebug中查看此时foo的值是：[1,2,3,undefined,undefined,undefined]但是这个结果并不准确，如果你在Chrome的控制台查看foo的结果，你会发现是这样的，[1,2,3]因为在javaScript中undefined是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。<br>为length设置一个更小的值会截断数组，但是增大length属性值不会对数组产生影响。</p>
<p>为了更好的性能，推荐使用普通的for循环并缓存数组的length属性。使用for in遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
<h3 id="Array构造函数"><a href="#Array构造函数" class="headerlink" title="Array构造函数"></a>Array构造函数</h3><p>由于Array的构造函数在如何处理参数时有点模棱两口，因此总是推荐使用数组的字面语法 - [] - 来创建数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//[1,2,3]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//[1,2,3]</span></div><div class="line"></div><div class="line">[<span class="number">3</span>]; <span class="comment">//[3]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'3'</span>); <span class="comment">//['3']</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//[3,4,5]</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[],此数组长度为3</span></div></pre></td></tr></table></figure></p>
<p>由于只有一个参数传递到构造函数中，并且这个参数时数组，构造函数会返回一个length属性被设置为此参数的空数组。需要特别注意的是，此时只有length属性被设置，真正的数组并没有生成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</div><div class="line">arr[<span class="number">1</span>]; <span class="comment">//undefined</span></div><div class="line"><span class="number">1</span> <span class="keyword">in</span> arr; <span class="comment">//false,数组还没有生成</span></div></pre></td></tr></table></figure></p>
<p>这种优先于设置数组长度属性的做法只在少数几种情况下有用，<strong>比如需要循环字符串，可以避免for循环的麻烦。</strong><br><code>new Array(count + 1).join(stringToRepeat);</code><br>new Array(3).join(‘#’) 将会返回##</p>
<p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>typeof操作符(和 instanceof一起)或许是JavaScript中最大的设计缺陷，因为几乎不可能从它们那里得到想要的结果。<br>尽管instanceof还有一些极少数的应用场景，typeof只有一个实际的应用，就是用来检测一个对象是否已经定义或者是否已经赋值，而不是用来检查对象的类型。</p>
<p><strong>JavaScript类型表格</strong><br>| Value | Class | Type |<br>| —— | :——-: | :———– |<br>| “foo” | String | string |<br>| new String(‘foo’) | String | object |<br>| 1.2 | Number | number |<br>| new Number(1.2) | Number | number |<br>| true | Boolean | boolean |<br>| new Boolean(true) | Boolean | object |<br>| new Date() | Date | object |<br>| new Error() | Error | object |<br>| [1,2,3] | Array | object |<br>| new Array(1,2,3) | Array | object |<br>| new Function(“”) | Function | function |<br>| /abc/g | RegExp | object |<br>| new RegExp(“co”) | RegExp | object |<br>| {} | Object | object |<br>| new Object() | Object | object |<br>上面表格中，Type一列表示typeof操作符的运算结果。可以看到，这个值在大多数情况下都返回”object”。<br>Class一列表示对象的内部属性[[Class]]的值。<br>为了获取对象的[[Class]]，我们需要使用定义在Object.prototype上的方法toString。<br>Javascript标准文档中定义：[[Class]]的值只可能是下面字符串中的一个：Arguments、Array、Boolean、Date、Error、Function、JSON、Math、Number、Object、RegExp、String.</p>
<p><strong>对象的类定义</strong><br>JavaScript标准文档只给出了一种获取[[Class]]值的方法，那就是使用Object.prototype.toString<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type,obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="class"><span class="keyword">class</span> </span>= <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !==<span class="literal">null</span> &amp;&amp; <span class="class"><span class="keyword">class</span> </span>=== type;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">//true</span></div><div class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>上面例子中，Object.prototype.toString方法被调用，this被设置为需要获取[[Class]]值的对象。<br>Object.prototype.toString 返回一种标准格式字符串，所以上例可以通过slice截取指定位置的字符串，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">// "[object Object]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>); <span class="comment">// "[object Number]"</span></div></pre></td></tr></table></figure></p>
<p><strong>ES5提示：</strong> 在ECMAScript5中，为了方便，对null和undefined调用Object.prototype.toString方法，其返回值由Object变成了Null和Undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IE8</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//"[object Object]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line"><span class="comment">//Firefox 4</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//"[object Null]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">//"[object Undefined]"</span></div></pre></td></tr></table></figure></p>
<p><strong>测试为定义变量</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> foo !== <span class="string">'undefined'</span></div></pre></td></tr></table></figure></p>
<p>上面代码会检测foo是否已经定义；如果没有定义而直接使用会导致ReferenceError的异常。这是typeof唯一有用的地方。</p>
<p>为了检测一个对象的类型，强烈推荐使用Object.prototype.toString方法；因为这是唯一一个可依赖的方式。正如上面表格所示，typeof的一些返回值在标准文档中并未定义，因此不同的引擎实现可能不同。<br>除非为了检测一个变量是否已经定义，我们应尽量避免使用typeof操作符。</p>
<h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>instanceof操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。如果用来比较内置类型，将会和typeof操作符一样用处不大。</p>
<p><strong>比较自定义对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">//true</span></div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//如果仅仅设置Bar.prototype为函数Foo本身，而不是Foo构造函数的一个实例</span></div><div class="line">Bar.prototype = Foo;</div><div class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>instanceof 比较内置类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></div><div class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>有一点需要注意，instanceof用来比较属于不同javaScript上下文的对象时将会出错，因为他们的构造函数不会是同一个对象。</p>
<p>instanceof操作符应该仅仅用来比较来自同一个JavaScript上下文的自定义对象。正如typeof操作符一样，任何其它的用法都应该是避免的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JavaScript是弱类型语言，所以会在任何可能的情况下应用强制类型转换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的比较结果是：true</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) == <span class="number">10</span>; <span class="comment">// Number.toString() 返回的字符串被再次转换为数字</span></div><div class="line"></div><div class="line"><span class="number">10</span> == <span class="string">'10'</span>;           <span class="comment">// 字符串被转换为数字</span></div><div class="line"><span class="number">10</span> == <span class="string">'+10 '</span>;         <span class="comment">// 同上</span></div><div class="line"><span class="number">10</span> == <span class="string">'010'</span>;          <span class="comment">// 同上</span></div><div class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>) == <span class="literal">false</span>; <span class="comment">// null 被转换为数字 0</span></div><div class="line">                    <span class="comment">// 0 当然不是一个 NaN（译者注：否定之否定）</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的比较结果是：false</span></div><div class="line"><span class="number">10</span> == <span class="number">010</span>;</div><div class="line"><span class="number">10</span> == <span class="string">'-10'</span>;</div></pre></td></tr></table></figure></p>
<p><strong>ES5提示：</strong> 以 0 开头的数字字面值会被作为八进制数字解析。而在ECMAScript 5严格模式下，这个特性被移除了。<br>为了避免上面复杂的强制类型转换，强烈推荐使用严格的等于操作符。 虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。</p>
<p><strong>内置类型的构造函数</strong><br>内置类型（比如 Number 和 String）的构造函数在被调用时，使用或者不使用 new 的结果完全不同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;     <span class="comment">// False, 对象与数字的比较</span></div><div class="line"><span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;         <span class="comment">// True, 数字与数字的比较</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) + <span class="number">0</span> === <span class="number">10</span>; <span class="comment">// True, 由于隐式的类型转换</span></div></pre></td></tr></table></figure></p>
<p>使用内置类型 Number 作为构造函数将会创建一个新的 Number 对象， 而在不使用 new 关键字的 Number 函数更像是一个数字转换器。</p>
<p>另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。</p>
<p>最好的选择是把要比较的值显式的转换为三种可能的类型之一。</p>
<p><strong>转换为字符串</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">''</span> + <span class="number">10</span> === <span class="string">'10'</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>将一个值加上空字符串可以轻松转换为字符串类型</p>
<p><strong>转换为数字</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+<span class="string">'10'</span> === <span class="number">10</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>使用一元的加号操作符，可以把字符串转换为数字。</p>
<p>字符串转换为数字的常用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+<span class="string">'010'</span> === <span class="number">10</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">'010'</span>) === <span class="number">10</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'010'</span>, <span class="number">10</span>) === <span class="number">10</span>  <span class="comment">// 用来转换为整数</span></div><div class="line"></div><div class="line">+<span class="string">'010.2'</span> === <span class="number">10.2</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">'010.2'</span>) === <span class="number">10.2</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'010.2'</span>, <span class="number">10</span>) === <span class="number">10</span></div></pre></td></tr></table></figure></p>
<p><strong>转换为布尔值</strong><br>通过使用两次否操作符，可以把一个值转换为布尔型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></div><div class="line">!!<span class="string">''</span>;      <span class="comment">// false</span></div><div class="line">!!<span class="string">'0'</span>;     <span class="comment">// true</span></div><div class="line">!!<span class="string">'1'</span>;     <span class="comment">// true</span></div><div class="line">!!<span class="string">'-1'</span>     <span class="comment">// true</span></div><div class="line">!!&#123;&#125;;      <span class="comment">// true</span></div><div class="line">!!<span class="literal">true</span>;    <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h3 id="为什么不要使用eval"><a href="#为什么不要使用eval" class="headerlink" title="为什么不要使用eval"></a>为什么不要使用eval</h3><p>eval函数会在当前作用域中执行一段JavaScript代码字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">eval</span>(<span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">//3</span></div><div class="line">foo; <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 但是eval只在被直接调用并且调用函数就是eval本身时，才在当前作用域中执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="keyword">var</span> bar = <span class="built_in">eval</span>;</div><div class="line">  bar(<span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">//2</span></div><div class="line">foo; <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等价于在全局作用域中调用eval，和下面两种写法效果一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：直接调用全局作用域下的 foo 变量</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">window</span>.foo = <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">// 2</span></div><div class="line">foo; <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line">  <span class="built_in">eval</span>.call(<span class="built_in">window</span>, <span class="string">'foo = 3'</span>);</div><div class="line">  <span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line">test(); <span class="comment">// 2</span></div><div class="line">foo; <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>在任何情况下我们都应该避免使用 eval 函数。99.9% 使用 eval 的场景都有不使用 eval 的解决方案。</p>
<p><strong>伪装的eval</strong><br>定时函数setTimeout和setInterval都可以接受字符串作为它们的第一个参数。这个字符串总是在全局作用域中执行，因此eval在这种情况下没有被直接调用。</p>
<p><strong>安全问题</strong><br>eval也存在安全问题，因为它会执行任意传给它的代码，在代码字符串未知或者是来自一个不信任的源时，绝对不要使用eval函数。</p>
<p>绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案， 一个更好的不使用 eval 的解决方案应该得到充分考虑并优先采用。</p>
<h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><p>JavaScript有两个表示‘空’的值，其中比较有用的是undefined.</p>
<p><strong>undefined的值</strong><br>undefined是一个值为undefined的类型。<br>这个语言也定义了一个全局变量，它的值是undefined，这个变量也被称为undefined。但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。</p>
<p>下面的情况会返回undefined值：</p>
<ul>
<li>访问未修改的全局变量undefined。</li>
<li>由于没有定义return表达式的函数隐式返回。</li>
<li>return表达式没有显式的返回任何内容。</li>
<li>访问不存在的属性。</li>
<li>函数参数没有被显式的传递值。</li>
<li>任何被设置为undefined值得变量。</li>
</ul>
<p>处理undefined值得改变<br>由于全局变量undefined只是保存了undefined类型实际值的副本，因此对它赋新值不会改变类型undefined的值。</p>
<p>然而，为了方便其它变量和undefined做比较，我们需要事先获取类型undefined的值。</p>
<p>为了避免可能对undefined值得改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。在调用时，这个参数不会获取任何值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">123</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">sth,foo,undefined</span>)</span>&#123;</div><div class="line">  <span class="comment">//局部作用域里的undefined变量重新获得了'undefined'值</span></div><div class="line">&#125;)(<span class="string">'Hello World'</span>,<span class="number">42</span>)</div></pre></td></tr></table></figure></p>
<p>另外一种达到相同目的方法是在函数内使用变量声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">undefined</span> =  <span class="number">123</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">sth,foo</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="literal">undefined</span>;</div><div class="line">&#125;)(<span class="string">'Hello World'</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p>这里唯一的区别是，在压缩后并且函数内没有其他需要使用var声明变量的情况下，这个版本的代码会多出4个字节的代码。</p>
<p><strong>null的用处</strong><br>JavaScript中的undefined的使用场景类似于其他语言中的null，实际上JavaScript中的null是另一种数据类型。</p>
<p>它在JavaScript内部有一些使用场景(比如声明原型链的终结<code>Foo.prototype = null</code>)，但是大多数情况下都可以使用undefined来代替。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="setTimeout和setInterval"><a href="#setTimeout和setInterval" class="headerlink" title="setTimeout和setInterval"></a>setTimeout和setInterval</h3><p>由于JavaScript是异步的，可以使用setTimeout和setInterval来计划执行函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> id = setTimeout(foo,<span class="number">1000</span>); <span class="comment">//返回一个大于零的数字</span></div></pre></td></tr></table></figure></p>
<p>当setTimeout被调用时，它会返回一个ID标识并且计划在将来大约1000毫秒后调用foo函数。foo函数只会被调用一次。</p>
<p>基于JavaScript引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞 此线程。因此没法确保函数会在setTimeout指定的时刻被调用。</p>
<p>作为第一个参数的函数将会在全局作用域中执行，因此函数内的this将会指向这个全局对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">42</span>;</div><div class="line">  <span class="keyword">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//this指向全局对象</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">//输出undefined</span></div><div class="line">  &#125;;</div><div class="line">  setTimeout(<span class="keyword">this</span>.method, <span class="number">500</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p><strong>setInterval的堆调用</strong><br>setTimeout只会执行回调函数一次，不过setInterval会每隔x毫秒执行函数一次。但是却不鼓励使用这个函数。</p>
<p>当回调函数的执行被阻塞时，setInterval仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//阻塞执行1s</span></div><div class="line">&#125;</div><div class="line">setInterval(foo,<span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码中,foo会执行一次随后被阻塞了一秒钟。</p>
<p>在foo被阻塞的时候，setInterval仍然在组织将来对回调函数的调用。因此，当第一次foo函数调用结束时，已经有10次函数在等待执行。</p>
<p><strong>处理可能的阻塞调用</strong><br>最简单也是最容易控制的方案，是在回调函数内部使用setTimeout函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//阻塞执行1s</span></div><div class="line">  setTimeout(foo,<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>这样不仅封装了setTimeout回调函数，而且阻止了调用指令的堆积，可以有更多的控制。foo函数现在可以控制是否继续执行还是终止执行。</p>
<p><strong>手工清空定时器</strong><br>可以通过将定时时产生的 ID 标识传递给 clearTimeout 或者 clearInterval 函数来清除定时， 至于使用哪个函数取决于调用的时候使用的是 setTimeout 还是 setInterval。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> id = setTimeout(foo, <span class="number">1000</span>);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure></p>
<p><strong>清除所有定时器</strong><br>由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清空"所有"的定时器</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">    clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能还有些定时器不会在上面代码中被清除（译者注：如果定时器调用时返回的 ID 值大于 1000）， 因此我们可以事先保存所有的定时器 ID，然后一把清除。</p>
<p>绝对不要使用字符串作为setTimeout或者setInterval的第一个参数，这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。</p>
<p>另外，应该避免使用setInterval，因为它的定时执行不会被JavaScript阻塞。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/初始Promise/" itemprop="url">
                  初始Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-28T11:21:39+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/28/初始Promise/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/28/初始Promise/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Don’t let yesterday take up too much of today.</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Promise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
<p><strong>语法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123; ... &#125;);</div></pre></td></tr></table></figure></p>
<p><strong>参数</strong><br>executor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Promise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。</p>
<p>Promise对象有以下几种状态：</p>
<ul>
<li>pedding: 初始状态，既不是fulfilled也不是rejected.</li>
<li>fulfilled: 成功的操作</li>
<li>rejected: 失败的操作</li>
</ul>
<p>pending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。</p>
<p>因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用–一种被称为composition的操作。</p>
<p><img src="/images/promise/promises.png" alt="Promise"></p>
<p><code>注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。</code></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Promise.length<br>长度属性，其值为1(构造器参数的数目)<br>Promise.prototype<br>表示Promise构造器的原型</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Promise.all(iterable)<br>返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。<br>Promise.race(iterable)<br>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。<br>Promise.reject(reason)<br>调用Promise的rejected句柄，并返回这个Promise对象<br>Promise.resolve(value)<br>用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。</p>
<h2 id="Promise原型"><a href="#Promise原型" class="headerlink" title="Promise原型"></a>Promise原型</h2><p><strong>原型</strong><br>Promise.prototype.constructor<br>返回创建了实例原型的函数。默认为Promise函数。</p>
<p><strong>方法</strong><br>Promise.prototype.catch(onRejected)<br>添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。</p>
<p>Promise.prototype.then(onFulfilled.onRejected)<br>添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>创建Promise</strong><br>这个小例子展示了Promise的机制。每当<code>&lt;button&gt;</code>被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。<br>这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"log"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  <span class="string">'use strict'</span></div><div class="line">  <span class="keyword">var</span> promiseCount = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> thisPromiseCount = ++promiseCount;</div><div class="line">    <span class="keyword">var</span> log = <span class="built_in">document</span>.getElementById(<span class="string">'log'</span>);</div><div class="line">    log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') 开始(同步代码开始)&lt;br/&gt;'</span>);</div><div class="line"></div><div class="line">    <span class="comment">//我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">      <span class="comment">//完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行</span></div><div class="line">      log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') Promise开始(异步代码开始)&lt;br/&gt;'</span>);</div><div class="line"></div><div class="line">      <span class="comment">//这只是个创建异步完成的示例</span></div><div class="line">      <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//我们满足(fullfil)了这个promise！</span></div><div class="line">        resolve(thisPromiseCount)</div><div class="line">      &#125;,<span class="built_in">Math</span>.random() *<span class="number">2000</span> + <span class="number">1000</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//定义当promise被满足时应做什么</span></div><div class="line">    p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">      <span class="comment">//输出一段信息和一个值</span></div><div class="line">      log.insertAdjacentHTML(<span class="string">'beforeend'</span>,val + <span class="string">') Promise被满足了(异步代码结束)&lt;br/&gt;'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    log.insertAdjacentHTML(<span class="string">'beforeend'</span>,thisPromiseCount + <span class="string">') 建立了Promise(同步代码结束)&lt;br/&gt;&lt;br/&gt;'</span>);</div><div class="line">  &#125;</div><div class="line">  testPromise();</div><div class="line">  testPromise();</div><div class="line">  testPromise();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。</p>
<h2 id="Example-using-new-XMLHttpRequest"><a href="#Example-using-new-XMLHttpRequest" class="headerlink" title="Example using new XMLHttpRequest()"></a>Example using new XMLHttpRequest()</h2><p><strong>创建一个promise</strong><br>这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$http</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> core = &#123;</div><div class="line">    <span class="attr">ajax</span>: <span class="function"><span class="keyword">function</span>(<span class="params">method,url,args</span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        <span class="keyword">var</span> uri = url;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(args &amp;&amp; (method === <span class="string">'POST'</span> || method === <span class="string">'PUT'</span>))&#123;</div><div class="line">          uri += <span class="string">'?'</span>;</div><div class="line">          <span class="keyword">var</span> argcount = <span class="number">0</span>;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> args)&#123;</div><div class="line">            <span class="keyword">if</span>(args.hasOwnProperty(key))&#123;</div><div class="line">              <span class="keyword">if</span>(argcount++)&#123;</div><div class="line">                uri += <span class="string">'&amp;'</span>;</div><div class="line">              &#125;</div><div class="line">              uri += encodeURIcomponent(key) + <span class="string">'='</span> + encodeURIcomponent(args[key]);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        client.open(method, uri);</div><div class="line">        client.send();</div><div class="line"></div><div class="line">        client.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt;<span class="number">300</span>)&#123;</div><div class="line">            resolve(<span class="keyword">this</span>.response);</div><div class="line">          &#125;<span class="keyword">else</span>&#123;</div><div class="line">            reject(<span class="keyword">this</span>.statusText);</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        client.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          reject(<span class="keyword">this</span>.statusText);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//Adapter patten</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'GET'</span>,url,args);</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'post'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'POST'</span>,url,args);</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'delete'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> core.ajax(<span class="string">'DELETE'</span>,url,args);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//End A</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mdnAPI = <span class="string">'https://developer.mozilla.org/en-US/search.json'</span>;</div><div class="line"><span class="keyword">var</span> payload = &#123;</div><div class="line">  <span class="string">'topic'</span>: <span class="string">'js'</span>,</div><div class="line">  <span class="string">'q'</span>: <span class="string">'Promise'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> callback = &#123;</div><div class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>,<span class="string">'success'</span>,<span class="built_in">JSON</span>.parse(data));</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>,<span class="string">'error'</span>,<span class="built_in">JSON</span>.parse(data));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//End B</span></div><div class="line"></div><div class="line"><span class="comment">//Executes the method call</span></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success)</div><div class="line">  .catch(callback.error);</div><div class="line"></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success,callback.error);</div><div class="line"></div><div class="line">$http(mdnAPI)</div><div class="line">  .get(payload)</div><div class="line">  .then(callback.success)</div><div class="line">  .then(<span class="literal">undefined</span>, callback.error);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/使用ServiceWorkers/" itemprop="url">
                  使用ServiceWorkers
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-27T23:02:50+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/使用ServiceWorkers/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/27/使用ServiceWorkers/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Don’t let yesterday take up too much of today.</p>
</blockquote>
<p><code>这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</code></p>
<p>本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。</p>
<h2 id="Service-workers出现的背景"><a href="#Service-workers出现的背景" class="headerlink" title="Service workers出现的背景"></a>Service workers出现的背景</h2><p>有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。</p>
<p>之前的尝试–APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。</p>
<p><code>注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。</code></p>
<p>Service workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。</p>
<h2 id="使用Service-workers前的设置"><a href="#使用Service-workers前的设置" class="headerlink" title="使用Service workers前的设置"></a>使用Service workers前的设置</h2><p>在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：</p>
<ul>
<li>FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；</li>
<li>Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；</li>
<li>Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。</li>
</ul>
<p>另外，你需要通过HTTPS来访问你的页面代码–出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>使用service workers，通常遵循以下基本步骤：</p>
<ol>
<li>service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。</li>
<li>如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。</li>
<li>service worker现在可以处理事件了。</li>
<li>受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的–让所有资源可离线访问。</li>
<li>当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。</li>
<li><p>下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。<br>7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。<br><img src="/images/serviceWorker/sw-lifecycle.png" alt="Worker lifecycle"></p>
<p>下图表示了service worker所有支持的事件：<br><img src="/images/serviceWorker/sw-events.png" alt="Events"></p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promises</a>是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。</p>
<p>Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。</p>
<p>接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：</p>
</li>
</ol>
<p><strong>同步</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="keyword">var</span> value = myFunction();</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125; <span class="keyword">catch</span>(err)&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>异步</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFunction().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。</p>
<p>现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgLoad</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.open(<span class="string">'Get'</span>,url);</div><div class="line">    request.responseType = <span class="string">'blob'</span>;</div><div class="line"></div><div class="line">    request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(request.status == <span class="number">200</span>)&#123;</div><div class="line">        resolve(request.response);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        reject(<span class="built_in">Error</span>(<span class="string">'Image didn\'t load successfully; error code:'</span> + request.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      reject(<span class="built_in">Error</span>(<span class="string">'There was a network error.'</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request.send();</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。</p>
<p>当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</div><div class="line"><span class="keyword">var</span> myImage = <span class="keyword">new</span> Image();</div><div class="line"></div><div class="line">imgLoad(<span class="string">'myLittleVader.jpg'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> imageURL = <span class="built_in">window</span>.URL.createObjectURL(response);</div><div class="line">myImage.src = imageURL;</div><div class="line">body.appendChild(myImage);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">Error</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Error</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/26/初识ServiceWorker/" itemprop="url">
                  初识ServiceWorker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-26T23:50:01+08:00" content="2016-07-26">
              2016-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/26/初识ServiceWorker/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/26/初识ServiceWorker/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>The best preparation for tomorrow is doing your best today.</p>
</blockquote>
<p><code>Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.</code></p>
<h2 id="Service-worker的概念和用法"><a href="#Service-worker的概念和用法" class="headerlink" title="Service worker的概念和用法"></a>Service worker的概念和用法</h2><p>serviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。</p>
<p>service worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。</p>
<p>为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。</p>
<p><code>注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。</code></p>
<p><code>注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。</code></p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>使用<code>ServiceWorkerContainer.register()</code>方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。</p>
<h2 id="下载、安装和激活"><a href="#下载、安装和激活" class="headerlink" title="下载、安装和激活"></a>下载、安装和激活</h2><p>此时，你的service worker会遵守以下的生命周期。</p>
<ol>
<li>下载</li>
<li>安装</li>
<li>激活</li>
</ol>
<p>当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。</p>
<p>之后它会至少每24小时被下载一次。它<strong>可能</strong>被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。</p>
<p>当下载的文件被发现是新的，就会尝试进行安装–无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。</p>
<p>如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。</p>
<p>如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活–此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。</p>
<p>你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。</p>
<p>同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.</p>
<p>service worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。</p>
<p>你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。</p>
<p><code>注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。</code></p>
<h2 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h2><p>Service workers也可以被用来做这些事情：</p>
<ul>
<li>后台数据同步</li>
<li>响应其他源的资源请求</li>
<li>集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了</li>
<li>为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理</li>
<li>为监控后台服务提供钩子</li>
<li>针对特定URL的个性化模板</li>
<li>增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片</li>
</ul>
<p>在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：</p>
<ul>
<li>后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。</li>
<li>对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容</li>
<li>对时间或日期作出响应</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="GaoQ" />
          <p class="site-author-name" itemprop="name">GaoQ</p>
          <p class="site-description motion-element" itemprop="description">There are no shortcuts to any place worth going</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GaoQ</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gaoquan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
